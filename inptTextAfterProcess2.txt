Editorial
Director
Marcia
Horton
Editor
Chief
Michael
Hirsch
Acquisitions
Editor
Matt
Goldstein
Editorial
Assistant
Chelsea
Bell
Assistant
Acquisitions
Editor
Global
Edition
Murchana
Borthakur
Associate
Project
Editor
Global
Edition
Binita
Roy
Managing
Editor
Jeff
Holcomb
Senior
Production
Project
Manager
Marilyn
Lloyd
Director
Marketing
Margaret
Waples
Pearson
Education
Limited
Edinburgh
Gate
Harlow
Essex
CM
JE
England
Associated
Companies
throughout
world
Visit
us
World
Wide
Web
www
pearsonglobaleditions
com
Pearson
Education
Limited
Marketing
Coordinator
Kathryn
Ferranti
Senior
Manufacturing
Buyer
Carol
Melville
Senior
Manufacturing
Controller
Production
Global
Edition
Trudy
Kimber
Text
Designer
Susan
Raymond
Cover
Art
Designer
Lumina
Datamatics
Cover
Image
Andrey
Bayda
Shutterstock
Interior
Chapter
Opener
graficart
net
Alamy
Full
Service
Project
Management
Rashmi
Tickyani
Aptara
Inc
Composition
Illustrations
Aptara
Inc
rights
Ian
Sommerville
identified
author
work
asserted
accordance
Copyright
Designs
Patents
Act
Authorized
adaptation
United
States
edition
entitled
Software
Engineering
th
edition
ISBN
Ian
Sommerville
published
Pearson
Education
rights
reserved
No
part
publication
reproduced
stored
retrieval
system
transmitted
form
means
electronic
mechanical
photocopying
recording
otherwise
without
prior
written
permission
publisher
license
permitting
restricted
copying
United
Kingdom
issued
Copyright
Licensing
Agency
Ltd
Saffron
House
Kirby
Street
London
EC
N
TS
trademarks
used
herein
property
respective
owners
use
trademark
text
vest
author
publisher
trademark
ownership
rights
trademarks
use
trademarks
imply
affiliation
endorsement
book
owners
ISBN
ISBN
British
Library
Cataloguing
Publication
Data
catalogue
record
book
available
British
Library
Typeset
New
Aster
LT
Std
Aptara
Inc
Printed
bound
Courier
Westford
United
States
America
@@@@@@@@@@
@@@@@@@@@@
Preface
Progress
software
engineering
last
years
astonishing
societies
function
without
large
professional
software
systems
National
utilities
infrastructure
energy
communications
transport
rely
complex
mostly
reliable
computer
systems
Software
allowed
us
explore
space
create
World
Wide
Web
significant
information
system
history
mankind
Smartphones
tablets
ubiquitous
entire
apps
industry
developing
software
devices
emerged
past
years
Humanity
now
facing
demanding
set
challenges
climate
change
extreme
weather
declining
natural
resources
increasing
world
population
fed
housed
international
terrorism
need
help
elderly
people
lead
satisfying
fulfilled
lives
need
new
technologies
help
us
address
challenges
sure
software
central
role
technologies
Software
engineering
therefore
critically
important
future
planet
continue
educate
software
engineers
develop
discipline
meet
demand
software
create
increasingly
complex
future
systems
need
course
still
problems
software
projects
Systems
still
sometimes
delivered
late
cost
expected
creating
increasingly
complex
software
systems
systems
surprised
encounter
difficulties
along
way
However
let
problems
conceal
real
successes
software
engineering
impressive
software
engineering
methods
technologies
developed
book
different
editions
now
around
years
edition
based
around
essential
principles
established
first
edition
write
software
engineering
practiced
industry
without
taking
evangelical
position
particular
approaches
agile
development
formal
methods
reality
industry
mixes
techniques
agile
plan
based
development
reflected
book
@@@@@@@@@@
Preface
write
know
understand
many
suggestions
additional
topics
covered
detail
open
source
development
use
UML
mobile
software
engineering
don
t
really
know
enough
areas
work
system
dependability
systems
engineering
reflected
selection
advanced
topics
book
believe
key
issues
modern
software
engineering
managing
complexity
integrating
agility
methods
ensuring
systems
secure
resilient
issues
driver
changes
additions
new
edition
book
Changes
th
edition
summary
major
updates
additions
book
th
edition
extensively
updated
chapter
agile
software
engineering
new
material
Scrum
updated
chapters
required
reflect
increasing
use
agile
methods
software
engineering
added
new
chapters
resilience
engineering
systems
engineering
systems
systems
completely
reorganized
three
chapters
covering
reliability
safety
security
added
new
material
RESTful
services
chapter
covering
service
oriented
software
engineering
revised
updated
chapter
configuration
management
new
material
distributed
version
control
systems
moved
chapters
aspect
oriented
software
engineering
process
improvement
print
version
book
web
site
New
supplementary
material
added
web
site
including
set
supporting
videos
explained
key
topics
video
recommended
related
YouTube
videos
part
structure
book
introduced
earlier
editions
retained
made
significant
changes
part
book
Part
Introduction
software
engineering
completely
rewritten
Chapter
agile
methods
updated
reflect
increasing
use
Scrum
new
case
study
digital
learning
environment
added
Chapter
used
number
chapters
Legacy
systems
covered
detail
Chapter
Minor
changes
updates
made
chapters
@@@@@@@@@@
Preface
Part
covers
dependable
systems
revised
restructured
Rather
activity
oriented
approach
information
safety
security
reliability
spread
several
chapters
reorganized
topic
chapter
right
makes
easier
cover
single
topic
security
part
general
course
added
completely
new
chapter
resilience
engineering
covers
cybersecurity
organizational
resilience
resilient
systems
design
Part
added
new
chapters
systems
engineering
systems
systems
extensively
revised
material
service
oriented
systems
engineering
reflect
increasing
use
RESTful
services
chapter
aspect
oriented
software
engineering
deleted
print
version
remains
available
web
chapter
Part
updated
material
configuration
management
reflect
increasing
use
distributed
version
control
tools
Git
chapter
process
improvement
deleted
print
version
remains
available
web
chapter
important
change
supplementary
material
book
addition
video
recommendations
chapters
made
videos
range
topics
available
YouTube
channel
linked
book
s
web
pages
cases
made
videos
recommended
YouTube
videos
useful
explain
rationale
behind
changes
ve
made
short
video
http
software
engineering
book
videos
th
edition
changes
Readership
book
primarily
aimed
university
college
students
taking
introductory
advanced
courses
software
systems
engineering
assume
readers
understand
basics
programming
fundamental
data
structures
Software
engineers
industry
find
book
useful
general
reading
update
knowledge
topics
software
reuse
architectural
design
dependability
security
systems
engineering
Using
book
software
engineering
courses
designed
book
used
three
different
types
software
engineering
course
General
introductory
courses
software
engineering
first
part
book
designed
support
semester
course
introductory
software
engineering
chapters
cover
fundamental
topics
software
engineering
@@@@@@@@@@
Preface
course
practical
component
management
chapters
Part
substituted
Introductory
intermediate
courses
specific
software
engineering
topics
create
range
advanced
courses
using
chapters
parts
example
taught
course
critical
systems
using
chapters
Part
plus
chapters
systems
engineering
quality
management
course
covering
software
intensive
systems
engineering
used
chapters
systems
engineering
requirements
engineering
systems
systems
distributed
software
engineering
embedded
software
project
management
project
planning
advanced
courses
specific
software
engineering
topics
case
chapters
book
form
foundation
course
supplemented
reading
explores
topic
detail
example
course
software
reuse
based
around
Chapters
Instructors
access
additional
teaching
support
material
Pearson
s
website
password
protected
instructors
using
book
teaching
obtain
password
registering
Pearson
website
material
available
includes
Model
answers
selected
end
chapter
exercises
Quiz
questions
answers
chapter
access
material
www
pearsonglobaleditions
com
Sommerville
Book
website
book
designed
hybrid
print
web
text
core
information
printed
edition
linked
supplementary
material
web
Several
chapters
include
specially
written
web
sections
add
information
chapter
six
web
chapters
topics
covered
print
version
book
download
wide
range
supporting
material
book
s
website
software
engineering
book
com
including
set
videos
cover
range
software
engineering
topics
recommend
YouTube
videos
support
learning
instructor
s
guide
gives
advice
use
book
teaching
different
courses
information
book
s
case
studies
insulin
pump
mental
health
care
system
wilderness
weather
system
digital
learning
system
well
case
studies
failure
Ariane
launcher
@@@@@@@@@@
Preface
Six
web
chapters
covering
process
improvement
formal
methods
interaction
design
application
architectures
documentation
aspect
oriented
development
Web
sections
add
content
presented
chapter
web
sections
linked
breakout
boxes
chapter
PowerPoint
presentations
chapters
book
additional
PowerPoint
presentations
covering
range
systems
engineering
topics
available
pearsonglobaleditions
com
Sommerville
response
requests
users
book
published
complete
requirements
specification
one
system
case
studies
book
s
web
site
difficult
students
get
access
documents
understand
structure
complexity
avoid
confidentiality
issues
re
engineered
requirements
document
real
system
no
restrictions
use
Contact
details
Website
software
engineering
book
com
Email
name
software
engineering
book
domain
gmail
com
Blog
iansommerville
com
systems
software
technology
YouTube
youtube
com
user
SoftwareEngBook
Facebook
facebook
com
sommerville
software
engineering
Twitter
@SoftwareEngBook
@iansommerville
general
tweets
Follow
Twitter
Facebook
get
updates
new
material
comments
software
systems
engineering
Acknowledgements
large
number
people
contributed
years
evolution
book
d
like
thank
everyone
reviewers
students
book
users
commented
previous
editions
made
constructive
suggestions
change
d
particularly
like
thank
family
Anne
Ali
Jane
love
help
support
working
book
previous
editions
Ian
Sommerville
September
@@@@@@@@@@
Contents
glance
Preface
Part
Introduction
Software
Engineering
Chapter
Introduction
Chapter
Software
processes
Chapter
Agile
software
development
Chapter
Requirements
engineering
Chapter
System
modeling
Chapter
Architectural
design
Chapter
Design
implementation
Chapter
Software
testing
Chapter
Software
evolution
Part
System
Dependability
Security
Chapter
Dependable
systems
Chapter
Reliability
engineering
Chapter
Safety
engineering
Chapter
Security
engineering
Chapter
Resilience
engineering
Part
Advanced
Software
Engineering
Chapter
Software
reuse
Chapter
Component
based
software
engineering
Chapter
Distributed
software
engineering
Chapter
Service
oriented
software
engineering
Chapter
Systems
engineering
Chapter
Systems
systems
Chapter
Real
time
software
engineering
Part
Software
management
Chapter
Project
management
Chapter
Project
planning
Chapter
Quality
management
Chapter
Configuration
management
Glossary
Subject
index
Author
index
Pearson
wishes
thank
acknowledge
following
people
work
Global
Edition
Contributor
Sherif
G
Aly
American
University
Cairo
muthuraj
m
Android
developer
Reviewers
mohit
P
Tahiliani
National
Institute
Technology
Karnataka
Surathkal
Chitra
Dhawale
P
R
Patil
Group
Educational
Institutes
Amravati
Sanjeevni
Shantaiya
Disha
Institute
management
Technology
@@@@@@@@@@
contentS
contentS
Preface
Part
Introduction
Software
Engineering
Chapter
Introduction
Professional
software
development
Software
engineering
ethics
Case
studies
Chapter
Software
processes
Software
process
models
Process
activities
Coping
change
Process
improvement
Chapter
Agile
software
development
Agile
methods
Agile
development
techniques
Agile
project
management
Scaling
agile
methods
@@@@@@@@@@
Contents
Chapter
Requirements
engineering
Functional
non
functional
requirements
Requirements
engineering
processes
Requirements
elicitation
Requirements
specification
Requirements
validation
Requirements
change
Chapter
System
modeling
Context
models
Interaction
models
Structural
models
Behavioral
models
model
driven
architecture
Chapter
Architectural
design
Architectural
design
decisions
Architectural
views
Architectural
patterns
Application
architectures
Chapter
Design
implementation
Object
oriented
design
using
UmL
Design
patterns
Implementation
issues
Open
source
development
Chapter
Software
testing
Development
testing
Test
driven
development
@@@@@@@@@@
Contents
Release
testing
User
testing
Chapter
Software
evolution
Evolution
processes
Legacy
systems
Software
maintenance
Part
System
Dependability
Security
Chapter
Dependable
systems
Dependability
properties
Sociotechnical
systems
Redundancy
diversity
Dependable
processes
Formal
methods
dependability
Chapter
Reliability
engineering
Availability
reliability
Reliability
requirements
Fault
tolerant
architectures
Programming
reliability
Reliability
measurement
Chapter
Safety
engineering
Safety
critical
systems
Safety
requirements
Safety
engineering
processes
Safety
cases
@@@@@@@@@@
Contents
Chapter
Security
engineering
Security
dependability
Security
organizations
Security
requirements
Secure
systems
design
Security
testing
assurance
Chapter
Resilience
engineering
Cybersecurity
Sociotechnical
resilience
Resilient
systems
design
Part
Advanced
Software
Engineering
Chapter
Software
reuse
reuse
landscape
Application
frameworks
Software
product
lines
Application
system
reuse
Chapter
Component
based
software
engineering
Components
component
models
CBSE
processes
Component
composition
Chapter
Distributed
software
engineering
Distributed
systems
Client
server
computing
@@@@@@@@@@
Contents
Architectural
patterns
distributed
systems
Software
service
Chapter
Service
oriented
software
engineering
Service
oriented
architecture
RESTful
services
Service
engineering
Service
composition
Chapter
Systems
engineering
Sociotechnical
systems
Conceptual
design
System
procurement
System
development
System
operation
evolution
Chapter
Systems
systems
System
complexity
Systems
systems
classification
Reductionism
complex
systems
Systems
systems
engineering
Systems
systems
architecture
Chapter
Real
time
software
engineering
Embedded
system
design
Architectural
patterns
real
time
software
Timing
analysis
Real
time
operating
systems
@@@@@@@@@@
Contents
Part
Software
Management
Chapter
Project
management
Risk
management
managing
people
Teamwork
Chapter
Project
planning
Software
pricing
Plan
driven
development
Project
scheduling
Agile
planning
Estimation
techniques
COCOmO
cost
modeling
Chapter
Quality
management
Software
quality
Software
standards
Reviews
inspections
Quality
management
agile
development
Software
measurement
Chapter
Configuration
management
Version
management
System
building
Change
management
Release
management
Glossary
Subject
index
Author
index
@@@@@@@@@@
PART
Introduction
Software
Engineering
aim
part
book
provide
general
introduction
software
engineering
chapters
part
designed
support
one
semester
first
course
software
engineering
introduce
important
concepts
software
processes
agile
methods
describe
essential
software
development
activities
requirements
specification
system
evolution
Chapter
general
introduction
introduces
professional
software
engineering
defines
software
engineering
concepts
included
brief
discussion
ethical
issues
software
engineering
important
software
engineers
think
wider
implications
work
chapter
introduces
four
case
studies
use
book
information
system
managing
records
patients
undergoing
treatment
mental
health
problems
Mentcare
control
system
portable
insulin
pump
embedded
system
wilderness
weather
station
digital
learning
environment
iLearn
Chapters
cover
software
engineering
processes
agile
development
Chapter
introduce
software
process
models
waterfall
model
discuss
basic
activities
part
processes
Chapter
supplements
discussion
agile
development
methods
software
engineering
chapter
@@@@@@@@@@
extensively
changed
previous
editions
focus
agile
development
using
Scrum
discussion
agile
practices
stories
requirements
definition
test
driven
development
remaining
chapters
part
extended
descriptions
software
process
activities
introduced
Chapter
Chapter
covers
critically
important
topic
requirements
engineering
requirements
system
defined
Chapter
explains
system
modeling
using
UML
focus
use
use
case
diagrams
class
diagrams
sequence
diagrams
state
diagrams
modeling
software
system
Chapter
discuss
importance
software
architecture
use
architectural
patterns
software
design
Chapter
introduces
object
oriented
design
use
design
patterns
introduce
important
implementation
issues
reuse
configuration
management
host
target
development
discuss
open
source
development
Chapter
focuses
software
testing
unit
testing
system
development
testing
software
releases
discuss
use
test
driven
development
approach
pioneered
agile
methods
wide
applicability
Finally
Chapter
presents
overview
software
evolution
issues
cover
evolution
processes
software
maintenance
legacy
system
management
@@@@@@@@@@
Introduction
Objectives
objectives
chapter
introduce
software
engineering
provide
framework
understanding
rest
book
read
chapter
understand
software
engineering
important
understand
development
different
types
software
system
require
different
software
engineering
techniques
understand
ethical
professional
issues
important
software
engineers
introduced
four
systems
different
types
used
examples
throughout
book
Contents
Professional
software
development
Software
engineering
ethics
Case
studies
@@@@@@@@@@
Chapter
Introduction
Software
engineering
essential
functioning
government
society
national
international
businesses
institutions
t
run
modern
world
without
software
National
infrastructures
utilities
controlled
computer
based
systems
electrical
products
include
computer
controlling
software
Industrial
manufacturing
distribution
completely
computerized
financial
system
Entertainment
including
music
industry
computer
games
film
television
software
intensive
world
s
population
software
controlled
mobile
phone
Internet
enabled
Software
systems
abstract
intangible
constrained
properties
materials
governed
physical
laws
manufacturing
processes
simplifies
software
engineering
no
natural
limits
potential
software
However
lack
physical
constraints
software
systems
quickly
extremely
complex
difficult
understand
expensive
change
many
different
types
software
system
ranging
simple
embedded
systems
complex
worldwide
information
systems
no
universal
notations
methods
techniques
software
engineering
different
types
software
require
different
approaches
Developing
organizational
information
system
completely
different
developing
controller
scientific
instrument
systems
much
common
graphics
intensive
computer
game
applications
need
software
engineering
need
software
engineering
methods
techniques
still
many
reports
software
projects
going
wrong
software
failures
Software
engineering
criticized
inadequate
modern
software
development
However
opinion
many
called
software
failures
consequence
two
factors
Increasing
system
complexity
new
software
engineering
techniques
help
us
build
larger
complex
systems
demands
change
Systems
built
delivered
quickly
larger
even
complex
systems
required
systems
new
capabilities
previously
thought
impossible
New
software
engineering
techniques
developed
meet
new
challenges
delivering
complex
software
Failure
use
software
engineering
methods
fairly
easy
write
computer
programs
without
using
software
engineering
methods
techniques
Many
companies
drifted
software
development
products
services
evolved
use
software
engineering
methods
everyday
work
Consequently
software
often
expensive
less
reliable
need
better
software
engineering
education
training
address
problem
Software
engineers
rightly
proud
achievements
course
still
problems
developing
complex
software
without
software
engineering
explored
space
Internet
modern
telecommunications
forms
travel
dangerous
expensive
Challenges
humanity
st
century
climate
change
fewer
natural
@@@@@@@@@@
Professional
software
development
History
software
engineering
notion
software
engineering
first
proposed
conference
held
discuss
called
software
crisis
Naur
Randell
clear
individual
approaches
program
development
scale
large
complex
software
systems
unreliable
cost
expected
delivered
late
Throughout
s
s
variety
new
software
engineering
techniques
methods
developed
structured
programming
information
hiding
object
oriented
development
Tools
standard
notations
developed
basis
today
s
software
engineering
http
software
engineering
book
com
web
history
resources
changing
demographics
expanding
world
population
rely
software
engineering
develop
systems
need
cope
issues
Professional
software
development
Lots
people
write
programs
People
business
write
spreadsheet
programs
simplify
jobs
scientists
engineers
write
programs
process
experimental
data
hobbyists
write
programs
interest
enjoyment
However
software
development
professional
activity
software
developed
business
purposes
inclusion
devices
software
products
information
systems
computer
aided
design
systems
key
distinctions
professional
software
intended
use
someone
apart
developer
teams
rather
individuals
usually
develop
software
maintained
changed
throughout
life
Software
engineering
intended
support
professional
software
development
rather
individual
programming
includes
techniques
support
program
specification
design
evolution
none
normally
relevant
personal
software
development
help
get
broad
view
software
engineering
summarized
frequently
asked
questions
subject
Figure
Many
people
think
software
simply
another
word
computer
programs
However
talking
software
engineering
software
programs
associated
documentation
libraries
support
websites
configuration
data
needed
make
programs
useful
professionally
developed
software
system
often
single
program
system
consist
several
separate
programs
configuration
files
used
set
programs
include
system
documentation
describes
structure
system
user
documentation
explains
use
system
websites
users
download
recent
product
information
one
important
differences
professional
amateur
software
development
writing
program
no
one
use
@@@@@@@@@@
Chapter
Introduction
Question
Answer
software
Computer
programs
associated
documentation
Software
products
developed
particular
customer
developed
general
market
creation
app
industry
mobile
devices
changed
economics
software
don
t
worry
writing
program
guides
documenting
pro
gram
design
However
writing
software
people
Figure
Frequently
asked
questions
software
engineering
attributes
good
software
Good
software
deliver
required
functionality
performance
user
maintainable
dependable
usable
software
engineering
Software
engineering
engineering
discipline
concerned
aspects
software
production
initial
conception
operation
maintenance
fundamental
software
engineering
activities
Software
specification
software
development
software
validation
software
evolution
difference
software
engineering
Computer
science
focuses
theory
fundamentals
software
computer
science
engineering
concerned
practicalities
developing
delivering
useful
software
difference
software
engineering
system
System
engineering
concerned
aspects
computer
engineering
based
systems
development
including
hardware
software
process
engineering
Software
engineering
part
general
process
key
challenges
facing
software
engineering
Coping
increasing
diversity
demands
reduced
delivery
times
developing
trustworthy
software
costs
software
engineering
Roughly
software
costs
development
costs
testing
costs
custom
software
evolution
costs
often
exceed
development
costs
best
software
engineering
techniques
software
projects
professionally
managed
methods
developed
different
techniques
appropriate
different
types
system
example
games
developed
using
series
prototypes
safety
critical
control
systems
require
complete
analyzable
specification
developed
no
methods
techniques
good
everything
differences
Internet
made
software
engineering
Internet
led
development
massive
highly
distributed
service
based
systems
supported
use
engineers
change
usually
provide
additional
information
well
code
program
Software
engineers
concerned
developing
software
products
software
sold
customer
two
kinds
software
product
Generic
products
stand
alone
systems
produced
development
organization
sold
open
market
customer
able
buy
Examples
type
product
include
apps
mobile
devices
software
PCs
databases
word
processors
drawing
packages
project
management
tools
kind
software
includes
vertical
@@@@@@@@@@
Professional
software
development
applications
designed
specific
market
library
information
systems
accounting
systems
systems
maintaining
dental
records
Customized
bespoke
software
systems
commissioned
developed
particular
customer
software
contractor
designs
implements
software
especially
customer
Examples
type
software
include
control
systems
electronic
devices
systems
written
support
particular
business
process
air
traffic
control
systems
critical
distinction
types
software
generic
products
organization
develops
software
controls
software
specification
means
run
development
problems
rethink
developed
custom
products
specification
developed
controlled
organization
buying
software
software
developers
work
specification
However
distinction
system
product
types
becoming
increasingly
blurred
systems
now
built
generic
product
base
adapted
suit
requirements
customer
Enterprise
Resource
Planning
ERP
systems
systems
SAP
Oracle
best
examples
approach
large
complex
system
adapted
company
incorporating
information
business
rules
processes
reports
required
talk
quality
professional
software
consider
software
used
changed
people
apart
developers
Quality
therefore
concerned
software
Rather
include
software
s
behavior
executing
structure
organization
system
programs
associated
documentation
reflected
software
s
quality
non
functional
attributes
Examples
attributes
software
s
response
time
user
query
understandability
program
code
specific
set
attributes
expect
software
system
obviously
depends
application
Therefore
aircraft
control
system
safe
interactive
game
responsive
telephone
switching
system
reliable
generalized
set
attributes
shown
Figure
think
essential
characteristics
professional
software
system
Software
engineering
Software
engineering
engineering
discipline
concerned
aspects
software
production
early
stages
system
specification
maintaining
system
gone
use
definition
two
key
phrases
Engineering
discipline
Engineers
make
things
work
apply
theories
methods
tools
appropriate
However
use
selectively
@@@@@@@@@@
Chapter
Introduction
Product
characteristic
Description
Acceptability
Figure
Essential
attributes
good
software
Dependability
security
Efficiency
Maintainability
Software
acceptable
type
users
designed
means
understandable
usable
compatible
systems
use
Software
dependability
includes
range
characteristics
including
reliability
security
safety
Dependable
software
cause
physical
economic
damage
event
system
failure
Software
secure
malicious
users
cannot
access
damage
system
Software
make
wasteful
use
system
resources
memory
processor
cycles
Efficiency
therefore
includes
responsiveness
processing
time
resource
utilization
etc
Software
written
way
evolve
meet
changing
needs
customers
critical
attribute
software
change
inevitable
requirement
changing
business
environment
try
discover
solutions
problems
even
no
applicable
theories
methods
Engineers
recognize
work
organizational
financial
constraints
look
solutions
constraints
aspects
software
production
Software
engineering
concerned
technical
processes
software
development
includes
activities
software
project
management
development
tools
methods
theories
support
software
development
Engineering
getting
results
required
quality
schedule
budget
often
involves
making
compromises
engineers
cannot
perfectionists
People
writing
programs
however
spend
much
time
wish
program
development
general
software
engineers
adopt
systematic
organized
approach
work
often
effective
way
produce
high
quality
software
However
engineering
selecting
appropriate
method
set
circumstances
creative
less
formal
approach
development
right
one
kinds
software
flexible
software
process
accommodates
rapid
change
particularly
appropriate
development
interactive
web
based
systems
mobile
apps
require
blend
software
graphical
design
skills
Software
engineering
important
two
reasons
individuals
society
rely
advanced
software
systems
need
able
produce
reliable
trustworthy
systems
economically
quickly
usually
cheaper
long
run
use
software
engineering
methods
techniques
professional
software
systems
rather
write
programs
@@@@@@@@@@
Professional
software
development
personal
programming
project
Failure
use
software
engineering
method
leads
higher
costs
testing
quality
assurance
long
term
maintenance
systematic
approach
used
software
engineering
sometimes
called
software
process
software
process
sequence
activities
leads
production
software
product
Four
fundamental
activities
common
software
processes
Software
specification
customers
engineers
define
software
produced
constraints
operation
Software
development
software
designed
programmed
Software
validation
software
checked
ensure
customer
requires
Software
evolution
software
modified
reflect
changing
customer
market
requirements
Different
types
systems
need
different
development
processes
explain
Chapter
example
real
time
software
aircraft
completely
specified
development
begins
e
commerce
systems
specification
program
usually
developed
together
Consequently
generic
activities
organized
different
ways
described
different
levels
detail
depending
type
software
developed
Software
engineering
related
computer
science
systems
engineering
Computer
science
concerned
theories
methods
underlie
computers
software
systems
software
engineering
concerned
practical
problems
producing
software
knowledge
computer
science
essential
software
engineers
way
knowledge
physics
essential
electrical
engineers
Computer
science
theory
however
often
applicable
relatively
small
programs
Elegant
theories
computer
science
rarely
relevant
large
complex
problems
require
software
solution
System
engineering
concerned
aspects
development
evolution
complex
systems
software
plays
major
role
System
engineering
therefore
concerned
hardware
development
policy
process
design
system
deployment
well
software
engineering
System
engineers
involved
specifying
system
defining
overall
architecture
integrating
different
parts
create
finished
system
discuss
next
section
many
different
types
software
no
universal
software
engineering
methods
techniques
used
However
four
related
issues
affect
many
different
types
software
@@@@@@@@@@
Chapter
Introduction
Heterogeneity
Increasingly
systems
required
operate
distributed
systems
across
networks
include
different
types
computer
mobile
devices
well
running
general
purpose
computers
software
execute
mobile
phones
tablets
often
integrate
new
software
older
legacy
systems
written
different
programming
languages
challenge
develop
techniques
building
dependable
software
flexible
enough
cope
heterogeneity
Business
social
change
Businesses
society
changing
incredibly
quickly
emerging
economies
develop
new
technologies
available
need
able
change
existing
software
rapidly
develop
new
software
Many
traditional
software
engineering
techniques
time
consuming
delivery
new
systems
often
takes
longer
planned
need
evolve
time
required
software
deliver
value
customers
reduced
Security
trust
software
intertwined
aspects
lives
essential
trust
software
especially
true
remote
software
systems
accessed
web
page
web
service
interface
make
sure
malicious
users
cannot
successfully
attack
software
information
security
maintained
Scale
Software
developed
across
wide
range
scales
small
embedded
systems
portable
wearable
devices
Internet
scale
cloud
based
systems
serve
global
community
address
challenges
need
new
tools
techniques
well
innovative
ways
combining
using
existing
software
engineering
methods
Software
engineering
diversity
Software
engineering
systematic
approach
production
software
takes
account
practical
cost
schedule
dependability
issues
well
needs
software
customers
producers
specific
methods
tools
techniques
used
depend
organization
developing
software
type
software
people
involved
development
process
no
universal
software
engineering
methods
suitable
systems
companies
Rather
diverse
set
software
engineering
methods
tools
evolved
past
years
However
SEMAT
initiative
Jacobson
et
al
proposes
fundamental
meta
process
instantiated
create
different
kinds
process
early
stage
development
basis
improving
current
software
engineering
methods
Perhaps
significant
factor
determining
software
engineering
methods
techniques
important
type
application
developed
many
different
types
application
including
@@@@@@@@@@
Professional
software
development
Stand
alone
applications
application
systems
run
personal
computer
apps
run
mobile
device
include
necessary
functionality
need
connected
network
Examples
applications
office
applications
PC
CAD
programs
photo
manipulation
software
travel
apps
productivity
apps
Interactive
transaction
based
applications
applications
execute
remote
computer
accessed
users
computers
phones
tablets
Obviously
include
web
applications
e
commerce
applications
interact
remote
system
buy
goods
services
class
application
includes
business
systems
business
provides
access
systems
web
browser
special
purpose
client
program
cloud
based
services
mail
photo
sharing
Interactive
applications
often
incorporate
large
data
store
accessed
updated
transaction
Embedded
control
systems
software
control
systems
control
manage
hardware
devices
Numerically
probably
embedded
systems
type
system
Examples
embedded
systems
include
software
mobile
cell
phone
software
controls
antilock
braking
car
software
microwave
oven
control
cooking
process
Batch
processing
systems
business
systems
designed
process
data
large
batches
process
large
numbers
individual
inputs
create
corresponding
outputs
Examples
batch
systems
periodic
billing
systems
phone
billing
systems
salary
payment
systems
Entertainment
systems
systems
personal
use
intended
entertain
user
systems
games
one
kind
another
run
special
purpose
console
hardware
quality
user
interaction
offered
important
distinguishing
characteristic
entertainment
systems
Systems
modeling
simulation
systems
developed
scientists
engineers
model
physical
processes
situations
include
many
separate
interacting
objects
often
computationally
intensive
require
high
performance
parallel
systems
execution
Data
collection
analysis
systems
Data
collection
systems
systems
collect
data
environment
send
data
systems
processing
software
interact
sensors
often
installed
hostile
environment
inside
engine
remote
location
Big
data
analysis
involve
cloud
based
systems
carrying
statistical
analysis
looking
relationships
collected
data
Systems
systems
systems
used
enterprises
large
organizations
composed
number
software
systems
generic
software
products
ERP
system
systems
assembly
specially
written
environment
@@@@@@@@@@
Chapter
Introduction
course
boundaries
system
types
blurred
develop
game
phone
take
account
constraints
power
hardware
interaction
developers
phone
software
Batch
processing
systems
often
used
conjunction
web
based
transaction
systems
example
company
travel
expense
claims
submitted
web
application
processed
batch
application
monthly
payment
type
system
requires
specialized
software
engineering
techniques
software
different
characteristics
example
embedded
control
system
automobile
safety
critical
burned
ROM
read
memory
installed
vehicle
therefore
expensive
change
system
needs
extensive
verification
validation
chances
recall
cars
sale
fix
software
problems
minimized
User
interaction
minimal
perhaps
nonexistent
no
need
use
development
process
relies
user
interface
prototyping
interactive
web
based
system
app
iterative
development
delivery
best
approach
system
composed
reusable
components
However
approach
impractical
system
systems
detailed
specifications
system
interactions
specified
advance
system
separately
developed
Nevertheless
software
engineering
fundamentals
apply
types
software
systems
developed
using
managed
understood
development
process
organization
developing
software
plan
development
process
clear
ideas
produced
completed
course
specific
process
use
depends
type
software
developing
Dependability
performance
important
types
system
Software
behave
expected
without
failures
available
use
required
safe
operation
far
possible
secure
external
attack
system
perform
efficiently
waste
resources
Understanding
managing
software
specification
requirements
software
important
know
different
customers
users
system
expect
manage
expectations
useful
system
delivered
budget
schedule
make
effective
use
existing
resources
means
appropriate
reuse
software
already
developed
rather
write
new
software
fundamental
notions
process
dependability
requirements
management
reuse
important
themes
book
Different
methods
reflect
different
ways
underlie
professional
software
development
@@@@@@@@@@
Professional
software
development
fundamentals
independent
program
language
used
software
development
don
t
cover
specific
programming
techniques
book
vary
dramatically
one
type
system
another
example
dynamic
language
Ruby
right
type
language
interactive
system
development
inappropriate
embedded
systems
engineering
Internet
software
engineering
development
Internet
World
Wide
Web
profound
effect
lives
Initially
web
primarily
universally
accessible
information
store
little
effect
software
systems
systems
ran
local
computers
accessible
organization
Around
web
started
evolve
functionality
added
browsers
meant
web
based
systems
developed
instead
special
purpose
user
interface
systems
accessed
using
web
browser
led
development
vast
range
new
system
products
delivered
innovative
services
accessed
web
often
funded
adverts
displayed
user
s
screen
involve
direct
payment
users
well
system
products
development
web
browsers
run
small
programs
local
processing
led
evolution
business
organizational
software
Instead
writing
software
deploying
users
PCs
software
deployed
web
server
made
much
cheaper
change
upgrade
software
no
need
install
software
every
PC
reduced
costs
user
interface
development
particularly
expensive
possible
businesses
moved
web
based
interaction
company
software
systems
notion
software
service
Chapter
proposed
early
st
century
now
standard
approach
delivery
web
based
system
products
Google
Apps
Microsoft
Office
Adobe
Creative
Suite
software
runs
remote
clouds
instead
local
servers
accessed
Internet
computing
cloud
huge
number
linked
computer
systems
shared
many
users
Users
buy
software
pay
according
much
software
used
given
free
access
return
watching
adverts
displayed
screen
use
services
web
based
mail
storage
video
using
cloud
based
system
advent
web
led
dramatic
change
way
business
software
organized
web
business
applications
mostly
monolithic
single
programs
running
single
computers
computer
clusters
Communications
local
organization
Now
software
highly
distributed
sometimes
across
world
Business
applications
programmed
scratch
involve
extensive
reuse
components
programs
change
software
organization
major
effect
software
engineering
web
based
systems
example
@@@@@@@@@@
Chapter
Introduction
Software
reuse
dominant
approach
constructing
web
based
systems
building
systems
think
assemble
preexisting
software
components
systems
often
bundled
together
framework
now
generally
recognized
impractical
specify
requirements
systems
advance
Web
based
systems
developed
delivered
incrementally
Software
implemented
using
service
oriented
software
engineering
software
components
stand
alone
web
services
discuss
approach
software
engineering
Chapter
Interface
development
technology
AJAX
Holdener
HTML
Freeman
emerged
support
creation
rich
interfaces
web
browser
fundamental
ideas
software
engineering
discussed
previous
section
apply
web
based
software
types
software
Web
based
systems
getting
larger
larger
software
engineering
techniques
deal
scale
complexity
relevant
systems
Software
engineering
ethics
Like
engineering
disciplines
software
engineering
carried
social
legal
framework
limits
freedom
people
working
area
software
engineer
accept
job
involves
wider
responsibilities
simply
application
technical
skills
behave
ethical
morally
responsible
way
respected
professional
engineer
goes
without
saying
uphold
normal
standards
honesty
integrity
use
skills
abilities
behave
dishonest
way
way
bring
disrepute
software
engineering
profession
However
areas
standards
acceptable
behavior
bound
laws
tenuous
notion
professional
responsibility
Confidentiality
normally
respect
confidentiality
employers
clients
regardless
formal
confidentiality
agreement
signed
Competence
misrepresent
level
competence
knowingly
accept
work
outside
competence
Intellectual
property
rights
aware
local
laws
governing
use
intellectual
property
patents
copyright
careful
ensure
intellectual
property
employers
clients
protected
@@@@@@@@@@
Software
engineering
ethics
Software
Engineering
Code
Ethics
Professional
Practice
ACM
IEEE
CS
Joint
Task
Force
Software
Engineering
Ethics
Professional
Practices
PREAMBLE
short
version
code
summarizes
aspirations
high
level
abstraction
clauses
included
full
version
give
examples
details
aspirations
change
way
act
software
engineering
professionals
Without
aspirations
details
legalistic
tedious
without
details
aspirations
high
sounding
empty
together
aspirations
details
form
cohesive
code
Software
engineers
shall
commit
making
analysis
specification
design
development
testing
maintenance
software
beneficial
respected
profession
accordance
commitment
health
safety
welfare
public
software
engineers
shall
adhere
following
Eight
Principles
PUBLIC
Software
engineers
shall
act
consistently
public
interest
CLIENT
EMPLOYER
Software
engineers
shall
act
manner
best
interests
client
employer
consistent
public
interest
PRODUCT
Software
engineers
shall
ensure
products
related
modifications
meet
highest
professional
standards
possible
JUDGMENT
Software
engineers
shall
maintain
integrity
independence
professional
judgment
MANAGEMENT
Software
engineering
managers
leaders
shall
subscribe
promote
ethical
approach
management
software
development
maintenance
PROFESSION
Software
engineers
shall
advance
integrity
reputation
profession
consistent
public
interest
COLLEAGUES
Software
engineers
shall
fair
supportive
colleagues
SELF
Software
engineers
shall
participate
lifelong
learning
regarding
practice
profession
shall
promote
ethical
approach
practice
profession
Figure
ACM
IEEE
Code
Ethics
ACM
IEEE
CS
Joint
Task
Force
Software
Engineering
Ethics
Professional
Practices
short
version
http
www
acm
org
se
code
ACM
Inc
IEEE
Inc
Computer
misuse
use
technical
skills
misuse
people
s
computers
Computer
misuse
ranges
relatively
trivial
game
playing
employer
s
machine
extremely
serious
dissemination
viruses
malware
Professional
societies
institutions
important
role
play
setting
ethical
standards
Organizations
ACM
IEEE
Institute
Electrical
Electronic
Engineers
British
Computer
Society
publish
code
professional
conduct
code
ethics
Members
organizations
undertake
follow
code
sign
membership
codes
conduct
generally
concerned
fundamental
ethical
behavior
Professional
associations
notably
ACM
IEEE
cooperated
produce
joint
code
ethics
professional
practice
code
exists
short
form
shown
Figure
longer
form
Gotterbarn
Miller
Rogerson
adds
detail
substance
shorter
version
rationale
behind
code
summarized
first
two
paragraphs
longer
form
@@@@@@@@@@
Chapter
Introduction
Computers
central
growing
role
commerce
industry
government
medicine
education
entertainment
society
large
Software
engineers
contribute
direct
participation
teaching
analysis
specification
design
development
certification
maintenance
testing
software
systems
roles
developing
software
systems
software
engineers
significant
opportunities
good
cause
harm
enable
others
good
cause
harm
influence
others
good
cause
harm
ensure
much
possible
efforts
used
good
software
engineers
commit
making
software
engineering
beneficial
respected
profession
accordance
commitment
software
engineers
shall
adhere
following
Code
Ethics
Professional
Practice
Code
contains
eight
Principles
related
behaviour
decisions
made
professional
software
engineers
including
practitioners
educators
managers
supervisors
policy
makers
well
trainees
students
profession
Principles
identify
ethically
responsible
relationships
individuals
groups
organizations
participate
primary
obligations
relationships
Clauses
Principle
illustrations
obligations
included
relationships
obligations
founded
software
engineer
s
humanity
special
care
owed
people
affected
work
software
engineers
unique
elements
practice
software
engineering
Code
prescribes
obligations
anyone
claiming
aspiring
software
engineer
situation
different
people
different
views
objectives
likely
faced
ethical
dilemmas
example
disagree
principle
policies
senior
management
company
react
Clearly
depends
people
involved
nature
disagreement
best
argue
case
position
organization
resign
principle
feel
problems
software
project
reveal
problems
management
discuss
suspicion
overreacting
situation
leave
long
impossible
resolve
difficulties
face
ethical
dilemmas
professional
lives
fortunately
cases
relatively
minor
resolved
without
much
difficulty
cannot
resolved
engineer
faced
perhaps
another
problem
principled
action
resign
job
well
affect
others
partner
children
difficult
situation
professional
engineers
arises
employer
acts
unethical
way
Say
company
responsible
developing
safety
critical
system
time
pressure
falsifies
safety
validation
records
engineer
s
responsibility
maintain
confidentiality
alert
customer
publicize
way
delivered
system
unsafe
ACM
IEEE
CS
Joint
Task
Force
Software
Engineering
Ethics
Professional
Practices
short
version
Preamble
http
www
acm
org
se
code
Copyright
Association
Computing
Machinery
Inc
Institute
Electrical
Electronics
Engineers
Inc
@@@@@@@@@@
Case
studies
problem
no
absolutes
comes
safety
system
validated
according
predefined
criteria
criteria
strict
system
operate
safely
throughout
lifetime
case
even
properly
validated
system
fail
cause
accident
Early
disclosure
problems
result
damage
employer
employees
failure
disclose
problems
result
damage
others
make
mind
matters
appropriate
ethical
position
depends
views
people
involved
potential
damage
extent
damage
people
affected
damage
influence
decision
situation
dangerous
justified
publicize
using
national
press
social
media
However
try
resolve
situation
respecting
rights
employer
Another
ethical
issue
participation
development
military
nuclear
systems
people
feel
strongly
issues
wish
participate
systems
development
associated
defense
systems
Others
work
military
systems
weapons
systems
others
feel
national
security
overriding
principle
no
ethical
objections
working
weapons
systems
situation
important
employers
employees
make
views
known
advance
organization
involved
military
nuclear
work
able
specify
employees
willing
accept
work
assignment
Equally
employee
taken
makes
clear
wish
work
systems
employers
exert
pressure
later
date
general
area
ethics
professional
responsibility
increasingly
important
software
intensive
systems
pervade
every
aspect
work
everyday
life
considered
philosophical
standpoint
basic
principles
ethics
considered
software
engineering
ethics
discussed
reference
basic
principles
approach
taken
Laudon
Laudon
Johnson
Johnson
recent
texts
Tavani
Tavani
introduce
notion
cyberethics
cover
philosophical
background
practical
legal
issues
include
ethical
issues
technology
users
well
developers
find
philosophical
approach
abstract
difficult
relate
everyday
experience
prefer
concrete
approach
embodied
professional
codes
conduct
Bott
Duquenoy
think
ethics
best
discussed
software
engineering
context
subject
right
Therefore
discuss
software
engineering
ethics
abstract
way
include
examples
exercises
starting
point
group
discussion
Case
studies
illustrate
software
engineering
concepts
use
examples
four
different
types
system
deliberately
used
single
case
study
one
key
messages
book
software
engineering
practice
depends
type
systems
@@@@@@@@@@
Chapter
Introduction
produced
therefore
choose
appropriate
example
discussing
concepts
safety
dependability
system
modeling
reuse
etc
system
types
use
case
studies
embedded
system
system
software
controls
hardware
device
embedded
device
Issues
embedded
systems
typically
include
physical
size
responsiveness
power
management
etc
example
embedded
system
use
software
system
control
insulin
pump
people
diabetes
information
system
primary
purpose
type
system
manage
provide
access
database
information
Issues
information
systems
include
security
usability
privacy
maintaining
data
integrity
example
information
system
used
medical
records
system
sensor
based
data
collection
system
system
primary
purposes
collect
data
set
sensors
process
data
way
key
requirements
systems
reliability
even
hostile
environmental
conditions
maintainability
example
data
collection
system
use
wilderness
weather
station
support
environment
integrated
collection
software
tools
used
support
kind
activity
Programming
environments
Eclipse
Vogel
familiar
type
environment
readers
book
describe
example
digital
learning
environment
used
support
students
learning
schools
introduce
systems
chapter
information
available
website
software
engineering
book
com
insulin
pump
control
system
insulin
pump
medical
system
simulates
operation
pancreas
internal
organ
software
controlling
system
embedded
system
collects
information
sensor
controls
pump
delivers
controlled
dose
insulin
user
People
suffer
diabetes
use
system
Diabetes
relatively
common
condition
human
pancreas
unable
produce
sufficient
quantities
hormone
called
insulin
Insulin
metabolizes
glucose
sugar
blood
conventional
treatment
diabetes
involves
regular
injections
genetically
engineered
insulin
Diabetics
measure
blood
sugar
levels
periodically
using
external
meter
estimate
dose
insulin
inject
problem
level
insulin
required
depend
blood
glucose
level
time
last
insulin
injection
Irregular
checking
lead
low
levels
blood
glucose
much
insulin
high
levels
blood
sugar
little
insulin
Low
blood
glucose
short
term
serious
condition
result
temporary
brain
malfunctioning
@@@@@@@@@@
Case
studies
Needle
assembly
Sensor
Display
Display
Alarm
Pump
Clock
Controller
Power
supply
Insulin
reservoir
Figure
Insulin
pump
hardware
architecture
Analyze
sensor
reading
Blood
sensor
Insulin
pump
Blood
sugar
Compute
insulin
Insulin
dose
Insulin
log
Log
doseCompute
pump
commands
Pump
data
Control
insulin
pump
Figure
Activity
model
insulin
pump
ultimately
unconsciousness
death
long
term
however
continual
high
levels
blood
glucose
lead
eye
damage
kidney
damage
heart
problems
Advances
developing
miniaturized
sensors
meant
now
possible
develop
automated
insulin
delivery
systems
systems
monitor
blood
sugar
levels
deliver
appropriate
dose
insulin
required
Insulin
delivery
systems
like
one
now
available
used
patients
find
difficult
control
insulin
levels
future
possible
diabetics
systems
permanently
attached
bodies
software
controlled
insulin
delivery
system
uses
microsensor
embedded
patient
measure
blood
parameter
proportional
sugar
level
sent
pump
controller
controller
computes
sugar
level
amount
insulin
needed
sends
signals
miniaturized
pump
deliver
insulin
via
permanently
attached
needle
Figure
shows
hardware
components
organization
insulin
pump
understand
examples
book
need
know
blood
sensor
measures
electrical
conductivity
blood
different
conditions
values
related
blood
sugar
level
insulin
pump
delivers
one
unit
insulin
response
single
pulse
controller
Therefore
deliver
units
insulin
controller
sends
pulses
pump
Figure
Unified
Modeling
@@@@@@@@@@
Chapter
Introduction
Mentcare
client
Mentcare
client
Mentcare
client
Network
Mentcare
server
Patient
database
Figure
organization
Mentcare
system
Language
UML
activity
model
illustrates
software
transforms
input
blood
sugar
level
sequence
commands
drive
insulin
pump
Clearly
safety
critical
system
pump
fails
operate
operate
correctly
user
s
health
damaged
fall
coma
blood
sugar
levels
high
low
system
therefore
meet
two
essential
high
level
requirements
system
shall
available
deliver
insulin
required
system
shall
perform
reliably
deliver
correct
amount
insulin
counteract
current
level
blood
sugar
system
therefore
designed
implemented
ensure
meets
requirements
detailed
requirements
discussions
ensure
system
safe
discussed
later
chapters
patient
information
system
mental
health
care
patient
information
system
support
mental
health
care
Mentcare
system
medical
information
system
maintains
information
patients
suffering
mental
health
problems
treatments
received
mental
health
patients
require
dedicated
hospital
treatment
need
attend
specialist
clinics
regularly
meet
doctor
detailed
knowledge
problems
make
easier
patients
attend
clinics
run
hospitals
held
local
medical
practices
community
centers
Mentcare
system
Figure
patient
information
system
intended
use
clinics
makes
use
centralized
database
patient
information
@@@@@@@@@@
Case
studies
designed
run
laptop
accessed
used
sites
secure
network
connectivity
local
systems
secure
network
access
use
patient
information
database
download
use
local
copies
patient
records
disconnected
system
complete
medical
records
system
maintain
information
medical
conditions
However
interact
exchange
data
clinical
information
systems
system
two
purposes
generate
management
information
allows
health
service
managers
assess
performance
local
government
targets
provide
medical
staff
timely
information
support
treatment
patients
Patients
suffer
mental
health
problems
sometimes
irrational
disorganized
miss
appointments
deliberately
accidentally
lose
prescriptions
medication
forget
instructions
make
unreasonable
demands
medical
staff
drop
clinics
unexpectedly
minority
cases
danger
people
regularly
change
address
homeless
long
term
short
term
basis
patients
dangerous
need
sectioned
confined
secure
hospital
treatment
observation
Users
system
include
clinical
staff
doctors
nurses
health
visitors
nurses
visit
people
home
check
treatment
Nonmedical
users
include
receptionists
make
appointments
medical
records
staff
maintain
records
system
administrative
staff
generate
reports
system
used
record
information
patients
name
address
age
next
kin
etc
consultations
date
doctor
seen
subjective
impressions
patient
etc
conditions
treatments
Reports
generated
regular
intervals
medical
staff
health
authority
managers
Typically
reports
medical
staff
focus
information
individual
patients
management
reports
anonymized
concerned
conditions
costs
treatment
etc
key
features
system
Individual
care
management
Clinicians
create
records
patients
edit
information
system
view
patient
history
system
supports
data
summaries
doctors
previously
met
patient
quickly
learn
key
problems
treatments
prescribed
Patient
monitoring
system
regularly
monitors
records
patients
involved
treatment
issues
warnings
possible
problems
detected
Therefore
patient
seen
doctor
time
warning
issued
One
important
elements
monitoring
system
keep
track
patients
sectioned
ensure
legally
required
checks
carried
right
time
@@@@@@@@@@
Chapter
Introduction
Administrative
reporting
system
generates
monthly
management
reports
showing
number
patients
treated
clinic
number
patients
entered
left
care
system
number
patients
sectioned
drugs
prescribed
costs
etc
Two
different
laws
affect
system
laws
data
protection
govern
confidentiality
personal
information
mental
health
laws
govern
compulsory
detention
patients
deemed
danger
others
Mental
health
unique
respect
medical
speciality
recommend
detention
patients
subject
strict
legislative
safeguards
One
aim
Mentcare
system
ensure
staff
act
accordance
law
decisions
recorded
judicial
review
necessary
medical
systems
privacy
critical
system
requirement
essential
patient
information
confidential
never
disclosed
anyone
apart
authorized
medical
staff
patient
Mentcare
system
safety
critical
system
mental
illnesses
cause
patients
suicidal
danger
people
possible
system
warn
medical
staff
potentially
suicidal
dangerous
patients
overall
design
system
take
account
privacy
safety
requirements
system
available
needed
otherwise
safety
compromised
impossible
prescribe
correct
medication
patients
potential
conflict
Privacy
easiest
maintain
single
copy
system
data
However
ensure
availability
event
server
failure
disconnected
network
multiple
copies
data
maintained
discuss
trade
offs
requirements
later
chapters
wilderness
weather
station
help
monitor
climate
change
improve
accuracy
weather
forecasts
remote
areas
government
country
large
areas
wilderness
decides
deploy
several
hundred
weather
stations
remote
areas
weather
stations
collect
data
set
instruments
measure
temperature
pressure
sunshine
rainfall
wind
speed
wind
direction
Wilderness
weather
stations
part
larger
system
Figure
weather
information
system
collects
data
weather
stations
makes
available
systems
processing
systems
Figure
weather
station
system
system
responsible
collecting
weather
data
carrying
initial
data
processing
transmitting
data
management
system
data
management
archiving
system
system
collects
data
wilderness
weather
stations
carries
data
processing
analysis
archives
data
form
retrieved
systems
weather
forecasting
systems
@@@@@@@@@@
Case
studies
system
Data
management
archiving
system
Station
maintenance
system
Weather
station
Figure
weather
station
s
environment
station
maintenance
system
system
communicate
satellite
wilderness
weather
stations
monitor
health
systems
provide
reports
problems
update
embedded
software
systems
event
system
problems
system
used
remotely
control
weather
station
Figure
used
UML
package
symbol
indicate
system
collection
components
separate
systems
identified
using
UML
stereotype
system
associations
packages
indicate
exchange
information
stage
no
need
define
detail
weather
stations
include
instruments
measure
weather
parameters
wind
speed
direction
ground
air
temperatures
barometric
pressure
rainfall
hour
period
instruments
controlled
software
system
takes
parameter
readings
periodically
manages
data
collected
instruments
weather
station
system
operates
collecting
weather
observations
frequent
intervals
example
temperatures
measured
every
minute
However
bandwidth
satellite
relatively
narrow
weather
station
carries
local
processing
aggregation
data
transmits
aggregated
data
requested
data
collection
system
impossible
make
connection
weather
station
maintains
data
locally
communication
resumed
weather
station
battery
powered
entirely
self
contained
no
external
power
network
cables
communications
relatively
slow
satellite
link
weather
station
include
mechanism
solar
wind
power
charge
batteries
deployed
wilderness
areas
exposed
severe
environmental
conditions
damaged
animals
station
software
therefore
concerned
data
collection
Monitor
instruments
power
communication
hardware
report
faults
management
system
Manage
system
power
ensuring
batteries
charged
environmental
conditions
permit
generators
shut
potentially
damaging
weather
conditions
high
wind
@@@@@@@@@@
Chapter
Introduction
Allow
dynamic
reconfiguration
parts
software
replaced
new
versions
backup
instruments
switched
system
event
system
failure
weather
stations
self
contained
unattended
means
software
installed
complex
even
though
data
collection
functionality
fairly
simple
digital
learning
environment
schools
Many
teachers
argue
using
interactive
software
systems
support
education
lead
improved
learner
motivation
deeper
level
knowledge
understanding
students
However
no
general
agreement
best
strategy
computer
supported
learning
teachers
practice
use
range
different
interactive
web
based
tools
support
learning
tools
used
depend
ages
learners
cultural
background
experience
computers
equipment
available
preferences
teachers
involved
digital
learning
environment
framework
set
general
purpose
specially
designed
tools
learning
embedded
plus
set
applications
geared
needs
learners
using
system
framework
provides
general
services
authentication
service
synchronous
asynchronous
communication
services
storage
service
tools
included
version
environment
chosen
teachers
learners
suit
specific
needs
general
applications
spreadsheets
learning
management
applications
Virtual
Learning
Environment
VLE
manage
homework
submission
assessment
games
simulations
include
specific
content
content
American
Civil
War
applications
view
annotate
content
Figure
high
level
architectural
model
digital
learning
environment
iLearn
designed
use
schools
students
years
age
approach
adopted
distributed
system
components
environment
services
accessed
anywhere
Internet
no
requirement
learning
tools
gathered
together
one
place
system
service
oriented
system
system
components
considered
replaceable
service
three
types
service
system
Utility
services
provide
basic
application
independent
functionality
used
services
system
Utility
services
usually
developed
adapted
specifically
system
Application
services
provide
specific
applications
email
conferencing
photo
sharing
etc
access
specific
educational
content
scientific
films
historical
resources
Application
services
external
services
specifically
purchased
system
available
freely
Internet
@@@@@@@@@@
Case
studies
Browser
based
user
interface
iLearn
app
Configuration
services
Group
management
Application
management
Identity
management
Application
services
Email
Messaging
Video
conferencing
Newspaper
archive
Word
processing
Simulation
Video
storage
Resource
finder
Spreadsheet
Virtual
learning
environment
History
archive
Utility
services
Figure
architecture
digital
learning
environment
iLearn
Authentication
User
storage
Logging
monitoring
Application
storage
Interfacing
Search
Configuration
services
used
adapt
environment
specific
set
application
services
define
services
shared
students
teachers
parents
environment
designed
services
replaced
new
services
available
provide
different
versions
system
suited
age
users
means
system
support
two
levels
service
integration
Integrated
services
services
offer
API
application
programming
interface
accessed
services
API
Direct
service
service
communication
therefore
possible
authentication
service
example
integrated
service
Rather
use
authentication
mechanisms
authentication
service
called
services
authenticate
users
users
already
authenticated
authentication
service
pass
authentication
information
directly
another
service
via
API
no
need
users
reauthenticate
Independent
services
services
simply
accessed
browser
interface
operate
independently
services
Information
shared
services
explicit
user
actions
copy
paste
reauthentication
required
independent
service
independent
service
becomes
widely
used
development
team
integrate
service
becomes
integrated
supported
service
@@@@@@@@@@
Chapter
Introduction
Key
Points
Software
engineering
engineering
discipline
concerned
aspects
software
production
Software
program
programs
includes
electronic
documentation
needed
system
users
quality
assurance
staff
developers
Essential
software
product
attributes
maintainability
dependability
security
efficiency
acceptability
software
process
includes
activities
involved
software
development
high
level
activities
specification
development
validation
evolution
part
software
processes
many
different
types
system
requires
appropriate
software
engineering
tools
techniques
development
specific
design
implementation
techniques
applicable
kinds
system
fundamental
ideas
software
engineering
applicable
types
software
system
fundamentals
include
managed
software
processes
software
dependability
security
requirements
engineering
software
reuse
Software
engineers
responsibilities
engineering
profession
society
simply
concerned
technical
issues
aware
ethical
issues
affect
work
Professional
societies
publish
codes
conduct
embed
ethical
professional
standards
set
standards
behavior
expected
members
reading
Software
Engineering
Code
Ethics
Approved
article
discusses
background
development
ACM
IEEE
Code
Ethics
includes
short
long
form
code
Comm
ACM
D
Gotterbarn
K
Miller
S
Rogerson
October
http
dx
doi
org
MC
View
th
st
Century
Software
Engineering
backward
forward
look
software
engineering
one
first
distinguished
software
engineers
Barry
Boehm
identifies
timeless
software
engineering
principles
suggests
commonly
used
practices
obsolete
B
Boehm
Proc
th
Software
Engineering
Conf
Shanghai
http
dx
doi
org
Software
Engineering
Ethics
Special
issue
IEEE
Computer
several
papers
topic
IEEE
Computer
June
Ethics
Information
Age
wide
ranging
book
covers
aspects
information
technology
ethics
simply
ethics
software
engineers
think
right
approach
really
need
understand
software
engineering
ethics
wider
ethical
framework
M
J
Quinn
Addison
Wesley
@@@@@@@@@@
Chapter
Exercises
Essence
Software
Engineering
Applying
SEMAT
kernel
book
discusses
idea
universal
framework
underlie
software
engineering
methods
adapted
used
types
systems
organizations
personally
skeptical
universal
approach
realistic
practice
book
interesting
ideas
worth
exploring
Jacobsen
P
W
Ng
P
E
McMahon
Spence
S
Lidman
Addison
Wesley
WebSite
PowerPoint
slides
chapter
www
pearsonglobaleditions
com
Sommerville
Links
supporting
videos
http
software
engineering
book
com
videos
software
engineering
Links
case
study
descriptions
http
software
engineering
book
com
case
studies
exerCiSeS
Explain
professional
software
developed
customer
simply
programs
developed
delivered
important
difference
generic
software
product
development
custom
software
development
mean
practice
users
generic
software
products
Briefly
discuss
usually
cheaper
long
run
use
software
engineering
methods
techniques
software
systems
Software
engineering
concerned
issues
like
system
heterogeneity
business
social
change
trust
security
ethical
issues
affecting
domain
Give
examples
ethical
issues
impact
software
engineering
domain
Based
knowledge
application
types
discussed
Section
explain
examples
different
application
types
require
specialized
software
engineering
techniques
support
design
development
Explain
fundamental
software
engineering
principles
process
dependability
requirements
management
reuse
relevant
types
software
system
Explain
electronic
connectivity
various
development
teams
support
software
engineering
activities
Noncertified
individuals
still
allowed
practice
software
engineering
Discuss
possible
drawbacks
@@@@@@@@@@
Chapter
Introduction
clauses
ACM
IEEE
Code
Ethics
shown
Figure
propose
appropriate
example
illustrates
clause
Drone
Revolution
currently
debated
discussed
world
Drones
unmanned
flying
machines
built
equipped
various
kinds
software
systems
allow
see
hear
act
Discuss
societal
challenges
building
kinds
systems
reFerenCeS
Bott
F
Professional
Issues
Information
Technology
Swindon
UK
British
Computer
Society
Duquenoy
P
Ethical
Legal
Professional
Issues
Computing
London
Thomson
Learning
Freeman
Definitive
Guide
HTML
New
York
Apress
Gotterbarn
D
K
Miller
S
Rogerson
Software
Engineering
Code
Ethics
Approved
Comm
ACM
doi
MC
Holdener
T
Ajax
Definitive
Guide
Sebastopol
CA
O
Reilly
Associates
Jacobson
P
W
Ng
P
E
McMahon
Spence
S
Lidman
Essence
Software
Engineering
Boston
Addison
Wesley
Johnson
D
G
Computer
Ethics
Englewood
Cliffs
NJ
Prentice
Hall
Laudon
K
Ethical
Concepts
Information
Technology
Comm
ACM
doi
Naur
P
Randell
B
Software
Engineering
Report
conference
sponsored
NATO
Science
Committee
Brussels
http
homepages
cs
ncl
ac
uk
brian
randell
NATO
nato
pdf
Tavani
H
T
Ethics
Technology
Controversies
Questions
Strategies
Ethical
Computing
th
ed
New
York
John
Wiley
Sons
Vogel
L
Eclipse
Application
Development
Complete
Guide
Eclipse
RCP
Development
Sebastopol
CA
O
Reilly
Associates
@@@@@@@@@@
Software
processes
Objectives
objective
chapter
introduce
idea
software
process
coherent
set
activities
software
production
read
chapter
understand
concepts
software
processes
software
process
models
introduced
three
general
software
process
models
used
know
fundamental
process
activities
software
requirements
engineering
software
development
testing
evolution
understand
processes
organized
cope
changes
software
requirements
design
understand
notion
software
process
improvement
factors
affect
software
process
quality
Contents
Software
process
models
Process
activities
Coping
change
Process
improvement
@@@@@@@@@@
Chapter
Software
processes
software
process
set
related
activities
leads
production
software
system
discussed
Chapter
many
different
types
software
systems
no
universal
software
engineering
method
applicable
Consequently
no
universally
applicable
software
process
process
used
different
companies
depends
type
software
developed
requirements
software
customer
skills
people
writing
software
However
many
different
software
processes
include
form
four
fundamental
software
engineering
activities
introduced
Chapter
Software
specification
functionality
software
constraints
operation
defined
Software
development
software
meet
specification
produced
Software
validation
software
validated
ensure
customer
wants
Software
evolution
software
evolve
meet
changing
customer
needs
activities
complex
activities
include
subactivities
requirements
validation
architectural
design
unit
testing
Processes
include
activities
software
configuration
management
project
planning
support
production
activities
describe
discuss
processes
usually
talk
activities
processes
specifying
data
model
designing
user
interface
ordering
activities
relate
people
develop
software
However
describing
processes
important
describe
involved
produced
conditions
influence
sequence
activities
Products
deliverables
outcomes
process
activity
example
outcome
activity
architectural
design
model
software
architecture
Roles
reflect
responsibilities
people
involved
process
Examples
roles
project
manager
configuration
manager
programmer
Pre
postconditions
conditions
hold
process
activity
enacted
product
produced
example
architectural
design
begins
precondition
consumer
approved
requirements
activity
finished
postcondition
UML
models
describing
architecture
reviewed
Software
processes
complex
like
intellectual
creative
processes
rely
people
making
decisions
judgments
no
universal
process
right
kinds
software
software
companies
developed
@@@@@@@@@@
Software
process
models
development
processes
Processes
evolved
take
advantage
capabilities
software
developers
organization
characteristics
systems
developed
safety
critical
systems
structured
development
process
required
detailed
records
maintained
business
systems
rapidly
changing
requirements
flexible
agile
process
likely
better
discussed
Chapter
professional
Professional
software
development
managed
activity
planning
inherent
part
processes
Plan
driven
processes
processes
process
activities
planned
advance
progress
measured
plan
agile
processes
discuss
Chapter
planning
incremental
continual
software
developed
therefore
easier
change
process
reflect
changing
customer
product
requirements
Boehm
Turner
Boehm
Turner
explain
approach
suitable
different
types
software
Generally
large
systems
need
find
balance
plan
driven
agile
processes
no
universal
software
process
scope
process
improvement
many
organizations
Processes
include
outdated
techniques
take
advantage
best
practice
industrial
software
engineering
Indeed
many
organizations
still
take
advantage
software
engineering
methods
software
development
improve
process
introducing
techniques
UML
modeling
test
driven
development
discuss
software
process
improvement
briefly
later
thischapter
text
detail
web
Chapter
Software
process
models
explained
Chapter
software
process
model
sometimes
called
Software
Development
Life
Cycle
SDLC
model
simplified
representation
software
process
process
model
represents
process
particular
perspective
thus
provides
partial
information
process
example
process
activity
model
shows
activities
sequence
show
roles
people
involved
activities
section
introduce
number
general
process
models
sometimes
called
process
paradigms
present
architectural
perspective
see
framework
process
details
process
activities
generic
models
high
level
abstract
descriptions
software
processes
used
explain
different
approaches
software
development
think
process
frameworks
extended
adapted
create
specific
software
engineering
processes
general
process
models
cover
waterfall
model
takes
fundamental
process
activities
specification
development
validation
evolution
represents
separate
process
phases
requirements
specification
software
design
implementation
testing
@@@@@@@@@@
Chapter
Software
processes
Rational
Unified
Process
Rational
Unified
Process
RUP
brings
together
elements
general
process
models
discussed
supports
prototyping
incremental
delivery
software
Krutchen
RUP
normally
described
three
perspectives
dynamic
perspective
shows
phases
model
time
static
perspective
shows
process
activities
practice
perspective
suggests
good
practices
used
process
Phases
RUP
inception
business
case
system
established
elaboration
requirements
architecture
developed
construction
software
implemented
transition
system
deployed
http
software
engineering
book
com
web
rup
Incremental
development
approach
interleaves
activities
specification
development
validation
system
developed
series
versions
increments
version
adding
functionality
previous
version
Integration
configuration
approach
relies
availability
reusable
components
systems
system
development
process
focuses
configuring
components
use
new
setting
integrating
system
said
no
universal
process
model
right
kinds
software
development
right
process
depends
customer
regulatory
requirements
environment
software
used
type
software
developed
example
safety
critical
software
usually
developed
using
waterfall
process
lots
analysis
documentation
required
implementation
begins
Software
products
now
developed
using
incremental
process
model
Business
systems
increasingly
developed
configuring
existing
systems
integrating
create
new
system
functionality
required
majority
practical
software
processes
based
general
model
often
incorporate
features
models
particularly
true
large
systems
engineering
large
systems
makes
sense
combine
best
features
general
processes
need
information
essential
system
requirements
design
software
architecture
support
requirements
cannot
develop
incrementally
Subsystems
larger
system
developed
using
different
approaches
Parts
system
well
understood
specified
developed
using
waterfall
based
process
bought
off
shelf
systems
configuration
parts
system
difficult
specify
advance
developed
using
incremental
approach
cases
software
components
likely
reused
Various
attempts
made
develop
universal
process
models
draw
general
models
One
best
known
universal
models
Rational
Unified
Process
RUP
Krutchen
developed
Rational
U
S
software
engineering
company
RUP
flexible
model
@@@@@@@@@@
Software
process
models
Requirements
definition
System
software
design
Implementation
unit
testing
Integration
system
testing
Operation
maintenanceFigure
waterfall
model
instantiated
different
ways
create
processes
resemble
general
process
models
discussed
RUP
adopted
large
software
companies
notably
IBM
gained
widespread
acceptance
waterfall
model
first
published
model
software
development
process
derived
engineering
process
models
used
large
military
systems
engineering
Royce
presents
software
development
process
number
stages
shown
Figure
cascade
one
phase
another
model
known
waterfall
model
software
life
cycle
waterfall
model
example
plan
driven
process
principle
least
plan
schedule
process
activities
starting
software
development
stages
waterfall
model
directly
reflect
fundamental
software
development
activities
Requirements
analysis
definition
system
s
services
constraints
goals
established
consultation
system
users
defined
detail
serve
system
specification
System
software
design
systems
design
process
allocates
requirements
hardware
software
systems
establishes
overall
system
architecture
Software
design
involves
identifying
describing
fundamental
software
system
abstractions
relationships
Implementation
unit
testing
stage
software
design
realized
set
programs
program
units
Unit
testing
involves
verifying
unit
meets
specification
@@@@@@@@@@
Chapter
Software
processes
Boehm
s
spiral
process
model
Barry
Boehm
one
pioneers
software
engineering
proposed
incremental
process
model
risk
driven
process
represented
spiral
rather
sequence
activities
Boehm
loop
spiral
represents
phase
software
process
Thus
innermost
loop
concerned
system
feasibility
next
loop
requirements
definition
next
loop
system
design
spiral
model
combines
change
avoidance
change
tolerance
assumes
changes
result
project
risks
includes
explicit
risk
management
activities
reduce
risks
http
software
engineering
book
com
web
spiral
model
Integration
system
testing
individual
program
units
programs
integrated
tested
complete
system
ensure
software
requirements
met
testing
software
system
delivered
customer
Operation
maintenance
Normally
longest
life
cycle
phase
system
installed
put
practical
use
Maintenance
involves
correcting
errors
discovered
earlier
stages
life
cycle
improving
implementation
system
units
enhancing
system
s
services
new
requirements
discovered
principle
result
phase
waterfall
model
one
documents
approved
signed
off
following
phase
start
previous
phase
finished
hardware
development
high
manufacturing
costs
involved
makes
sense
However
software
development
stages
overlap
feed
information
design
problems
requirements
identified
coding
design
problems
found
software
process
practice
never
simple
linear
model
involves
feedback
one
phase
another
new
information
emerges
process
stage
documents
produced
previous
stages
modified
reflect
required
system
changes
example
discovered
requirement
expensive
implement
requirements
document
changed
remove
requirement
However
requires
customer
approval
delays
overall
development
process
result
customers
developers
prematurely
freeze
software
specification
no
changes
made
Unfortunately
means
problems
left
later
resolution
ignored
programmed
around
Premature
freezing
requirements
mean
system
won
t
user
wants
lead
badly
structured
systems
design
problems
circumvented
implementation
tricks
final
life
cycle
phase
operation
maintenance
software
put
use
Errors
omissions
original
software
requirements
discovered
@@@@@@@@@@
Software
process
models
Program
design
errors
emerge
need
new
functionality
identified
system
therefore
evolve
remain
useful
Making
changes
software
maintenance
involve
repeating
previous
process
stages
reality
software
flexible
accommodate
change
developed
need
early
commitment
system
rework
changes
made
means
waterfall
model
appropriate
types
system
Embedded
systems
software
interface
hardware
systems
inflexibility
hardware
usually
possible
delay
decisions
software
s
functionality
implemented
Critical
systems
need
extensive
safety
security
analysis
software
specification
design
systems
specification
design
documents
complete
analysis
possible
Safety
related
problems
specification
design
usually
expensive
correct
implementation
stage
Large
software
systems
part
broader
engineering
systems
developed
several
partner
companies
hardware
systems
developed
using
similar
model
companies
find
easier
use
common
model
hardware
software
Furthermore
several
companies
involved
complete
specifications
needed
allow
independent
development
different
subsystems
waterfall
model
right
process
model
situations
informal
team
communication
possible
software
requirements
change
quickly
Iterative
development
agile
methods
better
systems
important
variant
waterfall
model
formal
system
development
mathematical
model
system
specification
created
model
refined
using
mathematical
transformations
preserve
consistency
executable
code
Formal
development
processes
based
B
method
Abrial
mostly
used
development
software
systems
stringent
safety
reliability
security
requirements
formal
approach
simplifies
production
safety
security
case
demonstrates
customers
regulators
system
meets
safety
security
requirements
However
high
costs
developing
formal
specification
development
model
rarely
used
except
critical
systems
engineering
Incremental
development
Incremental
development
based
idea
developing
initial
implementation
getting
feedback
users
others
evolving
software
several
versions
required
system
developed
Figure
Specification
development
validation
activities
interleaved
rather
separate
rapid
feedback
across
activities
@@@@@@@@@@
Chapter
Software
processes
Concurrent
activities
Outline
description
ValidationFinalversionDevelopmentIntermediateversionsSpecificationInitialversion
Figure
Incremental
development
Incremental
development
form
now
common
approach
development
application
systems
software
products
approach
plan
driven
agile
usually
mixture
approaches
plan
driven
approach
system
increments
identified
advance
agile
approach
adopted
early
increments
identified
development
later
increments
depends
progress
customer
priorities
Incremental
software
development
fundamental
part
agile
development
methods
better
waterfall
approach
systems
requirements
likely
change
development
process
case
business
systems
software
products
Incremental
development
reflects
way
solve
problems
rarely
work
complete
problem
solution
advance
move
toward
solution
series
steps
backtracking
realize
made
mistake
developing
software
incrementally
cheaper
easier
make
changes
software
developed
increment
version
system
incorporates
functionality
needed
customer
Generally
early
increments
system
include
important
urgently
required
functionality
means
customer
user
evaluate
system
relatively
early
stage
development
see
delivers
required
current
increment
changed
possibly
new
functionality
defined
later
increments
Incremental
development
three
major
advantages
waterfall
model
cost
implementing
requirements
changes
reduced
amount
analysis
documentation
redone
significantly
less
required
waterfall
model
easier
get
customer
feedback
development
work
done
Customers
comment
demonstrations
software
see
@@@@@@@@@@
Software
process
models
Problems
incremental
development
incremental
development
many
advantages
problem
free
primary
cause
difficulty
fact
large
organizations
bureaucratic
procedures
evolved
time
mismatch
procedures
informal
iterative
agile
process
Sometimes
procedures
good
reasons
example
procedures
ensure
software
meets
properly
implements
external
regulations
e
g
United
States
Sarbanes
Oxley
accounting
regulations
Changing
procedures
possible
process
conflicts
unavoidable
http
software
engineering
book
com
web
incremental
development
much
implemented
Customers
find
difficult
judge
progress
software
design
documents
Early
delivery
deployment
useful
software
customer
possible
even
functionality
included
Customers
able
use
gain
value
software
earlier
possible
waterfall
process
management
perspective
incremental
approach
two
problems
process
visible
Managers
need
regular
deliverables
measure
progress
systems
developed
quickly
cost
effective
produce
documents
reflect
every
version
system
System
structure
tends
degrade
new
increments
added
Regular
change
leads
messy
code
new
functionality
added
whatever
way
possible
becomes
increasingly
difficult
costly
add
new
features
system
reduce
structural
degradation
general
code
messiness
agile
methods
suggest
regularly
refactor
improve
restructure
software
problems
incremental
development
particularly
acute
large
complex
long
lifetime
systems
different
teams
develop
different
parts
system
Large
systems
need
stable
framework
architecture
responsibilities
different
teams
working
parts
system
need
clearly
defined
respect
architecture
planned
advance
rather
developed
incrementally
Incremental
development
mean
deliver
increment
system
customer
develop
system
incrementally
expose
customers
stakeholders
comment
without
necessarily
delivering
deploying
customer
s
environment
Incremental
delivery
covered
Section
means
software
used
real
operational
processes
user
feedback
likely
realistic
However
providing
feedback
possible
experimenting
new
software
disrupt
normal
business
processes
@@@@@@@@@@
Chapter
Software
processes
Requirements
specification
Software
discovery
Software
evaluation
Requirements
refinement
Configure
application
system
Adapt
components
Integrate
system
Develop
new
components
Application
system
available
Components
availableFigure
Reuse
oriented
software
engineering
Integration
configuration
majority
software
projects
software
reuse
often
happens
informally
people
working
project
know
search
code
similar
required
look
modify
needed
integrate
new
code
developed
informal
reuse
takes
place
regardless
development
process
used
However
since
software
development
processes
focus
reuse
existing
software
widely
used
Reuse
oriented
approaches
rely
base
reusable
software
components
integrating
framework
composition
components
Three
types
software
components
frequently
reused
Stand
alone
application
systems
configured
use
particular
environment
systems
general
purpose
systems
many
features
adapted
use
specific
application
Collections
objects
developed
component
package
integrated
component
framework
Java
Spring
framework
Wheeler
White
Web
services
developed
according
service
standards
available
remote
invocation
Internet
Figure
shows
general
process
model
reuse
based
development
based
integration
configuration
stages
process
Requirements
specification
initial
requirements
system
proposed
elaborated
detail
include
brief
descriptions
essential
requirements
desirable
system
features
Software
discovery
evaluation
Given
outline
software
requirements
search
made
components
systems
provide
functionality
required
Candidate
components
systems
evaluated
see
@@@@@@@@@@
Software
process
models
Software
development
tools
Software
development
tools
programs
used
support
software
engineering
process
activities
tools
include
requirements
management
tools
design
editors
refactoring
support
tools
compilers
debuggers
bug
trackers
system
building
tools
Software
tools
provide
process
support
automating
process
activities
providing
information
software
developed
example
development
graphical
system
models
part
requirements
specification
software
design
generation
code
graphical
models
generation
user
interfaces
graphical
interface
description
created
interactively
user
Program
debugging
provision
information
executing
program
automated
translation
programs
written
using
old
version
programming
language
recent
version
Tools
combined
framework
called
Interactive
Development
Environment
IDE
provides
common
set
facilities
tools
use
easier
tools
communicate
operate
integrated
way
http
software
engineering
book
com
web
software
tools
meet
essential
requirements
generally
suitable
use
system
Requirements
refinement
stage
requirements
refined
using
information
reusable
components
applications
discovered
requirements
modified
reflect
available
components
system
specification
re
defined
modifications
impossible
component
analysis
activity
reentered
search
alternative
solutions
Application
system
configuration
off
shelf
application
system
meets
requirements
available
configured
use
create
new
system
Component
adaptation
integration
no
off
shelf
system
individual
reusable
components
modified
new
components
developed
integrated
create
system
Reuse
oriented
software
engineering
based
around
configuration
integration
obvious
advantage
reducing
amount
software
developed
reducing
cost
risks
usually
leads
faster
delivery
software
However
requirements
compromises
inevitable
lead
system
@@@@@@@@@@
Chapter
Software
processes
meet
real
needs
users
Furthermore
control
system
evolution
lost
new
versions
reusable
components
control
organization
using
Software
reuse
important
several
chapters
third
dedicated
several
chapters
rd
part
book
topic
General
issues
software
reuse
covered
Chapter
component
based
software
engineering
Chapters
service
oriented
systems
Chapter
Process
activities
Real
software
processes
interleaved
sequences
technical
collaborative
managerial
activities
overall
goal
specifying
designing
implementing
testing
software
system
Generally
processes
now
tool
supported
means
software
developers
use
range
software
tools
help
requirements
management
systems
design
model
editors
program
editors
automated
testing
tools
debuggers
four
basic
process
activities
specification
development
validation
evolution
organized
differently
different
development
processes
waterfall
model
organized
sequence
incremental
development
interleaved
activities
carried
depends
type
software
developed
experience
competence
developers
type
organization
developing
software
Software
specification
Software
specification
requirements
engineering
process
understanding
defining
services
required
system
identifying
constraints
system
s
operation
development
Requirements
engineering
particularly
critical
stage
software
process
mistakes
made
stage
inevitably
lead
later
problems
system
design
implementation
requirements
engineering
process
starts
company
carry
feasibility
marketing
study
assess
need
market
software
technically
financially
realistic
develop
software
required
Feasibility
studies
short
term
relatively
cheap
studies
inform
decision
go
ahead
detailed
analysis
requirements
engineering
process
Figure
aims
produce
agreed
requirements
document
specifies
system
satisfying
stakeholder
requirements
Requirements
usually
presented
two
levels
detail
End
users
customers
need
high
level
statement
requirements
system
developers
need
detailed
system
specification
@@@@@@@@@@
Process
activities
Requirements
elicitation
analysis
Requirements
specification
Requirements
validation
System
descriptions
User
system
requirements
Requirements
document
Figure
requirements
engineering
process
three
main
activities
requirements
engineering
process
Requirements
elicitation
analysis
process
deriving
system
requirements
observation
existing
systems
discussions
potential
users
procurers
task
analysis
involve
development
one
system
models
prototypes
help
understand
system
specified
Requirements
specification
Requirements
specification
activity
translating
information
gathered
requirements
analysis
document
defines
set
requirements
Two
types
requirements
included
document
User
requirements
abstract
statements
system
requirements
customer
end
user
system
system
requirements
detailed
description
functionality
provided
Requirements
validation
activity
checks
requirements
realism
consistency
completeness
process
errors
requirements
document
inevitably
discovered
modified
correct
problems
Requirements
analysis
continues
definition
specification
new
requirements
come
light
throughout
process
Therefore
activities
analy
sis
definition
specification
interleaved
agile
methods
requirements
specification
separate
activity
seen
part
system
development
Requirements
informally
specified
increment
system
increment
developed
Requirements
specified
according
user
priorities
elicitation
requirements
comes
users
part
work
closely
development
team
@@@@@@@@@@
Chapter
Software
processes
Design
inputs
Platform
Software
Data
information
requirements
descriptions
Design
outputs
Architectural
design
Interface
design
Database
design
Component
selection
design
Design
activities
System
architecture
Interface
specification
Database
design
Component
descriptionsFigure
general
model
design
process
Software
design
implementation
implementation
stage
software
development
process
developing
executable
system
delivery
customer
Sometimes
involves
separate
activities
software
design
programming
However
agile
approach
development
used
design
implementation
interleaved
no
formal
design
documents
produced
process
course
software
still
designed
design
recorded
informally
whiteboards
programmer
s
notebooks
software
design
description
structure
software
implemented
data
models
structures
used
system
interfaces
system
components
sometimes
algorithms
used
Designers
arrive
finished
design
immediately
develop
design
stages
add
detail
develop
design
constant
backtracking
modify
earlier
designs
Figure
abstract
model
design
process
showing
inputs
design
process
process
activities
process
outputs
design
process
activities
interleaved
interdependent
New
information
design
constantly
generated
affects
previous
design
decisions
Design
rework
therefore
inevitable
@@@@@@@@@@
Process
activities
software
interfaces
software
systems
systems
include
operating
system
database
middleware
application
systems
make
software
platform
environment
software
execute
Information
platform
essential
input
design
process
designers
decide
best
integrate
environment
system
process
existing
data
description
data
included
platform
specification
Otherwise
data
description
input
design
process
system
data
organization
defined
activities
design
process
vary
depending
type
system
developed
example
real
time
systems
require
additional
stage
timing
design
include
database
no
database
design
involved
Figure
shows
four
activities
part
design
process
information
systems
Architectural
design
identify
overall
structure
system
principal
components
sometimes
called
subsystems
modules
relationships
distributed
Database
design
design
system
data
structures
represented
database
work
depends
existing
database
reused
new
database
created
Interface
design
define
interfaces
system
components
interface
specification
unambiguous
precise
interface
component
used
components
without
know
implemented
interface
specifications
agreed
components
separately
designed
developed
Component
selection
design
search
reusable
components
no
suitable
components
available
design
new
software
components
design
stage
simple
component
description
implementation
details
left
programmer
Alternatively
list
changes
made
reusable
component
detailed
design
model
expressed
UML
design
model
used
automatically
generate
implementation
activities
lead
design
outputs
shown
Figure
critical
systems
outputs
design
process
detailed
design
documents
setting
precise
accurate
descriptions
system
model
driven
approach
used
Chapter
design
outputs
design
diagrams
agile
methods
development
used
outputs
design
process
separate
specification
documents
represented
code
program
development
program
implement
system
follows
naturally
system
design
classes
program
safety
critical
systems
usually
designed
detail
implementation
begins
common
design
program
development
interleaved
Software
development
tools
used
generate
skeleton
program
design
includes
code
@@@@@@@@@@
Chapter
Software
processes
Figure
Stages
testing
System
testing
Component
testing
Customertesting
define
implement
interfaces
many
cases
developer
need
add
details
operation
program
component
Programming
individual
activity
no
general
process
usually
followed
programmers
start
components
understand
develop
move
less
understood
components
Others
take
opposite
approach
leaving
familiar
components
till
last
know
develop
developers
like
define
data
early
process
use
drive
program
development
others
leave
data
unspecified
long
possible
Normally
programmers
carry
testing
code
developed
often
reveals
program
defects
bugs
removed
program
Finding
fixing
program
defects
called
debugging
Defect
testing
debugging
different
processes
Testing
establishes
existence
defects
Debugging
concerned
locating
correcting
defects
debugging
generate
hypotheses
observable
behavior
program
test
hypotheses
hope
finding
fault
caused
output
anomaly
Testing
hypotheses
involve
tracing
program
code
manually
require
new
test
cases
localize
problem
Interactive
debugging
tools
show
intermediate
values
program
variables
trace
statements
executed
usually
used
support
debugging
process
Software
validation
Software
validation
generally
verification
validation
V
V
intended
show
system
conforms
specification
meets
expectations
system
customer
Program
testing
system
executed
using
simulated
test
data
principal
validation
technique
Validation
involve
checking
processes
inspections
reviews
stage
software
process
user
requirements
definition
program
development
However
V
V
time
effort
spent
program
testing
Except
small
programs
systems
tested
single
monolithic
unit
Figure
shows
three
stage
testing
process
system
components
individually
tested
integrated
system
tested
custom
software
customer
testing
involves
testing
system
real
customer
data
products
sold
applications
customer
testing
sometimes
called
beta
testing
selected
users
try
comment
software
@@@@@@@@@@
Process
activities
stages
testing
process
Component
testing
components
making
system
tested
people
developing
system
component
tested
independently
without
system
components
Components
simple
entities
functions
object
classes
coherent
groupings
entities
Test
automation
tools
JUnit
Java
rerun
tests
new
versions
component
created
commonly
used
Koskela
System
testing
System
components
integrated
create
complete
system
process
concerned
finding
errors
result
unanticipated
interactions
components
component
interface
problems
concerned
showing
system
meets
functional
non
functional
requirements
testing
emergent
system
properties
large
systems
multistage
process
components
integrated
form
subsystems
individually
tested
subsystems
integrated
form
final
system
Customer
testing
final
stage
testing
process
system
accepted
operational
use
system
tested
system
customer
potential
customer
rather
simulated
test
data
custom
built
software
customer
testing
reveal
errors
omissions
system
requirements
definition
real
data
exercise
system
different
ways
test
data
Customer
testing
reveal
requirements
problems
system
s
facilities
really
meet
users
needs
system
performance
unacceptable
products
customer
testing
shows
well
software
product
meets
customer
s
needs
Ideally
component
defects
discovered
early
testing
process
interface
problems
found
system
integrated
However
defects
discovered
program
debugged
require
stages
testing
process
repeated
Errors
program
components
say
come
light
system
testing
process
therefore
iterative
one
information
fed
back
later
stages
earlier
parts
process
Normally
component
testing
simply
part
normal
development
process
Programmers
make
test
data
incrementally
test
code
developed
programmer
knows
component
therefore
best
person
generate
test
cases
incremental
approach
development
used
increment
tested
developed
tests
based
requirements
increment
test
driven
development
normal
part
agile
processes
tests
developed
along
requirements
development
starts
helps
testers
developers
understand
requirements
ensures
no
delays
test
cases
created
plan
driven
software
process
used
e
g
critical
systems
development
testing
driven
set
test
plans
independent
team
testers
works
@@@@@@@@@@
Chapter
Software
processes
Requirements
specification
System
specification
Customer
test
System
integration
test
Sub
system
integration
test
System
design
Component
design
Service
Component
code
test
Customer
test
plan
System
integration
test
plan
Sub
system
integration
test
plan
Figure
Testing
phases
plan
driven
software
process
test
plans
developed
system
specification
design
Figure
illustrates
test
plans
link
testing
development
activities
sometimes
called
V
model
development
turn
side
see
V
V
model
shows
software
validation
activities
correspond
stage
waterfall
process
model
system
marketed
software
product
testing
process
called
beta
testing
often
used
Beta
testing
involves
delivering
system
number
potential
customers
agree
use
system
report
problems
system
developers
exposes
product
real
use
detects
errors
anticipated
product
developers
feedback
software
product
modified
released
beta
testing
general
sale
Software
evolution
flexibility
software
one
main
reasons
software
incorporated
large
complex
systems
decision
made
manufacture
hardware
expensive
make
changes
hardware
design
However
changes
made
software
time
system
development
Even
extensive
changes
still
much
cheaper
corresponding
changes
system
hardware
Historically
split
process
software
development
process
software
evolution
software
maintenance
People
think
software
development
creative
activity
software
system
developed
initial
concept
working
system
However
sometimes
think
software
maintenance
dull
uninteresting
think
software
maintenance
less
interesting
challenging
original
software
development
distinction
development
maintenance
increasingly
irrelevant
software
systems
completely
new
systems
makes
much
@@@@@@@@@@
Coping
change
Figure
Software
system
evolution
Assess
existing
systems
Define
system
requirements
Propose
system
changes
Modify
systems
Existing
systems
New
system
sense
see
development
maintenance
continuum
Rather
two
separate
processes
realistic
think
software
engineering
evolutionary
process
Figure
software
continually
changed
lifetime
response
changing
requirements
customer
needs
Coping
change
Change
inevitable
large
software
projects
system
requirements
change
businesses
respond
external
pressures
competition
changed
management
priorities
new
technologies
available
new
approaches
design
implementation
possible
Therefore
whatever
software
process
model
used
essential
accommodate
changes
software
developed
Change
adds
costs
software
development
usually
means
work
completed
redone
called
rework
example
relationships
requirements
system
analyzed
new
requirements
identified
requirements
analysis
repeated
necessary
redesign
system
deliver
new
requirements
change
programs
developed
retest
system
Two
related
approaches
used
reduce
costs
rework
Change
anticipation
software
process
includes
activities
anticipate
predict
possible
changes
significant
rework
required
example
prototype
system
developed
show
key
features
system
customers
experiment
prototype
refine
requirements
committing
high
software
production
costs
Change
tolerance
process
software
designed
changes
easily
made
system
normally
involves
form
incremental
development
Proposed
changes
implemented
increments
developed
impossible
single
increment
small
part
system
altered
incorporate
change
@@@@@@@@@@
Chapter
Software
processes
section
discuss
two
ways
coping
change
changing
system
requirements
System
prototyping
version
system
part
system
developed
quickly
check
customer
s
requirements
feasibility
design
decisions
method
change
anticipation
allows
users
experiment
system
delivery
refine
requirements
number
requirements
change
proposals
made
delivery
therefore
likely
reduced
Incremental
delivery
system
increments
delivered
customer
comment
experimentation
supports
change
avoidance
change
tolerance
avoids
premature
commitment
requirements
whole
system
allows
changes
incorporated
later
increments
relatively
low
cost
notion
refactoring
namely
improving
structure
organization
program
important
mechanism
supports
change
tolerance
discuss
Chapter
Agile
methods
Prototyping
prototype
early
version
software
system
used
demonstrate
concepts
try
design
options
find
problem
possible
solutions
Rapid
iterative
development
prototype
essential
costs
controlled
system
stakeholders
experiment
prototype
early
software
process
software
prototype
used
software
development
process
help
anticipate
changes
required
requirements
engineering
process
prototype
help
elicitation
validation
system
requirements
system
design
process
prototype
used
explore
software
solutions
development
user
interface
system
System
prototypes
allow
potential
users
see
well
system
supports
work
get
new
ideas
requirements
find
areas
strength
weakness
software
propose
new
system
requirements
Furthermore
prototype
developed
reveal
errors
omissions
system
requirements
feature
described
specification
seem
clear
useful
However
function
combined
functions
users
often
find
initial
view
incorrect
incomplete
system
specification
modified
reflect
changed
understanding
requirements
@@@@@@@@@@
Coping
change
EstablishprototypeobjectivesDefineprototypefunctionalityDevelopprototypeEvaluateprototypeFigure
Prototype
development
OutlinedefinitionExecutableprototypeEvaluationreportPrototypingplan
system
prototype
used
system
designed
carry
design
experiments
check
feasibility
proposed
design
example
database
design
prototyped
tested
check
supports
efficient
data
access
common
user
queries
Rapid
prototyping
end
user
involvement
sensible
way
develop
user
interfaces
dynamic
nature
user
interfaces
textual
descriptions
diagrams
good
enough
expressing
user
interface
requirements
design
process
model
prototype
development
shown
Figure
objectives
prototyping
made
explicit
start
process
develop
user
interface
develop
system
validate
functional
system
requirements
develop
system
demonstrate
application
managers
prototype
usually
cannot
meet
objectives
objectives
left
unstated
management
end
users
misunderstand
function
prototype
Consequently
get
benefits
expected
prototype
development
next
stage
process
decide
put
perhaps
importantly
leave
prototype
system
reduce
prototyping
costs
accelerate
delivery
schedule
leave
functionality
prototype
decide
relax
non
functional
requirements
response
time
memory
utilization
Error
handling
management
ignored
unless
objective
prototype
establish
user
interface
Standards
reliability
program
quality
reduced
final
stage
process
prototype
evaluation
Provision
made
stage
user
training
prototype
objectives
used
derive
plan
evaluation
Potential
users
need
time
comfortable
new
system
settle
normal
pattern
usage
using
system
normally
discover
requirements
errors
omissions
general
problem
prototyping
users
use
prototype
way
use
final
system
Prototype
testers
typical
system
users
enough
time
train
users
prototype
evaluation
prototype
slow
evaluators
adjust
way
working
avoid
system
features
slow
response
times
provided
better
response
final
system
use
different
way
@@@@@@@@@@
Chapter
Software
processes
Design
system
architecture
Define
outline
requirements
Assign
requirements
increments
System
incomplete
Develop
system
increment
Validate
increment
Integrate
increment
Validate
system
Deploy
increment
System
complete
Figure
Incremental
delivery
Incremental
delivery
Final
system
Incremental
delivery
Figure
approach
software
development
developed
increments
delivered
customer
deployed
use
working
environment
incremental
delivery
process
customers
define
services
important
least
important
number
delivery
increments
defined
increment
providing
subset
system
functionality
allocation
services
increments
depends
service
priority
highest
priority
services
implemented
delivered
first
system
increments
identified
requirements
services
delivered
first
increment
defined
detail
increment
developed
development
requirements
analysis
later
increments
take
place
requirements
changes
current
increment
accepted
increment
completed
delivered
installed
customer
s
normal
working
environment
experiment
system
helps
clarify
requirements
later
system
increments
new
increments
completed
integrated
existing
increments
system
functionality
improves
delivered
increment
Incremental
delivery
number
advantages
Customers
use
early
increments
prototypes
gain
experience
informs
requirements
later
system
increments
Unlike
prototypes
part
real
system
no
relearning
complete
system
available
Customers
wait
entire
system
delivered
gain
value
first
increment
satisfies
critical
requirements
use
software
immediately
process
maintains
benefits
incremental
development
relatively
easy
incorporate
changes
system
@@@@@@@@@@
Process
improvement
highest
priority
services
delivered
first
later
increments
integrated
important
system
services
receive
testing
means
customers
less
likely
encounter
software
failures
important
parts
system
However
problems
incremental
delivery
practice
works
situations
brand
new
system
introduced
system
evaluators
given
time
experiment
new
system
Key
problems
approach
Iterative
delivery
problematic
new
system
intended
replace
existing
system
Users
need
functionality
old
system
usually
unwilling
experiment
incomplete
new
system
often
impractical
use
old
new
systems
alongside
likely
different
databases
user
interfaces
systems
require
set
basic
facilities
used
different
parts
system
requirements
defined
detail
increment
implemented
hard
identify
common
facilities
needed
increments
essence
iterative
processes
specification
developed
conjunction
software
However
conflicts
procurement
model
many
organizations
complete
system
specification
part
system
development
contract
incremental
approach
no
complete
system
specification
final
increment
specified
requires
new
form
contract
large
customers
government
agencies
find
difficult
accommodate
types
systems
incremental
development
delivery
best
approach
large
systems
development
involve
teams
working
different
locations
embedded
systems
software
depends
hardware
development
critical
systems
requirements
analyzed
check
interactions
compromise
safety
security
system
large
systems
course
suffer
problems
uncertain
changing
requirements
Therefore
address
problems
get
benefits
incremental
development
system
prototype
developed
used
platform
experiments
system
requirements
design
experience
gained
prototype
definitive
requirements
agreed
Process
improvement
Nowadays
constant
demand
industry
cheaper
better
software
delivered
ever
tighter
deadlines
Consequently
many
software
companies
turned
software
process
improvement
way
enhancing
@@@@@@@@@@
Chapter
Software
processes
Figure
process
improvement
cycle
AnalyzeMeasureChange
quality
software
reducing
costs
accelerating
development
processes
Process
improvement
means
understanding
existing
processes
changing
processes
increase
product
quality
reduce
costs
development
time
cover
general
issues
process
measurement
process
improvement
detail
web
Chapter
Two
quite
different
approaches
process
improvement
change
used
process
maturity
approach
focused
improving
process
project
management
introducing
good
software
engineering
practice
organization
level
process
maturity
reflects
extent
good
technical
management
practice
adopted
organizational
software
development
processes
primary
goals
approach
improved
product
quality
process
predictability
agile
approach
focused
iterative
development
reduction
overheads
software
process
primary
characteristics
agile
methods
rapid
delivery
functionality
responsiveness
changing
customer
requirements
improvement
philosophy
best
processes
lowest
overheads
agile
approaches
achieve
describe
agile
approaches
Chapter
People
enthusiastic
committed
approaches
generally
skeptical
benefits
process
maturity
approach
rooted
plan
driven
development
usually
requires
increased
overhead
sense
activities
introduced
directly
relevant
program
development
Agile
approaches
focus
code
developed
deliberately
minimize
formality
documentation
general
process
improvement
process
underlying
process
maturity
approach
cyclical
process
shown
Figure
stages
process
Process
measurement
measure
one
attributes
software
process
product
measurements
form
baseline
helps
decide
@@@@@@@@@@
Process
improvement
process
improvements
effective
introduce
improvements
re
measure
attributes
hopefully
improved
way
Process
analysis
current
process
assessed
process
weaknesses
bottlenecks
identified
Process
models
sometimes
called
process
maps
describe
process
developed
stage
analysis
focused
considering
process
characteristics
rapidity
robustness
Process
change
Process
changes
proposed
address
identified
process
weaknesses
introduced
cycle
resumes
collect
data
effectiveness
changes
Without
concrete
data
process
software
developed
using
process
impossible
assess
value
process
improvement
However
companies
starting
process
improvement
process
unlikely
process
data
available
improvement
baseline
Therefore
part
first
cycle
changes
collect
data
software
process
measure
software
product
characteristics
Process
improvement
long
term
activity
stages
improvement
process
last
several
months
continuous
activity
whatever
new
processes
introduced
business
environment
change
new
processes
evolve
take
changes
account
notion
process
maturity
introduced
late
s
Software
Engineering
Institute
SEI
proposed
model
process
capability
maturity
Humphrey
maturity
software
company
s
processes
reflects
process
management
measurement
use
good
software
engineering
practices
company
idea
introduced
U
S
Department
Defense
assess
software
engineering
capability
defense
contractors
view
limiting
contracts
contractors
reached
required
level
process
maturity
Five
levels
process
maturity
proposed
shown
Figure
evolved
developed
last
years
Chrissis
Konrad
Shrum
fundamental
ideas
Humphrey
s
model
still
basis
software
process
maturity
assessment
levels
process
maturity
model
Initial
goals
associated
process
area
satisfied
processes
scope
work
performed
explicitly
set
communicated
team
members
Managed
level
goals
associated
process
area
met
organizational
policies
place
define
process
used
documented
project
plans
define
project
goals
Resource
management
process
monitoring
procedures
place
across
institution
Defined
level
focuses
organizational
standardization
deployment
processes
project
managed
process
adapted
project
requirements
defined
set
organizational
processes
Process
assets
process
measurements
collected
used
future
process
improvements
@@@@@@@@@@
Chapter
Software
processes
Figure
Capability
maturity
levels
Level
DefinedLevel
ManagedLevel
InitialLevel
QuantitativelymanagedLevel
Optimizing
Quantitatively
managed
level
organizational
responsibility
use
statistical
quantitative
methods
control
subprocesses
collected
process
product
measurements
used
process
management
Optimizing
highest
level
organization
use
process
product
measurements
drive
process
improvement
Trends
analyzed
processes
adapted
changing
business
needs
work
process
maturity
levels
major
impact
software
industry
focused
attention
software
engineering
processes
practices
used
led
significant
improvements
software
engineering
capability
However
much
overhead
formal
process
improvement
small
companies
maturity
estimation
agile
processes
difficult
Consequently
large
software
companies
now
use
maturity
focused
approach
software
process
improvement
Key
points
Software
processes
activities
involved
producing
software
system
Software
process
models
abstract
representations
processes
General
process
models
describe
organization
software
processes
Examples
general
models
include
waterfall
model
incremental
development
reusable
component
configuration
integration
@@@@@@@@@@
Chapter
Website
Requirements
engineering
process
developing
software
specification
Specifications
intended
communicate
system
needs
customer
system
developers
Design
implementation
processes
concerned
transforming
requirements
specification
executable
software
system
Software
validation
process
checking
system
conforms
specification
meets
real
needs
users
system
Software
evolution
takes
place
change
existing
software
systems
meet
new
requirements
Changes
continuous
software
evolve
remain
useful
Processes
include
activities
cope
change
involve
prototyping
phase
helps
avoid
poor
decisions
requirements
design
Processes
structured
iterative
development
delivery
changes
made
without
disrupting
system
whole
Process
improvement
process
improving
existing
software
processes
improve
software
quality
lower
development
costs
reduce
development
time
cyclic
process
involving
process
measurement
analysis
change
reading
Process
Models
Software
Engineering
excellent
overview
wide
range
software
engineering
process
models
proposed
W
Scacchi
Encyclopaedia
Software
Engineering
ed
J
J
Marciniak
John
Wiley
Sons
http
www
ics
uci
edu
wscacchi
Papers
SE
Encyc
Process
Models
SE
Encyc
pdf
Software
Process
Improvement
Results
Experience
Field
book
collection
papers
focusing
process
improvement
case
studies
several
small
medium
sized
Norwegian
companies
includes
good
introduction
general
issues
process
improvement
Conradi
R
Dyb
T
Sj
berg
D
Ulsund
T
eds
Springer
Software
Development
Life
Cycle
Models
Methodologies
blog
post
succinct
summary
several
software
process
models
proposed
used
discusses
advantages
disadvantages
models
M
Sami
http
melsatar
wordpress
com
software
development
life
cycle
models
methodologies
WebSite
PowerPoint
slides
chapter
www
pearsonglobaleditions
com
Sommerville
Links
supporting
videos
http
software
engineering
book
com
videos
software
engineering
@@@@@@@@@@
Chapter
Software
processes
exerCiSeS
Suggest
appropriate
generic
software
process
model
used
basis
managing
development
following
systems
Explain
answer
according
type
system
developed
system
control
antilock
braking
car
virtual
reality
system
support
software
maintenance
university
accounting
system
replaces
existing
system
interactive
travel
planning
system
helps
users
plan
journeys
lowest
environmental
impact
Incremental
software
development
effectively
used
customers
clear
idea
systems
needed
operations
Discuss
Consider
integration
configuration
process
model
shown
Figure
Explain
essential
repeat
requirements
engineering
activity
process
Suggest
important
make
distinction
developing
user
requirements
developing
system
requirements
requirements
engineering
process
Using
example
explain
design
activities
architectural
design
database
design
interface
design
component
design
interdependent
Explain
software
testing
incremental
staged
activity
programmers
best
people
test
programs
developed
Imagine
government
wants
software
program
helps
keep
track
utilization
country
s
vast
mineral
resources
requirements
put
forward
government
clear
software
company
tasked
development
prototype
government
found
prototype
impressive
asked
extended
actual
system
used
Discuss
pros
cons
taking
approach
developed
prototype
software
system
manager
impressed
proposes
put
use
production
system
new
features
added
required
avoids
expense
system
development
makes
system
immediately
useful
Write
short
report
manager
explaining
prototype
systems
normally
used
production
systems
Suggest
two
advantages
two
disadvantages
approach
process
assessment
improvement
embodied
SEI
s
Capability
Maturity
framework
Historically
introduction
technology
caused
profound
changes
labor
market
temporarily
least
displaced
people
jobs
Discuss
introduction
extensive
process
automation
likely
consequences
software
engineers
don
t
think
explain
think
reduce
job
opportunities
ethical
engineers
affected
passively
actively
resist
introduction
technology
@@@@@@@@@@
Chapter
References
reFerenCeS
Abrial
J
R
B
Book
Assigning
Programs
Meanings
Cambridge
UK
Cambridge
University
Press
Modeling
Event
B
System
Software
Engineering
Cambridge
UK
Cambridge
University
Press
Boehm
B
W
Spiral
Model
Software
Development
Enhancement
IEEE
Computer
doi
Boehm
B
W
R
Turner
Balancing
Agility
Discipline
Evaluating
Integrating
Agile
Plan
Driven
Methods
th
Int
Conf
Software
Engineering
Edinburgh
Scotland
doi
ICSE
Chrissis
M
B
M
Konrad
S
Shrum
CMMI
Development
Guidelines
Process
Integration
Product
Improvement
rd
ed
Boston
Addison
Wesley
Humphrey
W
S
Characterizing
Software
Process
Maturity
Framework
IEEE
Software
doi
Koskela
L
Effective
Unit
Testing
Guide
Java
Developers
Greenwich
CT
Manning
Publications
Krutchen
P
Rational
Unified
Process
Introduction
rd
ed
Reading
MA
Addison
Wesley
Royce
W
W
Managing
Development
Large
Software
Systems
Concepts
Techniques
IEEE
WESTCON
Los
Angeles
CA
Wheeler
W
J
White
Spring
Practice
Greenwich
CT
Manning
Publications
@@@@@@@@@@
Agile
software
development
Objectives
objective
chapter
introduce
agile
software
development
methods
read
chapter
understand
rationale
agile
software
development
methods
agile
manifesto
differences
agile
plan
driven
development
know
important
agile
development
practices
user
stories
refactoring
pair
programming
test
first
development
understand
Scrum
approach
agile
project
management
understand
issues
scaling
agile
development
methods
combining
agile
approaches
plan
driven
approaches
development
large
software
systems
Contents
Agile
methods
Agile
development
techniques
Agile
project
management
Scaling
agile
methods
@@@@@@@@@@
Chapter
Agile
software
development
Businesses
now
operate
global
rapidly
changing
environment
respond
new
opportunities
markets
changing
economic
conditions
emergence
competing
products
services
Software
part
business
operations
new
software
developed
quickly
take
advantage
new
opportunities
respond
competitive
pressure
Rapid
software
development
delivery
therefore
critical
requirement
business
systems
fact
businesses
willing
trade
off
software
quality
compromise
requirements
deploy
essential
new
software
quickly
businesses
operating
changing
environment
practically
impossible
derive
complete
set
stable
software
requirements
Requirements
change
customers
find
impossible
predict
system
affect
working
practices
interact
systems
user
operations
automated
system
delivered
users
gain
experience
real
requirements
clear
Even
external
factors
drive
requirements
change
Plan
driven
software
development
processes
completely
specify
requirements
design
build
test
system
geared
rapid
software
development
requirements
change
requirements
problems
discovered
system
design
implementation
reworked
retested
consequence
conventional
waterfall
specification
based
process
usually
lengthy
one
final
software
delivered
customer
long
originally
specified
types
software
safety
critical
control
systems
complete
analysis
system
essential
plan
driven
approach
right
one
However
fast
moving
business
environment
cause
real
problems
time
software
available
use
original
reason
procurement
changed
radically
software
effectively
useless
Therefore
business
systems
particular
development
processes
focus
rapid
software
development
delivery
essential
need
rapid
software
development
processes
handle
changing
requirements
recognized
many
years
Larman
Basili
However
faster
software
development
really
took
off
late
s
development
idea
agile
methods
Extreme
Programming
Beck
Scrum
Schwaber
Beedle
DSDM
Stapleton
Rapid
software
development
known
agile
development
agile
methods
agile
methods
designed
produce
useful
software
quickly
agile
methods
proposed
share
number
common
characteristics
processes
specification
design
implementation
interleaved
no
detailed
system
specification
design
documentation
minimized
generated
automatically
programming
environment
used
implement
system
user
requirements
document
outline
definition
important
characteristics
system
system
developed
series
increments
End
users
system
stakeholders
involved
specifying
evaluating
increment
@@@@@@@@@@
Chapter
Agile
software
development
Plan
based
development
Requirements
specification
Requirements
engineering
Design
implementation
Requirements
change
Figure
Plan
driven
agile
development
requests
Agile
development
Requirements
engineering
Design
implementation
propose
changes
software
new
requirements
implemented
later
version
system
Extensive
tool
support
used
support
development
process
Tools
used
include
automated
testing
tools
tools
support
configuration
management
system
integration
tools
automate
user
interface
production
Agile
methods
incremental
development
methods
increments
small
typically
new
releases
system
created
made
available
customers
every
two
three
weeks
involve
customers
development
process
get
rapid
feedback
changing
requirements
minimize
documentation
using
informal
communications
rather
formal
meetings
written
documents
Agile
approaches
software
development
consider
design
implementation
central
activities
software
process
incorporate
activities
requirements
elicitation
testing
design
implementation
contrast
plan
driven
approach
software
engineering
identifies
separate
stages
software
process
outputs
associated
stage
outputs
one
stage
used
basis
planning
following
process
activity
Figure
shows
essential
distinctions
plan
driven
agile
approaches
system
specification
plan
driven
software
development
process
iteration
occurs
activities
formal
documents
used
communicate
stages
process
example
requirements
evolve
ultimately
requirements
specification
produced
input
design
implementation
process
agile
approach
iteration
occurs
across
activities
Therefore
requirements
design
developed
together
rather
separately
practice
explain
Section
plan
driven
processes
often
used
along
agile
programming
practices
agile
methods
incorporate
planned
@@@@@@@@@@
activities
apart
programming
testing
perfectly
feasible
plan
driven
process
allocate
requirements
plan
design
development
phase
series
increments
agile
process
inevitably
code
focused
produce
design
documentation
Agile
developers
decide
iteration
produce
new
code
rather
produce
system
models
documentation
Agile
methods
s
early
s
widespread
view
best
way
achieve
better
software
careful
project
planning
formalized
quality
assurance
use
analysis
design
methods
supported
software
tools
controlled
rigorous
software
development
processes
view
came
software
engineering
community
responsible
developing
large
long
lived
software
systems
aerospace
government
systems
plan
driven
approach
developed
software
developed
large
teams
working
different
companies
Teams
often
geographically
dispersed
worked
software
long
periods
time
example
type
software
control
systems
modern
aircraft
take
years
initial
specification
deployment
Plan
driven
approaches
involve
significant
overhead
planning
designing
documenting
system
overhead
justified
work
multiple
development
teams
coordinated
system
critical
system
many
different
people
involved
maintaining
software
lifetime
However
heavyweight
plan
driven
development
approach
applied
small
medium
sized
business
systems
overhead
involved
large
dominates
software
development
process
time
spent
system
developed
program
development
testing
system
requirements
change
rework
essential
principle
least
specification
design
change
program
Dissatisfaction
heavyweight
approaches
software
engineering
led
development
agile
methods
late
s
methods
allowed
development
team
focus
software
rather
design
documentation
best
suited
application
development
system
requirements
usually
change
rapidly
development
process
intended
deliver
working
software
quickly
customers
propose
new
changed
requirements
included
later
iterations
system
aim
cut
process
bureaucracy
avoiding
work
dubious
long
term
value
eliminating
documentation
probably
never
used
philosophy
behind
agile
methods
reflected
agile
manifesto
http
agilemanifesto
org
issued
leading
developers
methods
manifesto
states
@@@@@@@@@@
Chapter
Agile
software
development
Principle
Description
Customer
involvement
Customers
closely
involved
throughout
development
process
role
provide
prioritize
new
system
requirements
evaluate
iterations
system
Team
members
left
develop
ways
working
without
prescriptive
processes
Figure
uncovering
better
ways
developing
software
helping
principles
agile
others
work
come
value
methods
Embrace
change
Expect
system
requirements
change
design
system
accommodate
changes
Incremental
delivery
software
developed
increments
customer
specifying
requirements
included
increment
Maintain
simplicity
Focus
simplicity
software
developed
development
process
possible
actively
work
eliminate
complexity
system
People
process
skills
development
team
recognized
exploited
Individuals
interactions
processes
tools
Working
software
comprehensive
documentation
Customer
collaboration
contract
negotiation
Responding
change
following
plan
value
items
right
value
items
left
agile
methods
suggest
software
developed
delivered
incrementally
methods
based
different
agile
processes
share
set
principles
based
agile
manifesto
much
common
listed
principles
Figure
Agile
methods
particularly
successful
two
kinds
system
development
Product
development
software
company
developing
small
medium
sized
product
sale
Virtually
software
products
apps
now
developed
using
agile
approach
Custom
system
development
organization
clear
commitment
customer
involved
development
process
external
stakeholders
regulations
affect
software
Agile
methods
work
well
situations
possible
continuous
communications
product
manager
system
customer
development
team
software
stand
alone
system
rather
tightly
integrated
systems
developed
time
Consequently
no
need
coordinate
parallel
development
streams
Small
medium
sized
http
agilemanifesto
org
@@@@@@@@@@
Figure
XP
release
cycle
Break
stories
tasks
Select
user
stories
release
Plan
release
Release
software
Evaluate
system
Develop
integrate
test
software
systems
developed
co
located
teams
informal
communications
among
team
members
work
well
Agile
development
techniques
ideas
underlying
agile
methods
developed
around
time
number
different
people
s
However
perhaps
significant
approach
changing
software
development
culture
development
Extreme
Programming
XP
name
coined
Kent
Beck
Beck
approach
developed
pushing
recognized
good
practice
iterative
development
extreme
levels
example
XP
several
new
versions
system
developed
different
programmers
integrated
tested
day
Figure
illustrates
XP
process
produce
increment
system
developed
XP
requirements
expressed
scenarios
called
user
stories
implemented
directly
series
tasks
Programmers
work
pairs
develop
tests
task
writing
code
tests
successfully
executed
new
code
integrated
system
short
time
gap
releases
system
Extreme
programming
controversial
introduced
number
agile
practices
quite
different
development
practice
time
practices
summarized
Figure
reflect
principles
agile
manifesto
Incremental
development
supported
small
frequent
releases
system
Requirements
based
simple
customer
stories
scenarios
used
basis
deciding
functionality
included
system
increment
Customer
involvement
supported
continuous
engagement
customer
development
team
customer
representative
takes
part
development
responsible
defining
acceptance
tests
system
People
process
supported
pair
programming
collective
ownership
system
code
sustainable
development
process
involve
excessively
long
working
hours
@@@@@@@@@@
Chapter
Agile
software
development
Principle
practice
Description
Collective
ownership
pairs
developers
work
areas
system
no
islands
expertise
develop
developers
take
responsibility
code
Anyone
change
anything
Continuous
integration
soon
work
task
complete
integrated
whole
system
integration
unit
tests
system
pass
Incremental
planning
Requirements
recorded
story
cards
stories
included
release
determined
time
available
relative
priority
developers
break
stories
development
tasks
See
Figures
site
customer
representative
end
user
system
Customer
available
full
time
use
XP
team
extreme
programming
process
customer
member
development
team
responsible
bringing
system
requirements
team
implementation
Pair
programming
Developers
work
pairs
checking
s
work
providing
support
good
job
Refactoring
developers
expected
refactor
code
continuously
soon
potential
code
improvements
found
keeps
code
simple
maintainable
Simple
design
Enough
design
carried
meet
current
requirements
no
Small
releases
minimal
useful
set
functionality
provides
business
value
developed
first
Releases
system
frequent
incrementally
add
functionality
first
release
Sustainable
pace
Large
amounts
overtime
considered
acceptable
net
effect
often
reduce
code
quality
medium
term
productivity
Test
first
development
automated
unit
test
framework
used
write
tests
new
piece
functionality
functionality
implemented
Figure
Extreme
programming
practices
Change
embraced
regular
system
releases
customers
test
first
development
refactoring
avoid
code
degeneration
continuous
integration
new
functionality
Maintaining
simplicity
supported
constant
refactoring
improves
code
quality
using
simple
designs
unnecessarily
anticipate
future
changes
system
practice
application
Extreme
Programming
originally
proposed
proved
difficult
anticipated
cannot
readily
integrated
management
practices
culture
businesses
Therefore
companies
adopting
agile
methods
pick
choose
XP
practices
appropriate
way
working
Sometimes
incorporated
development
processes
commonly
used
conjunction
management
focused
agile
method
Scrum
Rubin
@@@@@@@@@@
Prescribing
medication
Kate
doctor
wishes
prescribe
medication
patient
attending
clinic
patient
record
already
displayed
computer
clicks
medication
field
select
current
medication
new
medication
formulary
selects
current
medication
system
asks
check
dose
wants
change
dose
enters
new
dose
confirms
prescription
chooses
new
medication
system
assumes
knows
medication
prescribe
types
first
letters
drug
name
system
displays
list
possible
drugs
starting
letters
chooses
required
medication
system
responds
asking
check
medication
selected
correct
enters
dose
confirms
prescription
chooses
formulary
system
displays
search
box
approved
formulary
search
drug
required
selects
drug
asked
check
medication
correct
enters
dose
confirms
prescription
system
checks
dose
approved
range
isn
t
Kate
asked
change
dose
Figure
prescribing
medication
story
Kate
confirmed
prescription
displayed
checking
clicks
Change
clicks
prescription
recorded
audit
database
clicks
Change
reenters
Prescribing
medication
process
convinced
XP
practical
agile
method
companies
significant
contribution
probably
set
agile
development
practices
introduced
community
discuss
important
practices
section
User
stories
Software
requirements
change
handle
changes
agile
methods
separate
requirements
engineering
activity
Rather
integrate
requirements
elicitation
development
make
easier
idea
user
stories
developed
user
story
scenario
use
experienced
system
user
far
possible
system
customer
works
closely
development
team
discusses
scenarios
team
members
Together
develop
story
card
briefly
describes
story
encapsulates
customer
needs
development
team
aims
implement
scenario
future
release
software
example
story
card
Mentcare
system
shown
Figure
short
description
scenario
prescribing
medication
patient
User
stories
used
planning
system
iterations
story
cards
developed
development
team
breaks
tasks
Figure
estimates
effort
resources
required
implementing
task
usually
involves
discussions
customer
refine
requirements
customer
prioritizes
stories
implementation
choosing
stories
@@@@@@@@@@
Chapter
Agile
software
development
Task
Change
dose
prescribed
drug
Task
Formulary
selection
Task
Dose
checking
Dose
checking
safety
precaution
check
doctor
prescribed
dangerously
small
large
dose
Using
formulary
id
generic
drug
name
look
formulary
retrieve
recommended
maximum
minimum
dose
Check
prescribed
dose
minimum
maximum
outside
range
issue
errorFigure
Examples
message
saying
dose
high
low
task
cards
prescribing
range
enable
Confirm
button
medication
used
immediately
deliver
useful
business
support
intention
identify
useful
functionality
implemented
two
weeks
next
release
system
made
available
customer
course
requirements
change
unimplemented
stories
change
discarded
changes
required
system
already
delivered
new
story
cards
developed
customer
decides
changes
priority
new
functionality
idea
user
stories
powerful
one
people
find
much
easier
relate
stories
conventional
requirements
document
use
cases
User
stories
helpful
getting
users
involved
suggesting
requirements
initial
predevelopment
requirements
elicitation
activity
discuss
detail
Chapter
principal
problem
user
stories
completeness
difficult
judge
enough
user
stories
developed
cover
essential
requirements
system
difficult
judge
single
story
gives
true
picture
activity
Experienced
users
often
familiar
work
leave
things
describing
Refactoring
fundamental
precept
traditional
software
engineering
design
change
anticipate
future
changes
software
design
changes
easily
implemented
Extreme
programming
however
discarded
principle
basis
designing
change
often
wasted
effort
isn
t
worth
taking
time
add
generality
program
cope
change
Often
changes
anticipated
never
materialize
completely
different
change
requests
made
course
practice
changes
made
code
developed
make
changes
easier
developers
XP
suggested
code
developed
constantly
refactored
Refactoring
Fowler
et
al
means
programming
team
look
possible
improvements
software
implements
@@@@@@@@@@
immediately
team
members
see
code
improved
make
improvements
even
situations
no
immediate
need
fundamental
problem
incremental
development
local
changes
tend
degrade
software
structure
Consequently
changes
software
harder
harder
implement
Essentially
development
proceeds
finding
workarounds
problems
result
code
often
duplicated
parts
software
reused
inappropriate
ways
overall
structure
degrades
code
added
system
Refactoring
improves
software
structure
readability
avoids
structural
deterioration
naturally
occurs
software
changed
Examples
refactoring
include
reorganization
class
hierarchy
remove
duplicate
code
tidying
renaming
attributes
methods
replacement
similar
code
sections
calls
methods
defined
program
library
Program
development
environments
usually
include
tools
refactoring
simplify
process
finding
dependencies
code
sections
making
global
code
modifications
principle
refactoring
part
development
process
software
easy
understand
change
new
requirements
proposed
practice
case
Sometimes
development
pressure
means
refactoring
delayed
time
devoted
implementation
new
functionality
new
features
changes
cannot
readily
accommodated
code
level
refactoring
require
architecture
system
modified
Test
first
development
discussed
introduction
chapter
one
important
differences
incremental
development
plan
driven
development
way
system
tested
incremental
development
no
system
specification
used
external
testing
team
develop
system
tests
consequence
approaches
incremental
development
informal
testing
process
comparison
plan
driven
testing
Extreme
Programming
developed
new
approach
program
testing
address
difficulties
testing
without
specification
Testing
automated
central
development
process
development
cannot
proceed
tests
successfully
executed
key
features
testing
XP
test
first
development
incremental
test
development
scenarios
user
involvement
test
development
validation
use
automated
testing
frameworks
XP
s
test
first
philosophy
now
evolved
general
test
driven
development
techniques
Jeffries
Melnik
believe
test
driven
development
one
important
innovations
software
engineering
Instead
writing
code
writing
tests
code
write
tests
write
code
@@@@@@@@@@
Chapter
Agile
software
development
Test
Dose
checking
Input
number
mg
representing
single
dose
drug
number
representing
number
single
doses
per
day
Tests
Test
inputs
single
dose
correct
frequency
high
Test
inputs
single
dose
high
low
Test
inputs
single
dose
frequency
high
low
Test
inputs
single
dose
frequency
permitted
range
Output
error
message
indicating
dose
outside
safe
range
Figure
Test
case
description
dose
checking
means
run
test
code
written
discover
problems
development
discuss
test
driven
development
depth
Chapter
Writing
tests
implicitly
defines
interface
specification
behavior
functionality
developed
Problems
requirements
interface
misunderstandings
reduced
Test
first
development
requires
clear
relationship
system
requirements
code
implementing
corresponding
requirements
XP
relationship
clear
story
cards
representing
requirements
broken
tasks
tasks
principal
unit
implementation
test
first
development
task
implementers
thoroughly
understand
specification
write
tests
system
means
ambiguities
omissions
specification
clarified
implementation
begins
Furthermore
avoids
problem
test
lag
happen
developer
system
works
faster
pace
tester
implementation
gets
ahead
testing
tendency
skip
tests
development
schedule
maintained
XP
s
test
first
approach
assumes
user
stories
developed
broken
set
task
cards
shown
Figure
task
generates
one
unit
tests
check
implementation
described
task
Figure
shortened
description
test
case
developed
check
prescribed
dose
drug
fall
outside
known
safe
limits
role
customer
testing
process
help
develop
acceptance
tests
stories
implemented
next
release
system
explain
Chapter
acceptance
testing
process
whereby
system
tested
using
customer
data
check
meets
customer
s
real
needs
Test
automation
essential
test
first
development
Tests
written
executable
components
task
implemented
testing
components
stand
alone
simulate
submission
input
tested
check
result
meets
output
specification
automated
test
framework
system
makes
easy
write
executable
tests
submit
set
tests
execution
Junit
Tahchiev
et
al
widely
used
example
automated
testing
framework
Java
programs
@@@@@@@@@@
testing
automated
set
tests
quickly
eas
ily
executed
functionality
added
system
tests
run
problems
new
code
introduced
caught
immediately
Test
first
development
automated
testing
usually
result
large
number
tests
written
executed
However
problems
ensuring
test
coverage
complete
Programmers
prefer
programming
testing
sometimes
take
shortcuts
writing
tests
example
write
incomplete
tests
check
possible
exceptions
occur
tests
difficult
write
incrementally
example
complex
user
interface
often
difficult
write
unit
tests
code
implements
display
logic
workflow
screens
difficult
judge
completeness
set
tests
lot
system
tests
test
set
provide
complete
coverage
Crucial
parts
system
executed
remain
untested
Therefore
large
set
frequently
executed
tests
give
impression
system
complete
correct
case
tests
reviewed
tests
written
development
undetected
bugs
delivered
system
release
Pair
programming
Another
innovative
practice
introduced
XP
programmers
work
pairs
develop
software
programming
pair
sits
computer
develop
software
However
pair
program
together
Rather
pairs
created
dynamically
team
members
work
development
process
Pair
programming
number
advantages
supports
idea
collective
ownership
responsibility
system
reflects
Weinberg
s
idea
egoless
programming
Weinberg
software
owned
team
whole
individuals
held
responsible
problems
code
Instead
team
collective
responsibility
resolving
problems
acts
informal
review
process
line
code
looked
least
two
people
Code
inspections
reviews
Chapter
effective
discovering
high
percentage
software
errors
However
time
consuming
organize
typically
introduce
delays
development
process
Pair
programming
less
formal
process
probably
doesn
t
find
many
errors
code
inspections
However
cheaper
easier
organize
formal
program
inspections
encourages
refactoring
improve
software
structure
problem
asking
programmers
refactor
normal
development
environment
effort
@@@@@@@@@@
Chapter
Agile
software
development
involved
expended
long
term
benefit
developer
spends
time
refactoring
judged
less
efficient
one
simply
carries
developing
code
pair
programming
collective
ownership
used
others
benefit
immediately
refactoring
likely
support
process
think
pair
programming
less
efficient
individual
programming
given
time
pair
developers
produce
half
much
code
two
individuals
working
alone
Many
companies
adopted
agile
methods
suspicious
pair
programming
use
companies
mix
pair
individual
programming
experienced
programmer
working
less
experienced
colleague
problems
Formal
studies
value
pair
programming
mixed
results
Using
student
volunteers
Williams
collaborators
Williams
et
al
found
productivity
pair
programming
seems
comparable
two
people
working
independently
reasons
suggested
pairs
discuss
software
development
probably
fewer
false
starts
less
rework
Furthermore
number
errors
avoided
informal
inspection
less
time
spent
repairing
bugs
discovered
testing
process
However
studies
experienced
programmers
replicate
results
Arisholm
et
al
found
significant
loss
productivity
compared
two
programmers
working
alone
quality
benefits
fully
compensate
pair
programming
overhead
Nevertheless
sharing
knowledge
happens
pair
programming
important
reduces
overall
risks
project
team
members
leave
make
pair
programming
worthwhile
Agile
project
management
software
business
managers
need
know
going
project
likely
meet
objectives
deliver
software
time
proposed
budget
Plan
driven
approaches
software
development
evolved
meet
need
discussed
Chapter
managers
draw
plan
project
showing
delivered
delivered
work
development
project
deliverables
plan
based
approach
requires
manager
stable
view
everything
developed
development
processes
informal
planning
project
control
proposed
early
adherents
agile
methods
clashed
business
requirement
visibility
Teams
self
organizing
produce
documentation
planned
development
short
cycles
work
small
companies
developing
software
products
inappropriate
larger
companies
need
know
going
organization
Like
every
professional
software
development
process
agile
development
managed
best
use
made
time
resources
available
@@@@@@@@@@
Agile
project
management
Scrum
term
Definition
Development
team
Potentially
shippable
product
increment
Product
backlog
Product
owner
Scrum
ScrumMaster
Sprint
development
iteration
Sprints
usually
weeks
long
Velocity
Figure
Scrum
terminology
self
organizing
group
software
developers
no
seven
people
responsible
developing
software
essential
project
documents
software
increment
delivered
sprint
idea
potentially
shippable
means
finished
state
no
work
testing
needed
incorporate
final
product
practice
achievable
list
items
Scrum
team
tackle
feature
definitions
software
software
requirements
user
stories
descriptions
supplementary
tasks
needed
architecture
definition
user
documentation
individual
possibly
small
group
job
identify
product
features
requirements
prioritize
development
continuously
review
product
backlog
ensure
project
continues
meet
critical
business
needs
Product
Owner
customer
product
manager
software
company
stakeholder
representative
daily
meeting
Scrum
team
reviews
progress
prioritizes
work
done
day
Ideally
short
face
face
meeting
includes
whole
team
ScrumMaster
responsible
ensuring
Scrum
process
followed
guides
team
effective
use
Scrum
responsible
interfacing
rest
company
ensuring
Scrum
team
diverted
outside
interference
Scrum
developers
adamant
ScrumMaster
thought
project
manager
Others
however
find
easy
see
difference
estimate
much
product
backlog
effort
team
cover
single
sprint
Understanding
team
s
velocity
helps
estimate
covered
sprint
provides
basis
measuring
improving
performance
team
address
issue
Scrum
agile
method
developed
Schwaber
Beedle
Rubin
provide
framework
organizing
agile
projects
extent
least
provide
external
visibility
going
devel
opers
Scrum
wished
make
clear
Scrum
method
project
man
agement
conventional
sense
deliberately
invented
new
terminology
ScrumMaster
replaced
names
project
manager
Figure
summarizes
Scrum
terminology
means
Scrum
agile
method
insofar
follows
principles
agile
mani
festo
showed
Figure
However
focuses
providing
framework
agile
project
organization
mandate
use
specific
development
@@@@@@@@@@
Chapter
Agile
software
development
Review
work
done
Select
items
Plan
sprint
Review
sprintSprint
Scrum
Product
backlog
Sprint
backlog
Potentially
shippable
softwareFigure
Scrum
sprint
cycle
practices
pair
programming
test
first
development
means
easily
integrated
existing
practice
company
Consequently
agile
methods
mainstream
approach
software
development
Scrum
emerged
widely
used
method
Scrum
process
sprint
cycle
shown
Figure
input
process
product
backlog
process
iteration
produces
product
increment
delivered
customers
starting
point
Scrum
sprint
cycle
product
backlog
list
items
product
features
requirements
engineering
improvement
worked
Scrum
team
initial
version
product
backlog
derived
requirements
document
list
user
stories
description
software
developed
majority
entries
product
backlog
concerned
implementation
system
features
activities
included
Sometimes
planning
iteration
questions
cannot
easily
answered
come
light
additional
work
required
explore
possible
solutions
team
carry
prototyping
trial
development
understand
problem
solution
backlog
items
design
system
architecture
develop
system
documentation
product
backlog
specified
varying
levels
detail
responsibility
Product
Owner
ensure
level
detail
specification
appropriate
work
done
example
backlog
item
complete
user
story
shown
Figure
simply
instruction
Refactor
user
interface
code
leaves
team
decide
refactoring
done
sprint
cycle
lasts
fixed
length
time
usually
weeks
beginning
cycle
Product
Owner
prioritizes
items
product
backlog
define
important
items
developed
cycle
Sprints
never
extended
take
account
unfinished
work
Items
returned
product
backlog
cannot
completed
allocated
time
sprint
whole
team
involved
selecting
highest
priority
items
believe
completed
estimate
time
required
complete
items
make
estimates
use
velocity
attained
previous
@@@@@@@@@@
Agile
project
management
sprints
much
backlog
covered
single
sprint
leads
creation
sprint
backlog
work
done
sprint
team
self
organizes
decide
work
sprint
begins
sprint
team
holds
short
daily
meetings
Scrums
review
progress
necessary
re
prioritize
work
Scrum
team
members
share
information
describe
progress
since
last
meeting
bring
problems
arisen
state
planned
following
day
Thus
everyone
team
knows
going
problems
arise
re
plan
short
term
work
cope
Everyone
participates
short
term
planning
no
top
direction
ScrumMaster
daily
interactions
among
Scrum
teams
coordinated
using
Scrum
board
office
whiteboard
includes
information
post
notes
Sprint
backlog
work
done
unavailability
staff
shared
resource
whole
team
anyone
change
move
items
board
means
team
member
glance
see
others
work
remains
done
end
sprint
review
meeting
involves
whole
team
meeting
two
purposes
First
means
process
improvement
team
reviews
way
worked
reflects
things
done
better
Second
provides
input
product
product
state
product
backlog
review
precedes
next
sprint
ScrumMaster
formally
project
manager
practice
ScrumMasters
take
role
many
organizations
conventional
management
structure
report
progress
senior
management
involved
longer
term
planning
project
budgeting
involved
project
administration
agreeing
holidays
staff
liaising
HR
etc
hardware
software
purchases
various
Scrum
success
stories
Schatz
Abdelshafi
Mulder
van
Vliet
Bellouiti
things
users
like
Scrum
method
product
broken
set
manageable
understandable
chunks
stakeholders
relate
Unstable
requirements
hold
progress
whole
team
visibility
everything
consequently
team
communication
morale
improved
Customers
see
time
delivery
increments
gain
feedback
product
works
faced
last
minute
surprises
team
announces
software
delivered
expected
Trust
customers
developers
established
positive
culture
created
everyone
expects
project
succeed
Scrum
originally
designed
intended
use
co
located
teams
team
members
get
together
every
day
stand
meetings
However
much
software
development
now
involves
distributed
teams
team
members
located
different
places
around
world
allows
companies
take
advantage
@@@@@@@@@@
Chapter
Agile
software
development
ScrumMaster
located
development
team
Product
Owner
aware
everyday
visit
Videoconferencing
problems
developers
try
product
establish
good
owner
relationship
development
team
essential
trust
Distributed
Scrum
Real
time
communica
common
development
tions
team
environment
teams
members
informal
communication
Continuous
integration
particularly
instant
team
messaging
video
members
aware
calls
Figure
Distributed
state
Scrum
product
time
lower
cost
staff
countries
makes
access
specialist
skills
possible
allows
hour
development
work
going
different
time
zones
Consequently
developments
Scrum
distributed
development
environments
multi
team
working
Typically
offshore
development
product
owner
different
country
development
team
distributed
Figure
shows
requirements
Distributed
Scrum
Deemer
Scaling
agile
methods
Agile
methods
developed
use
small
programming
teams
work
together
room
communicate
informally
originally
used
development
small
medium
sized
systems
software
products
Small
companies
without
formal
processes
bureaucracy
enthusiastic
initial
adopters
methods
course
need
faster
delivery
software
suited
customer
needs
applies
larger
systems
larger
companies
Consequently
past
years
lot
work
put
evolving
agile
methods
large
software
systems
use
large
companies
Scaling
agile
methods
closely
related
facets
Scaling
methods
handle
development
large
systems
big
developed
single
small
team
Scaling
methods
specialized
development
teams
widespread
use
large
company
many
years
software
development
experience
@@@@@@@@@@
Scaling
agile
methods
course
scaling
scaling
closely
related
Contracts
develop
large
software
systems
usually
awarded
large
organizations
multiple
teams
working
development
project
large
companies
often
experimented
agile
methods
smaller
projects
face
problems
scaling
scaling
time
many
anecdotes
effectiveness
agile
methods
suggested
lead
orders
magnitude
improvements
productivity
comparable
reductions
defects
Ambler
Ambler
influential
agile
method
developer
suggests
productivity
improvements
exaggerated
large
systems
organizations
suggests
organization
moving
agile
methods
expect
see
productivity
improvement
across
organization
years
similar
reductions
number
product
defects
Practical
problems
agile
methods
areas
particularly
development
software
products
apps
agile
development
incredibly
successful
far
best
approach
use
type
system
However
agile
methods
suitable
types
software
development
embedded
systems
engineering
development
large
complex
systems
large
long
lifetime
systems
developed
software
company
external
client
using
agile
approach
presents
number
problems
informality
agile
development
incompatible
legal
approach
contract
definition
commonly
used
large
companies
Agile
methods
appropriate
new
software
development
rather
software
maintenance
majority
software
costs
large
companies
come
maintaining
existing
software
systems
Agile
methods
designed
small
co
located
teams
much
software
development
now
involves
worldwide
distributed
teams
Contractual
issues
major
problem
agile
methods
used
system
customer
uses
outside
organization
system
development
contract
software
development
drawn
software
requirements
document
usually
part
contract
customer
supplier
interleaved
development
requirements
code
fundamental
agile
methods
no
definitive
statement
requirements
included
contract
Consequently
agile
methods
rely
contracts
customer
pays
time
required
system
development
rather
development
specific
set
requirements
long
goes
well
benefits
customer
developer
However
problems
arise
difficult
disputes
blame
pay
extra
time
resources
required
resolve
problems
@@@@@@@@@@
Chapter
Agile
software
development
explain
Chapter
huge
amount
software
engineering
effort
goes
maintenance
evolution
existing
software
systems
Agile
practices
incremental
delivery
design
change
maintaining
simplicity
make
sense
software
changed
fact
think
agile
development
process
process
supports
continual
change
agile
methods
used
software
product
development
new
releases
product
app
simply
involve
continuing
agile
approach
However
maintenance
involves
custom
system
changed
response
new
business
requirements
no
clear
consensus
suitability
agile
methods
software
maintenance
Bird
Kilner
Three
types
problems
arise
lack
product
documentation
keeping
customers
involved
development
team
continuity
Formal
documentation
supposed
describe
system
make
easier
people
changing
system
understand
practice
however
formal
documentation
rarely
updated
accurately
reflect
program
code
reason
agile
methods
enthusiasts
argue
waste
time
write
documentation
key
implementing
maintainable
software
produce
high
quality
readable
code
lack
documentation
problem
maintaining
systems
developed
using
agile
approach
However
experience
system
maintenance
important
document
system
requirements
document
tells
software
engineer
system
supposed
Without
knowledge
difficult
assess
impact
proposed
system
changes
Many
agile
methods
collect
requirements
informally
incrementally
create
coherent
requirements
document
use
agile
methods
therefore
make
subsequent
system
maintenance
difficult
expensive
particular
problem
development
team
continuity
cannot
maintained
key
challenge
using
agile
approach
maintenance
keeping
customers
involved
process
customer
able
justify
full
time
involvement
representative
system
development
less
likely
maintenance
changes
continuous
Customer
representatives
likely
lose
interest
system
Therefore
likely
alternative
mechanisms
change
proposals
discussed
Chapter
adapted
fit
agile
approach
Another
potential
problem
arise
maintaining
continuity
development
team
Agile
methods
rely
team
members
understanding
aspects
system
without
consult
documentation
agile
development
team
broken
implicit
knowledge
lost
difficult
new
team
members
build
understanding
system
components
Many
programmers
prefer
work
new
development
software
maintenance
unwilling
continue
work
software
system
first
release
delivered
Therefore
even
intention
keep
development
team
together
people
leave
assigned
maintenance
tasks
@@@@@@@@@@
Scaling
agile
methods
Principle
Practice
Customer
involvement
depends
customer
willing
able
spend
time
development
team
represent
system
stakeholders
Often
customer
representatives
demands
time
cannot
play
full
part
software
development
external
stakeholders
regulators
difficult
represent
views
agile
team
Embrace
change
Prioritizing
changes
extremely
difficult
especially
systems
many
stakeholders
Typically
stakeholder
gives
different
priorities
different
changes
Incremental
delivery
Rapid
iterations
short
term
planning
development
fit
longer
term
planning
cycles
business
planning
marketing
Marketing
managers
need
know
product
features
several
months
advance
prepare
effective
marketing
campaign
Maintain
simplicity
pressure
delivery
schedules
team
members
time
carry
desirable
system
simplifications
People
process
Individual
team
members
suitable
personalities
intense
involvement
typical
agile
methods
therefore
interact
well
team
members
Figure
Agile
principles
organizational
practice
Agile
plan
driven
methods
fundamental
requirement
scaling
agile
methods
integrate
plan
driven
approaches
Small
startup
companies
work
informal
short
term
planning
larger
companies
longer
term
plans
budgets
investment
staffing
business
development
software
development
support
plans
longer
term
software
planning
essential
Early
adopters
agile
methods
first
decade
st
century
enthusiasts
deeply
committed
agile
manifesto
deliberately
rejected
plan
driven
approach
software
engineering
reluctant
change
initial
vision
agile
methods
way
However
organizations
saw
value
benefits
agile
approach
adapted
methods
suit
culture
ways
working
principles
underlying
agile
methods
sometimes
difficult
realize
practice
Figure
address
problems
large
agile
software
development
projects
combine
practices
plan
driven
agile
approaches
mostly
agile
others
mostly
plan
driven
agile
practices
decide
balance
plan
based
agile
approach
answer
range
technical
human
organizational
questions
relate
system
developed
development
team
organizations
developing
procuring
system
Figure
Agile
methods
developed
refined
projects
develop
small
medium
sized
business
systems
software
products
software
developer
controls
specification
system
types
system
attributes
size
complexity
real
time
response
external
regulation
mean
pure
agile
approach
@@@@@@@@@@
Chapter
Agile
software
development
SystemTeamOrganizationScaleTechnologyDistributionContractsDeliveryRegulationTypeLifetimeCompetenceCultureFigure
Factors
influencing
choice
plan
based
agile
development
unlikely
work
needs
front
planning
design
documentation
systems
engineering
process
key
issues
follows
large
system
developed
Agile
methods
effective
system
developed
relatively
small
co
located
team
communicate
informally
possible
large
systems
require
larger
development
teams
plan
driven
approach
used
type
system
developed
Systems
require
lot
analysis
implementation
e
g
real
time
system
complex
timing
requirements
usually
need
fairly
detailed
design
carry
analysis
plan
driven
approach
best
circumstances
expected
system
lifetime
Long
lifetime
systems
require
design
documentation
communicate
original
intentions
system
developers
support
team
However
supporters
agile
methods
rightly
argue
documentation
frequently
kept
date
much
use
long
term
system
maintenance
system
subject
external
regulation
system
approved
external
regulator
e
g
Federal
Aviation
Administration
approves
software
critical
operation
aircraft
probably
required
produce
detailed
documentation
part
system
safety
case
Agile
methods
place
great
deal
responsibility
development
team
cooperate
communicate
development
system
rely
individual
engineering
skills
software
support
development
process
However
reality
everyone
highly
skilled
engineer
people
communicate
effectively
possible
teams
work
together
planning
required
make
effective
use
people
available
Key
issues
good
designers
programmers
development
team
sometimes
argued
agile
methods
require
higher
skill
levels
plan
based
approaches
programmers
simply
translate
detailed
design
code
team
relatively
low
skill
levels
need
use
best
people
develop
design
others
responsible
programming
@@@@@@@@@@
Scaling
agile
methods
development
team
organized
development
team
distributed
part
development
outsourced
need
develop
design
documents
communicate
across
development
teams
technologies
available
support
system
development
Agile
methods
often
rely
good
tools
keep
track
evolving
design
developing
system
using
IDE
good
tools
program
visualization
analysis
design
documentation
required
Television
films
created
popular
vision
software
companies
informal
organizations
run
young
men
mostly
provide
fashionable
working
environment
minimum
bureaucracy
organizational
procedures
far
truth
software
developed
large
companies
established
working
practices
procedures
Management
companies
uncomfortable
lack
documentation
informal
decision
making
agile
methods
Key
issues
important
detailed
specification
design
moving
implementation
perhaps
contractual
reasons
probably
need
use
plan
driven
approach
requirements
engineering
use
agile
development
practices
system
implementation
incremental
delivery
strategy
deliver
software
customers
system
stakeholders
get
rapid
feedback
realistic
customer
representatives
available
willing
participate
development
team
cultural
issues
affect
system
development
Traditional
engineering
organizations
culture
plan
based
development
norm
engineering
usually
requires
extensive
design
documentation
rather
informal
knowledge
used
agile
processes
reality
issue
project
labeled
plan
driven
agile
important
Ultimately
primary
concern
buyers
software
system
executable
software
system
meets
needs
useful
things
individual
user
organization
Software
developers
pragmatic
choose
methods
effective
type
system
developed
labeled
agile
plan
driven
Agile
methods
large
systems
Agile
methods
evolve
used
large
scale
software
development
fundamental
reason
large
scale
software
systems
much
complex
difficult
understand
manage
small
scale
systems
software
products
Six
principal
factors
Figure
contribute
complexity
@@@@@@@@@@
Chapter
Agile
software
development
Figure
Large
project
characteristics
Large
software
system
System
systems
Brownfield
development
Diverse
stakeholders
Prolonged
procurement
System
configuration
Regulatory
constraints
Large
systems
usually
systems
systems
collections
separate
communicating
systems
separate
teams
develop
system
Frequently
teams
working
different
places
sometimes
different
time
zones
practically
impossible
team
view
whole
system
Consequently
priorities
usually
complete
part
system
without
regard
wider
systems
issues
Large
systems
brownfield
systems
Hopkins
Jenkins
include
interact
number
existing
systems
Many
system
requirements
concerned
interaction
don
t
really
lend
flexibility
incremental
development
Political
issues
significant
often
easiest
solution
problem
change
existing
system
However
requires
negotiation
managers
system
convince
changes
implemented
without
risk
system
s
operation
several
systems
integrated
create
system
significant
fraction
development
concerned
system
configuration
rather
original
code
development
necessarily
compatible
incremental
development
frequent
system
integration
Large
systems
development
processes
often
constrained
external
rules
regulations
limiting
way
developed
require
certain
types
system
documentation
produced
Customers
specific
compliance
requirements
followed
require
process
documentation
completed
Large
systems
long
procurement
development
time
difficult
maintain
coherent
teams
know
system
period
inevitably
people
move
jobs
projects
Large
systems
usually
diverse
set
stakeholders
different
perspectives
objectives
example
nurses
administrators
end
users
medical
system
senior
medical
staff
hospital
managers
others
stakeholders
system
practically
impossible
involve
different
stakeholders
development
process
@@@@@@@@@@
Scaling
agile
methods
Core
agile
development
Disciplined
agile
delivery
Value
driven
life
cycle
Risk
value
driven
life
cycle
Self
organizing
teams
Self
organizing
appropriate
Agility
scale
Disciplined
agile
delivery
scaling
factors
apply
Large
team
size
Geographic
distribution
Regulatory
compliance
Domain
complexity
Organization
distribution
Technical
complexity
Organizational
complexity
Enterprise
discipline
Core
agile
development
Disciplined
agile
delivery
Agility
scale
governance
framework
Full
delivery
life
cycle
Focus
construction
Figure
IBM
s
Agility
Scale
model
IBM
Dean
Leffingwell
great
deal
experience
scaling
agile
methods
developed
Scaled
Agile
Framework
Leffingwell
support
large
scale
multi
team
software
development
reports
method
used
successfully
number
large
companies
IBM
developed
framework
large
scale
use
agile
methods
called
Agile
Scaling
Model
ASM
Figure
taken
Ambler
s
white
paper
discusses
ASM
Ambler
shows
overview
model
ASM
recognizes
scaling
staged
process
development
teams
move
core
agile
practices
discussed
called
Disciplined
Agile
Delivery
Essentially
stage
involves
adapting
practices
disciplined
organizational
setting
recognizing
teams
cannot
simply
focus
development
take
account
stages
software
engineering
process
requirements
architectural
design
final
scaling
stage
ASM
move
Agility
Scale
complexity
inherent
large
projects
recognized
involves
taking
account
factors
distributed
development
complex
legacy
environments
regulatory
compliance
requirements
practices
used
disciplined
agile
delivery
modified
project
project
basis
take
account
sometimes
additional
plan
based
practices
added
process
No
single
model
appropriate
large
scale
agile
products
type
product
customer
requirements
people
available
different
However
approaches
scaling
agile
methods
number
things
common
@@@@@@@@@@
Chapter
Agile
software
development
completely
incremental
approach
requirements
engineering
impossible
early
work
initial
software
requirements
essential
need
work
identify
different
parts
system
developed
different
teams
often
part
contract
system
development
However
requirements
normally
specified
detail
details
best
developed
incrementally
cannot
single
product
owner
customer
representative
Different
people
involved
different
parts
system
continuously
communicate
negotiate
throughout
development
process
possible
focus
code
system
need
front
design
system
documentation
software
architecture
designed
documentation
produced
describe
critical
aspects
system
database
schemas
work
breakdown
across
teams
Cross
team
communication
mechanisms
designed
used
involve
regular
phone
videoconferences
team
members
frequent
short
electronic
meetings
teams
update
progress
range
communication
channels
email
instant
messaging
wikis
social
networking
systems
provided
facilitate
communications
Continuous
integration
whole
system
built
every
time
developer
checks
change
practically
impossible
several
separate
programs
integrated
create
system
However
essential
maintain
frequent
system
builds
regular
releases
system
Configuration
management
tools
support
multi
team
software
development
essential
Scrum
adapted
large
scale
development
essence
Scrum
team
model
described
Section
maintained
multiple
Scrum
teams
set
key
characteristics
multi
team
Scrum
Role
replication
team
Product
Owner
work
component
ScrumMaster
chief
Product
Owner
ScrumMaster
entire
project
Product
architects
team
chooses
product
architect
architects
collaborate
design
evolve
overall
system
architecture
Release
alignment
dates
product
releases
team
aligned
demonstrable
complete
system
produced
Scrum
Scrums
daily
Scrum
Scrums
representatives
team
meet
discuss
progress
identify
problems
plan
work
done
day
Individual
team
Scrums
staggered
time
representatives
teams
attend
necessary
@@@@@@@@@@
Scaling
agile
methods
Agile
methods
across
organizations
Small
software
companies
develop
software
products
among
enthusiastic
adopters
agile
methods
companies
constrained
organizational
bureaucracies
process
standards
change
quickly
adopt
new
ideas
course
larger
companies
experimented
agile
methods
specific
projects
much
difficult
scale
methods
across
organization
difficult
introduce
agile
methods
large
companies
number
reasons
Project
managers
experience
agile
methods
reluctant
accept
risk
new
approach
know
affect
particular
projects
Large
organizations
often
quality
procedures
standards
projects
expected
follow
bureaucratic
nature
likely
incompatible
agile
methods
Sometimes
supported
software
tools
e
g
requirements
management
tools
use
tools
mandated
projects
Agile
methods
seem
work
best
team
members
relatively
high
skill
level
However
large
organizations
likely
wide
range
skills
abilities
people
lower
skill
levels
effective
team
members
agile
processes
cultural
resistance
agile
methods
especially
organizations
long
history
using
conventional
systems
engineering
processes
Change
management
testing
procedures
examples
company
procedures
compatible
agile
methods
Change
management
process
controlling
changes
system
impact
changes
predictable
costs
controlled
changes
approved
advance
made
conflicts
notion
refactoring
refactoring
part
agile
process
developer
improve
code
without
getting
external
approval
large
systems
testing
standards
system
build
handed
external
testing
team
conflict
test
first
approaches
used
agile
development
methods
Introducing
sustaining
use
agile
methods
across
large
organization
process
cultural
change
Cultural
change
takes
long
time
implement
often
requires
change
management
accomplished
Companies
wishing
use
agile
methods
need
evangelists
promote
change
Rather
trying
force
agile
methods
onto
unwilling
developers
companies
found
best
way
introduce
agile
bit
bit
starting
enthusiastic
group
developers
successful
agile
project
act
starting
point
project
team
spreading
agile
practice
across
organization
notion
agile
widely
known
explicit
actions
taken
spread
across
organization
@@@@@@@@@@
Chapter
Agile
software
development
Key
Points
Agile
methods
iterative
development
methods
focus
reducing
process
overheads
documentation
incremental
software
delivery
involve
customer
representatives
directly
development
process
decision
use
agile
plan
driven
approach
development
depend
type
software
developed
capabilities
development
team
culture
company
developing
system
practice
mix
agile
plan
based
techniques
used
Agile
development
practices
include
requirements
expressed
user
stories
pair
programming
refactoring
continuous
integration
test
first
development
Scrum
agile
method
provides
framework
organizing
agile
projects
centered
around
set
sprints
fixed
time
periods
system
increment
developed
Planning
based
prioritizing
backlog
work
selecting
highest
priority
tasks
sprint
scale
agile
methods
plan
based
practices
integrated
agile
practice
include
front
requirements
multiple
customer
representatives
documentation
common
tooling
across
project
teams
alignment
releases
across
teams
reAding
Get
Ready
Agile
Methods
Care
thoughtful
critique
agile
methods
discusses
strengths
weaknesses
written
vastly
experienced
software
engineer
Still
relevant
years
old
B
Boehm
IEEE
Computer
January
http
dx
doi
org
Extreme
Programming
Explained
first
book
XP
still
perhaps
readable
explains
approach
perspective
one
inventors
enthusiasm
comes
clearly
book
K
Beck
C
Andres
Addison
Wesley
Essential
Scrum
Practical
Guide
Popular
Agile
Process
comprehensive
readable
description
development
Scrum
method
K
S
Rubin
Addison
Wesley
Agility
Scale
Economic
Governance
Measured
Improvement
Disciplined
Delivery
paper
discusses
IBM
s
approach
scale
agile
methods
systematic
approach
integrating
plan
based
agile
development
excellent
thoughtful
discussion
key
issues
scaling
agile
W
Brown
S
W
Ambler
W
Royce
Proc
th
Int
Conf
Software
Engineering
http
dx
doi
org
WebSite
PowerPoint
slides
chapter
www
pearsonglobaleditions
com
Sommerville
Links
supporting
videos
http
software
engineering
book
com
videos
agile
methods
@@@@@@@@@@
Chapter
References
exerCiSeS
end
study
program
students
software
engineering
course
typically
expected
complete
major
project
Explain
agile
methodology
useful
students
use
case
Explain
principles
underlying
agile
methods
lead
accelerated
development
deployment
software
Extreme
programming
expresses
user
requirements
stories
story
written
card
Discuss
advantages
disadvantages
approach
requirements
description
test
first
development
tests
written
code
Explain
test
suite
compromise
quality
software
system
developed
Suggest
four
reasons
productivity
rate
programmers
working
pair
half
two
programmers
working
individually
Compare
contrast
Scrum
approach
project
management
conventional
plan
based
approaches
discussed
Chapter
comparison
based
effectiveness
approach
planning
allocation
people
projects
estimating
cost
projects
maintaining
team
cohesion
managing
changes
project
team
membership
reduce
costs
environmental
impact
commuting
company
decides
close
number
offices
provide
support
staff
work
home
However
senior
management
introduce
policy
unaware
software
developed
using
Scrum
Explain
use
technology
support
Scrum
distributed
environment
make
possible
problems
likely
encounter
using
approach
necessary
introduce
methods
documentation
plan
based
approaches
scaling
agile
methods
larger
projects
developed
distributed
development
teams
Explain
agile
methods
work
well
organizations
teams
wide
range
skills
abilities
well
established
processes
One
problems
user
closely
involved
software
development
team
go
native
adopt
outlook
development
team
lose
sight
needs
user
colleagues
Suggest
three
ways
avoid
problem
discuss
advantages
disadvantages
approach
reFerenCeS
Ambler
S
W
Scaling
Agile
Executive
Guide
http
www
ibm
com
developerworks
community
blogs
ambler
entry
scaling
agile
executive
guide
Arisholm
E
H
Gallis
T
Dyba
D
K
Sjoberg
Evaluating
Pair
Programming
Respect
System
Complexity
Programmer
Expertise
IEEE
Trans
Software
Eng
doi
TSE
Beck
K
Chrysler
Goes
Extremes
Distributed
Computing
@@@@@@@@@@
Chapter
Agile
software
development
Embracing
Change
Extreme
Programming
IEEE
Computer
doi
Bellouiti
S
Scrum
Helped
Team
http
www
scrumalliance
org
community
articles
june
scrum
helped
team
Bird
J
t
Agile
Maintenance
http
swreflections
blogspot
co
uk
cant
agile
maintenance
html
Deemer
P
Distributed
Scrum
Primer
http
www
goodagile
com
distributedscrumprimer
Fowler
M
K
Beck
J
Brant
W
Opdyke
D
Roberts
Refactoring
Improving
Design
Existing
Code
Boston
Addison
Wesley
Hopkins
R
K
Jenkins
Eating
Elephant
Moving
Greenfield
Development
Brownfield
Boston
IBM
Press
Jeffries
R
G
Melnik
TDD
Art
Fearless
Programming
IEEE
Software
doi
MS
Kilner
S
Agile
Methods
Work
Software
Maintenance
http
www
vlegaci
com
agile
methods
work
software
maintenance
part
Larman
C
V
R
Basili
Iterative
Incremental
Development
Brief
History
IEEE
Computer
doi
MC
Leffingwell
D
Scaling
Software
Agility
Best
Practices
Large
Enterprises
Boston
Addison
Wesley
Leffingwell
D
Agile
Software
Requirements
Lean
Requirements
Practices
Teams
Programs
Enterprise
Boston
Addison
Wesley
Mulder
M
M
van
Vliet
Case
Study
Distributed
Scrum
Project
Dutch
Railways
InfoQ
http
www
infoq
com
articles
dutch
railway
scrum
Rubin
K
S
Essential
Scrum
Boston
Addison
Wesley
Schatz
B
Abdelshafi
Primavera
Gets
Agile
Successful
Transition
Agile
Develop
ment
IEEE
Software
doi
MS
Schwaber
K
M
Beedle
Agile
Software
Development
Scrum
Englewood
Cliffs
NJ
Prentice
Hall
Stapleton
J
DSDM
Business
Focused
Development
nd
ed
Harlow
UK
Pearson
Education
Tahchiev
P
F
Leme
V
Massol
G
Gregory
JUnit
Action
e
Greenwich
CT
Manning
Publications
Weinberg
G
Psychology
Computer
Programming
New
York
Van
Nostrand
Williams
L
R
R
Kessler
W
Cunningham
R
Jeffries
Strengthening
Case
Pair
Programming
IEEE
Software
doi
@@@@@@@@@@
Requirements
engineering
Objectives
objective
chapter
introduce
software
requirements
explain
processes
involved
discovering
documenting
requirements
read
chapter
understand
concepts
user
system
requirements
requirements
written
different
ways
understand
differences
functional
non
functional
software
requirements
understand
main
requirements
engineering
activities
elicitation
analysis
validation
relationships
activities
understand
requirements
management
necessary
supports
requirements
engineering
activities
Contents
Functional
non
functional
requirements
Requirements
engineering
processes
Requirements
elicitation
Requirements
specification
Requirements
validation
Requirements
change
@@@@@@@@@@
Chapter
Requirements
engineering
requirements
system
descriptions
services
system
provide
constraints
operation
requirements
reflect
needs
customers
system
serves
certain
purpose
controlling
device
placing
order
finding
information
process
finding
analyzing
documenting
checking
services
constraints
called
requirements
engineering
RE
term
requirement
used
consistently
software
industry
cases
requirement
simply
high
level
abstract
statement
service
system
provide
constraint
system
extreme
detailed
formal
definition
system
function
Davis
Davis
explains
differences
exist
company
wishes
let
contract
large
software
development
project
define
needs
sufficiently
abstract
way
solution
predefined
requirements
written
several
contractors
bid
contract
offering
perhaps
different
ways
meeting
client
organization
s
needs
contract
awarded
contractor
write
system
definition
client
detail
client
understands
validate
software
documents
called
requirements
document
system
problems
arise
requirements
engineering
process
result
failing
make
clear
separation
different
levels
description
distinguish
using
term
user
requirements
mean
high
level
abstract
requirements
system
requirements
mean
detailed
description
system
User
requirements
system
requirements
defined
follows
User
requirements
statements
natural
language
plus
diagrams
services
system
expected
provide
system
users
constraints
operate
user
requirements
vary
broad
statements
system
features
required
detailed
precise
descriptions
system
functionality
System
requirements
detailed
descriptions
software
system
s
functions
services
operational
constraints
system
requirements
document
sometimes
called
functional
specification
define
exactly
implemented
part
contract
system
buyer
software
developers
Different
kinds
requirement
needed
communicate
information
system
different
types
reader
Figure
illustrates
distinction
user
system
requirements
example
mental
health
care
patient
information
system
Mentcare
shows
user
requirement
expanded
several
system
requirements
see
Figure
user
requirement
quite
Davis
M
Software
Requirements
Objects
Functions
States
Englewood
Cliffs
NJ
Prentice
Hall
@@@@@@@@@@
Chapter
Requirements
engineering
User
requirements
definition
Mentcare
system
shall
generate
monthly
management
reports
showing
cost
drugs
prescribed
clinic
month
Figure
User
system
requirements
Figure
Readers
different
types
requirements
specification
System
requirements
specification
last
working
day
month
summary
drugs
prescribed
cost
prescribing
clinics
shall
generated
system
shall
generate
report
printing
last
working
day
month
report
shall
created
clinic
shall
list
individual
drug
names
total
number
prescriptions
number
doses
prescribed
total
cost
prescribed
drugs
drugs
available
different
dose
units
e
g
mg
mg
etc
separate
reports
shall
created
dose
unit
Access
drug
cost
reports
shall
restricted
authorized
users
listed
management
access
control
list
general
system
requirements
provide
specific
information
services
functions
system
implemented
need
write
requirements
different
levels
detail
different
types
readers
use
different
ways
Figure
shows
types
readers
user
system
requirements
readers
user
requirements
usually
concerned
system
implemented
managers
interested
detailed
facilities
system
readers
system
requirements
need
know
precisely
system
concerned
support
business
processes
involved
system
implementation
different
types
document
readers
shown
Figure
examples
system
stakeholders
well
users
many
people
kind
interest
system
System
stakeholders
include
anyone
affected
system
way
anyone
legitimate
interest
Stakeholders
range
end
users
system
managers
external
stakeholders
regulators
System
requirements
User
requirements
Client
managers
System
end
users
Client
engineers
Contractor
managers
System
architects
System
end
users
Client
engineers
System
architects
Software
developers
@@@@@@@@@@
Chapter
Requirements
engineering
Feasibility
studies
feasibility
study
short
focused
study
take
place
early
RE
process
answer
three
key
questions
system
contribute
overall
objectives
organization
system
implemented
schedule
budget
using
current
technology
system
integrated
systems
used
answer
questions
no
probably
go
ahead
project
http
software
engineering
book
com
web
feasibility
study
certify
acceptability
system
example
system
stakeholders
Mentcare
system
include
Patients
information
recorded
system
relatives
patients
Doctors
responsible
assessing
treating
patients
Nurses
coordinate
consultations
doctors
administer
treatments
Medical
receptionists
manage
patients
appointments
staff
responsible
installing
maintaining
system
medical
ethics
manager
ensure
system
meets
current
ethical
guidelines
patient
care
Health
care
managers
obtain
management
information
system
Medical
records
staff
responsible
ensuring
system
information
maintained
preserved
record
keeping
procedures
properly
implemented
Requirements
engineering
usually
presented
first
stage
software
engineering
process
However
understanding
system
requirements
developed
decision
made
go
ahead
procurement
development
system
early
stage
RE
establishes
high
level
view
system
benefits
provide
considered
feasibility
study
tries
assess
system
technically
financially
feasible
results
study
help
management
decide
go
ahead
procurement
development
system
chapter
present
traditional
view
requirements
rather
requirements
agile
processes
discussed
Chapter
majority
large
systems
still
case
clearly
identifiable
requirements
engineering
phase
implementation
system
begins
outcome
requirements
document
part
system
development
contract
course
subsequent
changes
made
requirements
user
requirements
expanded
@@@@@@@@@@
Functional
non
functional
requirements
detailed
system
requirements
Sometimes
agile
approach
concurrently
eliciting
requirements
system
developed
used
add
detail
refine
user
requirements
Functional
non
functional
requirements
Software
system
requirements
often
classified
functional
non
functional
requirements
Functional
requirements
statements
services
system
provide
system
react
particular
inputs
system
behave
particular
situations
cases
functional
requirements
explicitly
state
system
Non
functional
requirements
constraints
services
functions
offered
system
include
timing
constraints
constraints
development
process
constraints
imposed
standards
Non
functional
requirements
often
apply
system
whole
rather
individual
system
features
services
reality
distinction
different
types
requirements
clearcut
simple
definitions
suggest
user
requirement
concerned
security
statement
limiting
access
authorized
users
appear
nonfunctional
requirement
However
developed
detail
requirement
generate
requirements
clearly
functional
need
include
user
authentication
facilities
system
shows
requirements
independent
one
requirement
often
generates
constrains
requirements
system
requirements
therefore
specify
services
features
system
required
specify
necessary
functionality
ensure
services
features
delivered
effectively
Functional
requirements
functional
requirements
system
describe
system
requirements
depend
type
software
developed
expected
users
software
general
approach
taken
organization
writing
requirements
expressed
user
requirements
functional
requirements
written
natural
language
system
users
managers
understand
Functional
system
requirements
expand
user
requirements
written
system
developers
describe
system
functions
inputs
outputs
exceptions
detail
Functional
system
requirements
vary
general
requirements
covering
system
specific
requirements
reflecting
local
ways
working
organization
s
existing
systems
example
examples
functional
@@@@@@@@@@
Chapter
Requirements
engineering
Domain
requirements
Domain
requirements
derived
application
domain
system
rather
specific
needs
system
users
new
functional
requirements
right
constrain
existing
functional
requirements
set
particular
computations
carried
problem
domain
requirements
software
engineers
understand
characteristics
domain
system
operates
means
engineers
know
domain
requirement
missed
conflicts
requirements
http
software
engineering
book
com
web
domain
requirements
requirements
Mentcare
system
used
maintain
information
patients
receiving
treatment
mental
health
problems
user
shall
able
search
appointments
lists
clinics
system
shall
generate
day
clinic
list
patients
expected
attend
appointments
day
staff
member
using
system
shall
uniquely
identified
eight
digit
employee
number
user
requirements
define
specific
functionality
included
system
requirements
show
functional
requirements
written
different
levels
detail
contrast
requirements
Functional
requirements
name
suggests
traditionally
focused
system
However
organization
decides
existing
off
shelf
system
software
product
meet
needs
little
point
developing
detailed
functional
specification
cases
focus
development
information
requirements
specify
information
needed
people
work
Information
requirements
specify
information
needed
delivered
organized
Therefore
information
requirement
Mentcare
system
specify
information
included
list
patients
expected
appointments
day
Imprecision
requirements
specification
lead
disputes
customers
software
developers
natural
system
developer
interpret
ambiguous
requirement
way
simplifies
implementation
Often
however
customer
wants
New
requirements
established
changes
made
system
course
delays
system
delivery
increases
costs
example
first
Mentcare
system
requirement
list
states
user
shall
able
search
appointments
lists
clinics
rationale
requirement
patients
mental
health
problems
sometimes
confused
appointment
one
clinic
go
different
clinic
appointment
recorded
attended
regardless
clinic
@@@@@@@@@@
Functional
non
functional
requirements
medical
staff
member
specifying
search
requirement
expect
search
mean
given
patient
name
system
looks
name
appointments
clinics
However
explicit
requirement
System
developers
interpret
requirement
easier
implement
search
function
require
user
choose
clinic
carry
search
patients
attended
clinic
involves
user
input
takes
longer
complete
search
Ideally
functional
requirements
specification
system
complete
consistent
Completeness
means
services
information
required
user
defined
Consistency
means
requirements
contradictory
practice
possible
achieve
requirements
consistency
completeness
small
software
systems
One
reason
easy
make
mistakes
omissions
writing
specifications
large
complex
systems
Another
reason
large
systems
many
stakeholders
different
backgrounds
expectations
Stakeholders
likely
different
often
inconsistent
needs
inconsistencies
obvious
requirements
originally
specified
inconsistent
requirements
discovered
deeper
analysis
system
development
Non
functional
requirements
Non
functional
requirements
name
suggests
requirements
directly
concerned
specific
services
delivered
system
users
non
functional
requirements
usually
specify
constrain
characteristics
system
whole
relate
emergent
system
properties
reliability
response
time
memory
use
Alternatively
define
constraints
system
implementation
capabilities
O
devices
data
representations
used
interfaces
systems
Non
functional
requirements
often
critical
individual
functional
requirements
System
users
usually
find
ways
work
around
system
function
doesn
t
really
meet
needs
However
failing
meet
non
functional
requirement
mean
whole
system
unusable
example
aircraft
system
meet
reliability
requirements
certified
safe
operation
embedded
control
system
fails
meet
performance
requirements
control
functions
operate
correctly
often
possible
identify
system
components
implement
specific
functional
requirements
e
g
formatting
components
implement
reporting
requirements
often
difficult
non
functional
requirements
implementation
requirements
spread
throughout
system
two
reasons
Non
functional
requirements
affect
overall
architecture
system
rather
individual
components
example
ensure
performance
requirements
met
embedded
system
organize
system
minimize
communications
components
@@@@@@@@@@
Chapter
Requirements
engineering
PerformancerequirementsSpacerequirementsUsabilityrequirementsEfficiencyrequirementsDependabilityrequirementsSecurityrequirementsRegulatoryrequirementsEthicalrequirementsLegislativerequirementsOperationalrequirementsDevelopmentrequirementsEnvironmentalrequirementsSafety
securityrequirementsAccountingrequirementsProductrequirementsOrganizationalrequirementsExternalrequirementsNon
functionalrequirements
Figure
Types
non
functional
individual
non
functional
requirement
security
requirement
requirements
generate
several
related
functional
requirements
define
new
system
services
required
non
functional
requirement
implemented
addition
generate
requirements
constrain
existing
requirements
example
limit
access
information
system
Nonfunctional
requirements
arise
user
needs
budget
constraints
organizational
policies
need
interoperability
software
hardware
systems
external
factors
safety
regulations
privacy
legislation
Figure
classification
non
functional
requirements
see
diagram
non
functional
requirements
come
required
characteristics
software
product
requirements
organization
developing
software
organizational
requirements
external
sources
Product
requirements
requirements
specify
constrain
runtime
behavior
software
Examples
include
performance
requirements
fast
system
execute
much
memory
requires
reliability
requirements
set
acceptable
failure
rate
security
requirements
usability
requirements
Organizational
requirements
requirements
broad
system
requirements
derived
policies
procedures
customer
s
developer
s
organizations
Examples
include
operational
process
requirements
define
system
used
development
process
requirements
specify
@@@@@@@@@@
Functional
non
functional
requirements
ProDuct
requirement
Mentcare
system
shall
available
clinics
normal
working
hours
Mon
Fri
Downtime
normal
working
hours
shall
exceed
seconds
one
day
organizational
requirement
Users
Mentcare
system
shall
identify
using
health
authority
identity
card
external
requirement
system
shall
implement
patient
privacy
provisions
set
HStan
priv
Figure
Examples
possible
non
functional
programming
language
development
environment
process
standards
requirements
used
environmental
requirements
specify
operating
environ
Mentcare
system
ment
system
External
requirements
broad
heading
covers
requirements
derived
factors
external
system
development
process
include
regulatory
requirements
set
done
system
approved
use
regulator
nuclear
safety
authority
legislative
requirements
followed
ensure
system
operates
law
ethical
requirements
ensure
system
acceptable
users
general
public
Figure
shows
examples
product
organizational
external
requirements
included
Mentcare
system
specification
product
requirement
availability
requirement
defines
system
available
allowed
downtime
day
says
nothing
functionality
Mentcare
system
clearly
identifies
constraint
considered
system
designers
organizational
requirement
specifies
users
authenticate
system
health
authority
operates
system
moving
standard
authentication
procedure
software
instead
users
login
name
swipe
identity
card
reader
identify
external
requirement
derived
need
system
conform
privacy
legislation
Privacy
obviously
important
issue
health
care
systems
requirement
specifies
system
developed
accordance
national
privacy
standard
common
problem
non
functional
requirements
stakeholders
propose
requirements
general
goals
ease
use
ability
system
recover
failure
rapid
user
response
Goals
set
good
intentions
cause
problems
system
developers
leave
scope
interpretation
subsequent
dispute
system
delivered
example
following
system
goal
typical
manager
express
usability
requirements
system
easy
use
medical
staff
organized
way
user
errors
minimized
@@@@@@@@@@
Chapter
Requirements
engineering
Property
measure
Speed
Processed
transactions
second
User
event
response
time
Screen
refresh
time
Size
Megabytes
Number
ROM
chips
Ease
use
Training
time
Number
help
frames
Reliability
Mean
time
failure
Probability
unavailability
Rate
failure
occurrence
Availability
Robustness
Time
restart
failure
Percentage
events
causing
failure
Probability
data
corruption
failure
Portability
Percentage
target
dependent
statements
Number
target
systems
Figure
Metrics
specifying
nonfunctional
requirements
rewritten
show
goal
expressed
testable
nonfunctional
requirement
impossible
objectively
verify
system
goal
following
description
least
include
software
instrumentation
count
errors
made
users
testing
system
Medical
staff
shall
able
use
system
functions
two
hours
training
training
average
number
errors
made
experienced
users
shall
exceed
two
per
hour
system
use
possible
write
non
functional
requirements
quantitatively
objectively
tested
Figure
shows
metrics
use
specify
non
functional
system
properties
measure
characteristics
system
tested
check
system
met
nonfunctional
requirements
practice
customers
system
often
find
difficult
translate
goals
measurable
requirements
goals
maintainability
no
simple
metrics
used
cases
even
quantitative
specification
possible
customers
able
relate
needs
specifications
don
t
understand
number
defining
reliability
example
means
terms
everyday
experience
computer
systems
Furthermore
cost
objectively
verifying
measurable
non
functional
requirements
high
customers
paying
system
think
costs
justified
Non
functional
requirements
often
conflict
interact
functional
non
functional
requirements
example
identification
requirement
Figure
requires
card
reader
installed
computer
connects
system
However
another
requirement
requests
mobile
access
system
doctors
nurses
tablets
smartphones
normally
@@@@@@@@@@
Requirements
engineering
processes
equipped
card
readers
circumstances
alternative
identification
method
supported
difficult
separate
functional
non
functional
requirements
requirements
document
non
functional
requirements
stated
separately
functional
requirements
relationships
hard
understand
However
ideally
highlight
requirements
clearly
related
emergent
system
properties
performance
reliability
putting
separate
section
requirements
document
distinguishing
way
system
requirements
Non
functional
requirements
reliability
safety
confidentiality
requirements
particularly
important
critical
systems
cover
dependability
requirements
Part
describes
ways
specifying
reliability
safety
security
requirements
Requirements
engineering
processes
discussed
Chapter
requirements
engineering
involves
three
key
activities
discovering
requirements
interacting
stakeholders
elicitation
analysis
converting
requirements
standard
form
specification
checking
requirements
define
system
customer
wants
validation
shown
sequential
processes
Figure
However
practice
requirements
engineering
iterative
process
activities
interleaved
Figure
shows
interleaving
activities
organized
iterative
process
around
spiral
output
RE
process
system
requirements
document
amount
time
effort
devoted
activity
iteration
depends
stage
overall
process
type
system
developed
budget
available
Early
process
effort
spent
understanding
high
level
business
non
functional
requirements
user
requirements
system
Later
process
outer
rings
spiral
effort
devoted
eliciting
understanding
non
functional
requirements
detailed
system
requirements
spiral
model
accommodates
approaches
development
requirements
developed
different
levels
detail
number
iterations
around
spiral
vary
spiral
exited
user
requirements
elicited
Agile
development
used
instead
prototyping
requirements
system
implementation
developed
together
virtually
systems
requirements
change
people
involved
develop
better
understanding
want
software
organization
buying
system
changes
modifications
made
system
s
hardware
software
organizational
environment
Changes
managed
understand
impact
requirements
cost
system
implications
making
change
discuss
process
requirements
management
Section
@@@@@@@@@@
Chapter
Requirements
engineering
Requirements
specification
Requirements
validation
Requirements
elicitation
System
requirements
specification
modeling
System
req
elicitation
User
requirements
specification
User
requirements
elicitation
Business
requirements
specification
Prototyping
Feasibility
study
Reviews
System
requirements
document
Start
Figure
spiral
view
requirements
engineering
process
Requirements
elicitation
aims
requirements
elicitation
process
understand
work
stakeholders
use
new
system
help
support
work
requirements
elicitation
software
engineers
work
stakeholders
find
application
domain
work
activities
services
system
features
stakeholders
want
required
performance
system
hardware
constraints
Eliciting
understanding
requirements
system
stakeholders
difficult
process
several
reasons
Stakeholders
often
don
t
know
want
computer
system
except
general
terms
find
difficult
articulate
want
system
make
unrealistic
demands
don
t
know
isn
t
feasible
@@@@@@@@@@
Requirements
elicitation
Requirementsclassification
andorganization
Requirementsprioritization
andnegotiation
Requirements
documentation
discovery
understanding
Requirements
Figure
requirements
elicitation
analysis
process
Stakeholders
system
naturally
express
requirements
terms
implicit
knowledge
work
Requirements
engineers
without
experience
customer
s
domain
understand
requirements
Different
stakeholders
diverse
requirements
express
requirements
different
ways
Requirements
engineers
discover
potential
sources
requirements
discover
commonalities
conflict
Political
factors
influence
requirements
system
Managers
demand
specific
system
requirements
allow
increase
influence
organization
economic
business
environment
analysis
takes
place
dynamic
inevitably
changes
analysis
process
importance
particular
requirements
change
New
requirements
emerge
new
stakeholders
originally
consulted
process
model
elicitation
analysis
process
shown
Figure
organization
version
instantiation
general
model
depending
local
factors
expertise
staff
type
system
developed
standards
used
process
activities
Requirements
discovery
understanding
process
interacting
stakeholders
system
discover
requirements
Domain
requirements
stakeholders
documentation
discovered
activity
Requirements
classification
organization
activity
takes
unstructured
collection
requirements
groups
related
requirements
organizes
coherent
clusters
Requirements
prioritization
negotiation
Inevitably
multiple
stakeholders
involved
requirements
conflict
activity
concerned
prioritizing
requirements
finding
resolving
requirements
conflicts
@@@@@@@@@@
Chapter
Requirements
engineering
Viewpoints
viewpoint
way
collecting
organizing
set
requirements
group
stakeholders
something
common
viewpoint
therefore
includes
set
system
requirements
Viewpoints
come
end
users
managers
others
help
identify
people
provide
information
requirements
structure
requirements
analysis
http
www
software
engineering
book
com
web
viewpoints
negotiation
Usually
stakeholders
meet
resolve
differences
agree
compromise
requirements
Requirements
documentation
requirements
documented
input
next
round
spiral
early
draft
software
requirements
documents
produced
stage
requirements
simply
maintained
informally
whiteboards
wikis
shared
spaces
Figure
shows
requirements
elicitation
analysis
iterative
process
continual
feedback
activity
activities
process
cycle
starts
requirements
discovery
ends
requirements
documentation
analyst
s
understanding
requirements
improves
round
cycle
cycle
ends
requirements
document
produced
simplify
analysis
requirements
helpful
organize
group
stakeholder
information
One
way
consider
stakeholder
group
viewpoint
collect
requirements
group
viewpoint
include
viewpoints
represent
domain
requirements
constraints
systems
Alternatively
use
model
system
architecture
identify
subsystems
associate
requirements
subsystem
Inevitably
different
stakeholders
different
views
importance
priority
requirements
sometimes
views
conflicting
stakeholders
feel
views
properly
considered
deliberately
attempt
undermine
RE
process
Therefore
important
organize
regular
stakeholder
meetings
Stakeholders
opportunity
express
concerns
agree
requirements
compromises
requirements
documentation
stage
important
use
simple
language
diagrams
describe
requirements
makes
possible
stakeholders
understand
comment
requirements
make
information
sharing
easier
best
use
shared
document
e
g
Google
Docs
Office
wiki
accessible
interested
stakeholders
Requirements
elicitation
techniques
Requirements
elicitation
involves
meeting
stakeholders
different
kinds
discover
information
proposed
system
supplement
information
@@@@@@@@@@
Requirements
elicitation
knowledge
existing
systems
usage
information
documents
various
kinds
need
spend
time
understanding
people
work
produce
use
systems
need
change
accommodate
new
system
two
fundamental
approaches
requirements
elicitation
Interviewing
talk
people
Observation
ethnography
watch
people
job
see
artifacts
use
use
use
mix
interviewing
observation
collect
information
derive
requirements
basis
discussions
Interviewing
Formal
informal
interviews
system
stakeholders
part
requirements
engineering
processes
interviews
requirements
engineering
team
puts
questions
stakeholders
system
currently
use
system
developed
Requirements
derived
answers
questions
Interviews
two
types
Closed
interviews
stakeholder
answers
predefined
set
questions
Open
interviews
no
predefined
agenda
requirements
engineering
team
explores
range
issues
system
stakeholders
develops
better
understanding
needs
practice
interviews
stakeholders
normally
mixture
obtain
answer
certain
questions
usually
lead
issues
discussed
less
structured
way
Completely
open
ended
discussions
rarely
work
well
usually
ask
questions
get
started
keep
interview
focused
system
developed
Interviews
good
getting
overall
understanding
stakeholders
interact
new
system
difficulties
face
current
systems
People
like
talking
work
usually
happy
get
involved
interviews
However
unless
system
prototype
demonstrate
expect
stakeholders
suggest
specific
detailed
requirements
Everyone
finds
difficult
visualize
system
like
need
analyze
information
collected
generate
requirements
Eliciting
domain
knowledge
interviews
difficult
two
reasons
application
specialists
use
jargon
specific
area
work
impossible
discuss
domain
requirements
without
using
terminology
normally
use
words
precise
subtle
way
requirements
engineers
misunderstand
@@@@@@@@@@
Chapter
Requirements
engineering
domain
knowledge
familiar
stakeholders
find
difficult
explain
think
fundamental
isn
t
worth
mentioning
example
librarian
goes
without
saying
acquisitions
catalogued
added
library
However
obvious
interviewer
isn
t
taken
account
requirements
Interviews
effective
technique
eliciting
knowledge
organizational
requirements
constraints
subtle
power
relationships
different
people
organization
Published
organizational
structures
rarely
match
reality
decision
making
organization
interviewees
wish
reveal
actual
rather
theoretical
structure
stranger
general
people
generally
reluctant
discuss
political
organizational
issues
affect
requirements
effective
interviewer
bear
two
things
mind
open
minded
avoid
preconceived
ideas
requirements
willing
listen
stakeholders
stakeholder
comes
surprising
requirements
willing
change
mind
system
prompt
interviewee
get
discussions
going
using
springboard
question
requirements
proposal
working
together
prototype
system
Saying
people
tell
want
unlikely
result
useful
information
find
much
easier
talk
defined
context
rather
general
terms
Information
interviews
used
along
information
system
documentation
describing
business
processes
existing
systems
user
observations
developer
experience
Sometimes
apart
information
system
documents
interview
information
source
information
system
requirements
However
interviewing
liable
miss
essential
information
used
conjunction
requirements
elicitation
techniques
Ethnography
Software
systems
exist
isolation
used
social
organizational
environment
software
system
requirements
generated
constrained
environment
One
reason
many
software
systems
delivered
never
used
requirements
take
proper
account
social
organizational
factors
affect
practical
operation
system
therefore
important
requirements
engineering
process
try
understand
social
organizational
issues
affect
use
system
Ethnography
observational
technique
used
understand
operational
processes
help
derive
requirements
software
support
processes
analyst
immerses
working
environment
@@@@@@@@@@
Requirements
elicitation
system
used
day
day
work
observed
notes
made
actual
tasks
participants
involved
value
ethnography
helps
discover
implicit
system
requirements
reflect
actual
ways
people
work
rather
formal
processes
defined
organization
People
often
find
difficult
articulate
details
work
second
nature
understand
work
understand
relationship
work
organization
Social
organizational
factors
affect
work
obvious
individuals
clear
noticed
unbiased
observer
example
workgroup
self
organize
members
know
s
work
cover
someone
absent
mentioned
interview
group
see
integral
part
work
Suchman
Suchman
pioneered
use
ethnography
study
office
work
found
actual
work
practices
far
richer
complex
dynamic
simple
models
assumed
office
automation
systems
difference
assumed
actual
work
important
reason
office
systems
no
significant
effect
productivity
Crabtree
Crabtree
discusses
wide
range
studies
since
describes
general
use
ethnography
systems
design
research
investigated
methods
integrating
ethnography
software
engineering
process
linking
requirements
engineering
methods
Viller
Sommerville
documenting
patterns
interaction
cooperative
systems
Martin
Sommerville
Ethnography
particularly
effective
discovering
two
types
requirements
Requirements
derived
way
people
work
rather
way
business
process
definitions
say
work
practice
people
never
follow
formal
processes
example
air
traffic
controllers
switch
off
conflict
alert
system
detects
aircraft
intersecting
flight
paths
even
though
normal
control
procedures
specify
used
conflict
alert
system
sensitive
issues
audible
warnings
even
planes
far
apart
Controllers
find
distracting
prefer
use
strategies
ensure
planes
conflicting
flight
paths
Requirements
derived
cooperation
awareness
people
s
activities
example
air
traffic
controllers
ATCs
use
awareness
controlles
work
predict
number
aircraft
entering
control
sector
modify
control
strategies
depending
predicted
workload
Therefore
automated
ATC
system
allow
controllers
sector
visibility
work
adjacent
sectors
Ethnography
combined
development
system
prototype
Figure
ethnography
informs
development
prototype
fewer
prototype
refinement
cycles
required
Furthermore
prototyping
focuses
ethnography
identifying
problems
questions
discussed
ethnographer
look
answers
questions
next
phase
system
study
Sommerville
et
al
@@@@@@@@@@
Chapter
Requirements
engineering
Ethnographic
analysis
Debriefing
meetings
Focused
ethnography
Prototype
evaluation
Generic
system
development
System
protoyping
Figure
Ethnography
prototyping
requirements
analysis
Ethnography
helpful
understand
existing
systems
understanding
help
innovation
Innovation
particularly
relevant
new
product
development
Commentators
suggested
Nokia
used
ethnography
discover
people
used
phones
developed
new
phone
models
basis
Apple
hand
ignored
current
use
revolutionized
mobile
phone
industry
introduction
iPhone
Ethnographic
studies
reveal
critical
process
details
often
missed
requirements
elicitation
techniques
However
focus
end
user
approach
effective
discovering
broader
organizational
domain
requirements
suggestion
innovations
therefore
use
ethnography
one
number
techniques
requirements
elicitation
Stories
scenarios
People
find
easier
relate
real
life
examples
abstract
descriptions
good
telling
system
requirements
However
able
describe
handle
particular
situations
imagine
things
new
way
working
Stories
scenarios
ways
capturing
kind
information
use
interviewing
groups
stakeholders
discuss
system
stakeholders
develop
specific
system
requirements
Stories
scenarios
essentially
thing
description
system
used
particular
task
describe
people
information
use
produce
systems
use
process
difference
ways
descriptions
structured
level
detail
presented
Stories
written
narrative
text
present
high
level
description
system
use
scenarios
usually
structured
specific
information
collected
inputs
outputs
find
stories
effective
setting
big
picture
Parts
stories
developed
detail
represented
scenarios
Figure
example
story
developed
understand
requirements
iLearn
digital
learning
environment
introduced
Chapter
story
describes
situation
primary
elementary
school
teacher
using
environment
support
student
projects
fishing
industry
see
high
level
description
purpose
facilitate
discussion
iLearn
system
used
act
starting
point
eliciting
requirements
system
@@@@@@@@@@
Requirements
elicitation
Photo
sharing
classroom
Jack
primary
school
teacher
Ullapool
village
northern
Scotland
decided
class
project
focused
fishing
industry
area
looking
history
development
economic
impact
fishing
part
project
pupils
asked
gather
share
reminiscences
relatives
use
newspaper
archives
collect
old
photographs
related
fishing
fishing
communities
area
Pupils
use
iLearn
wiki
gather
together
fishing
stories
SCRAN
history
resources
site
access
newspaper
archives
photographs
However
Jack
needs
photo
sharing
site
wants
pupils
take
comment
s
photos
upload
scans
old
photographs
families
Jack
sends
email
primary
school
teachers
group
member
see
anyone
rec
ommend
appropriate
system
Two
teachers
reply
suggest
use
KidsTakePics
photo
sharing
site
allows
teachers
check
moderate
content
KidsTakePics
integrated
iLearn
authentication
service
sets
teacher
class
account
uses
iLearn
setup
service
add
KidsTakePics
services
seen
pupils
class
log
immediately
use
system
upload
photos
mobile
devices
class
computers
Figure
user
story
iLearn
system
advantage
stories
everyone
easily
relate
found
approach
particularly
useful
get
information
wider
community
realistically
interview
made
stories
available
wiki
invited
teachers
students
across
country
comment
high
level
stories
go
detail
system
developed
specific
scenarios
Scenarios
descriptions
example
user
interaction
sessions
think
best
present
scenarios
structured
way
rather
narrative
text
User
stories
used
agile
methods
Extreme
Programming
narrative
scenarios
rather
general
stories
help
elicit
requirements
scenario
starts
outline
interaction
elicitation
process
details
added
create
complete
description
interaction
general
scenario
include
description
system
users
expect
scenario
starts
description
normal
flow
events
scenario
description
go
wrong
resulting
problems
handled
Information
activities
going
time
description
system
state
scenario
ends
example
scenario
Figure
describes
happens
student
uploads
photos
KidsTakePics
system
explained
Figure
key
difference
system
systems
teacher
moderates
uploaded
photos
check
suitable
sharing
see
much
detailed
description
story
Figure
used
propose
requirements
iLearn
system
Like
stories
scenarios
used
facilitate
discussions
stakeholders
sometimes
different
ways
achieving
result
@@@@@@@@@@
Chapter
Requirements
engineering
uploading
photos
KidstakePics
initial
assumption
user
group
users
one
digital
photographs
uploaded
picture
sharing
site
photos
saved
tablet
laptop
computer
successfully
logged
KidsTakePics
normal
user
chooses
upload
photos
prompted
select
photos
uploaded
computer
select
project
name
photos
stored
Users
given
option
inputting
keywords
associated
uploaded
photo
Uploaded
photos
named
creating
conjunction
user
name
filename
photo
local
computer
completion
upload
system
automatically
sends
email
project
moderator
asking
check
new
content
generates
screen
message
user
checking
done
go
wrong
No
moderator
associated
selected
project
email
automatically
generated
school
administrator
asking
nominate
project
moderator
Users
informed
possible
delay
making
photos
visible
Photos
name
already
uploaded
user
user
asked
wishes
re
upload
photos
name
rename
photos
cancel
upload
users
choose
re
upload
photos
originals
overwritten
choose
rename
photos
new
name
automatically
generated
adding
number
existing
filename
activities
moderator
logged
system
approve
photos
uploaded
System
state
completion
User
logged
selected
photos
uploaded
assigned
status
awaiting
moderation
Photos
visible
moderator
user
uploaded
Figure
Scenario
uploading
photos
KidsTakePics
Requirements
specification
Requirements
specification
process
writing
user
system
requirements
requirements
document
Ideally
user
system
requirements
clear
unambiguous
easy
understand
complete
consistent
practice
impossible
achieve
Stakeholders
interpret
requirements
different
ways
often
inherent
conflicts
inconsistencies
requirements
User
requirements
written
natural
language
supplemented
appropriate
diagrams
tables
requirements
document
System
requirements
written
natural
language
notations
based
forms
graphical
mathematical
system
models
used
Figure
summarizes
possible
notations
writing
system
requirements
user
requirements
system
describe
functional
nonfunctional
requirements
understandable
system
users
don
t
detailed
technical
knowledge
Ideally
specify
external
behavior
system
requirements
document
include
details
system
architecture
design
Consequently
writing
user
requirements
use
software
jargon
structured
notations
formal
notations
write
user
requirements
natural
language
simple
tables
forms
intuitive
diagrams
@@@@@@@@@@
Requirements
specification
notation
Description
Figure
Notations
writing
system
requirements
Structured
natural
language
Graphical
notations
Mathematical
specifications
Natural
language
sentences
requirements
written
using
numbered
sentences
natural
language
sentence
express
one
requirement
requirements
written
natural
language
standard
form
template
field
provides
information
aspect
requirement
Graphical
models
supplemented
text
annotations
used
define
functional
requirements
system
UML
unified
modeling
language
use
case
sequence
diagrams
commonly
used
notations
based
mathematical
concepts
finite
state
machines
sets
unambiguous
specifications
reduce
ambiguity
requirements
document
customers
don
t
understand
formal
specification
cannot
check
represents
want
reluctant
accept
system
contract
discuss
approach
Chapter
covers
system
dependability
System
requirements
expanded
versions
user
requirements
software
engineers
use
starting
point
system
design
add
detail
explain
system
provide
user
requirements
used
part
contract
implementation
system
therefore
complete
detailed
specification
whole
system
Ideally
system
requirements
describe
external
behavior
system
operational
constraints
concerned
system
designed
implemented
However
level
detail
required
completely
specify
complex
software
system
possible
desirable
exclude
design
information
several
reasons
design
initial
architecture
system
help
structure
requirements
specification
system
requirements
organized
according
different
subsystems
make
system
defining
requirements
iLearn
system
proposed
architecture
shown
Figure
cases
systems
interoperate
existing
systems
constrain
design
impose
requirements
new
system
use
specific
architecture
satisfy
non
functional
requirements
N
version
programming
achieve
reliability
discussed
Chapter
necessary
external
regulator
needs
certify
system
safe
specify
architectural
design
already
certified
used
Natural
language
specification
Natural
language
used
write
requirements
software
since
s
expressive
intuitive
universal
potentially
vague
ambiguous
interpretation
depends
background
reader
result
@@@@@@@@@@
Chapter
Requirements
engineering
system
shall
measure
blood
sugar
deliver
insulin
required
every
minutes
Changes
blood
sugar
relatively
slow
frequent
measurement
unnecessary
less
frequent
measurement
lead
unnecessarily
high
sugar
levels
system
shall
run
self
test
routine
every
minute
conditions
tested
associated
actions
defined
Table
self
test
routine
discover
hardware
software
problems
alert
user
fact
normal
operation
impossible
Figure
Example
many
proposals
alternative
ways
write
requirements
However
requirements
none
proposals
widely
adopted
natural
language
continue
insulin
pump
software
system
widely
used
way
specifying
system
software
requirements
minimize
misunderstandings
writing
natural
language
requirements
recommend
follow
simple
guidelines
Invent
standard
format
ensure
requirement
definitions
adhere
format
Standardizing
format
makes
omissions
less
likely
requirements
easier
check
suggest
possible
write
requirement
one
two
sentences
natural
language
Use
language
consistently
distinguish
mandatory
desirable
requirements
Mandatory
requirements
requirements
system
support
usually
written
using
shall
Desirable
requirements
essential
written
using
Use
text
highlighting
bold
italic
color
pick
key
parts
requirement
assume
readers
understand
technical
software
engineering
language
easy
words
architecture
module
misunderstood
possible
avoid
use
jargon
abbreviations
acronyms
possible
try
associate
rationale
user
requirement
rationale
explain
requirement
included
proposed
requirement
requirement
source
know
consult
requirement
changed
Requirements
rationale
particularly
useful
requirements
changed
help
decide
changes
undesirable
Figure
illustrates
guidelines
used
includes
two
requirements
embedded
software
automated
insulin
pump
introduced
Chapter
requirements
embedded
system
defined
insulin
pump
requirements
document
downloaded
book
s
web
pages
Structured
specifications
Structured
natural
language
way
writing
system
requirements
requirements
written
standard
way
rather
free
form
text
approach
maintains
expressiveness
understandability
natural
language
@@@@@@@@@@
Requirements
specification
Problems
using
natural
language
requirements
specification
flexibility
natural
language
useful
specification
often
causes
problems
scope
writing
unclear
requirements
readers
designers
misinterpret
requirements
different
background
user
easy
amalgamate
several
requirements
single
sentence
structuring
natural
language
requirements
difficult
http
software
engineering
book
com
web
natural
language
ensures
uniformity
imposed
specification
Structured
language
notations
use
templates
specify
system
requirements
specification
use
programming
language
constructs
show
alternatives
iteration
highlight
key
elements
using
shading
different
fonts
Robertsons
Robertson
Robertson
book
VOLERE
requirements
engineering
method
recommend
user
requirements
initially
written
cards
one
requirement
per
card
suggest
number
fields
card
requirements
rationale
dependencies
requirements
source
requirements
supporting
materials
similar
approach
used
example
structured
specification
shown
Figure
use
structured
approach
specifying
system
requirements
define
one
standard
templates
requirements
represent
templates
structured
forms
specification
structured
around
objects
manipulated
system
functions
performed
system
events
processed
system
example
form
based
specification
case
one
defines
calculate
dose
insulin
delivered
blood
sugar
safe
band
shown
Figure
standard
format
used
specifying
functional
requirements
following
information
included
description
function
entity
specified
description
inputs
origin
inputs
description
outputs
destination
outputs
Information
information
needed
computation
entities
system
required
requires
part
description
action
taken
functional
approach
used
precondition
setting
true
function
called
postcondition
specifying
true
function
called
description
side
effects
operation
Using
structured
specifications
removes
problems
natural
language
specification
Variability
specification
reduced
requirements
organized
@@@@@@@@@@
Chapter
Requirements
engineering
Insulin
Pump
Control
Software
SRS
Function
Compute
insulin
dose
Safe
sugar
level
Description
Computes
dose
insulin
delivered
current
measured
sugar
level
safe
zone
units
inputs
Current
sugar
reading
r
previous
two
readings
r
r
Source
Current
sugar
reading
sensor
readings
memory
outputs
CompDose
dose
insulin
delivered
Destination
Main
control
loop
action
CompDose
zero
sugar
level
stable
falling
level
increasing
rate
increase
decreasing
level
increasing
rate
increase
increasing
CompDose
computed
dividing
difference
current
sugar
level
previous
level
rounding
result
result
rounded
zero
CompDose
set
minimum
dose
delivered
see
Figure
requires
Two
previous
readings
rate
change
sugar
level
computed
Precondition
insulin
reservoir
contains
least
maximum
allowed
single
dose
insulin
Postcondition
r
replaced
r
r
replaced
r
Side
effects
None
Figure
structured
specification
requirement
insulin
pump
Figure
tabular
specification
computation
insulin
pump
effectively
However
still
sometimes
difficult
write
requirements
clear
unambiguous
way
particularly
complex
computations
e
g
calculate
insulin
dose
specified
address
problem
add
extra
information
natural
language
requirements
example
using
tables
graphical
models
system
show
computations
proceed
system
state
changes
users
interact
system
sequences
actions
performed
Tables
particularly
useful
number
possible
alternative
situations
need
describe
actions
taken
insulin
pump
bases
computations
insulin
requirement
rate
change
blood
sugar
levels
rates
change
computed
using
current
previous
readings
Figure
tabular
description
rate
change
blood
sugar
used
calculate
amount
insulin
delivered
condition
action
Sugar
level
falling
r
r
CompDose
Sugar
level
stable
r
r
CompDose
Sugar
level
increasing
rate
increase
decreasing
r
r
r
r
CompDose
Sugar
level
increasing
rate
increase
stable
increasing
r
r
r
r
r
r
CompDose
round
r
r
rounded
result
CompDose
MinimumDose
@@@@@@@@@@
Requirements
specification
Nurse
Medical
receptionist
Manager
Register
patient
View
personal
info
View
record
Generate
report
Export
statistics
Doctor
Edit
record
Setup
consultationFigure
Use
cases
Mentcare
system
Use
cases
Use
cases
way
describing
interactions
users
system
using
graphical
model
structured
text
first
introduced
Objectory
method
Jacobsen
et
al
now
fundamental
feature
Unified
Modeling
Language
UML
simplest
form
use
case
identifies
actors
involved
interaction
names
type
interaction
add
additional
information
describing
interaction
system
additional
information
textual
description
one
graphical
models
UML
sequence
state
charts
see
Chapter
Use
cases
documented
using
high
level
use
case
diagram
set
use
cases
represents
possible
interactions
described
system
requirements
Actors
process
human
systems
represented
stick
figures
class
interaction
represented
named
ellipse
Lines
link
actors
interaction
Optionally
arrowheads
added
lines
show
interaction
initiated
illustrated
Figure
shows
use
cases
Mentcare
system
Use
cases
identify
individual
interactions
system
users
systems
use
case
documented
textual
description
linked
models
UML
develop
scenario
detail
example
brief
description
Setup
Consultation
use
case
Figure
Setup
consultation
allows
two
doctors
working
different
offices
view
patient
record
time
One
doctor
initiates
consultation
choosing
people
involved
dropdown
menu
doctors
online
patient
record
displayed
screens
initiating
doctor
edit
record
addition
text
chat
window
created
@@@@@@@@@@
Chapter
Requirements
engineering
help
coordinate
actions
assumed
phone
call
voice
communi
cation
separately
arranged
UML
standard
object
oriented
modeling
use
cases
use
case
based
elicitation
used
requirements
engineering
process
However
experience
use
cases
fine
grained
useful
discussing
requirements
Stakeholders
don
t
understand
term
use
case
don
t
find
graphical
model
useful
often
interested
detailed
description
every
system
interaction
Consequently
find
use
cases
helpful
systems
design
requirements
engineering
discuss
use
cases
Chapter
shows
used
alongside
system
models
document
system
design
people
think
use
case
single
low
level
interaction
scenario
Others
Stevens
Pooley
Stevens
Pooley
suggest
use
case
includes
set
related
low
level
scenarios
scenarios
single
thread
use
case
Therefore
scenario
normal
interaction
plus
scenarios
possible
exception
practice
use
way
software
requirements
document
software
requirements
document
sometimes
called
software
requirements
specification
SRS
official
statement
system
developers
implement
include
user
requirements
system
detailed
specification
system
requirements
Sometimes
user
system
requirements
integrated
single
description
cases
user
requirements
described
introductory
chapter
system
requirements
specification
Requirements
documents
essential
systems
outsourced
development
different
teams
develop
different
parts
system
detailed
analysis
requirements
mandatory
circumstances
software
product
business
system
development
detailed
requirements
document
needed
Agile
methods
argue
requirements
change
rapidly
requirements
document
date
soon
written
effort
largely
wasted
Rather
formal
document
agile
approaches
often
collect
user
requirements
incrementally
write
cards
whiteboards
short
user
stories
user
prioritizes
stories
implementation
next
increment
system
business
systems
requirements
unstable
think
approach
good
one
However
think
still
useful
write
short
supporting
document
defines
business
dependability
requirements
system
easy
forget
requirements
apply
system
whole
focusing
functional
requirements
next
system
release
requirements
document
diverse
set
users
ranging
senior
management
organization
paying
system
engineers
responsible
developing
software
Figure
shows
possible
users
document
use
@@@@@@@@@@
Requirements
specification
System
customers
Managers
System
engineers
System
test
engineers
Figure
Users
requirements
document
System
maintenance
engineers
diversity
possible
users
means
requirements
document
compromise
describe
requirements
customers
define
requirements
precise
detail
developers
testers
well
include
information
future
system
evolution
Information
anticipated
changes
helps
system
designers
avoid
restrictive
design
decisions
maintenance
engineers
adapt
system
new
requirements
level
detail
include
requirements
document
depends
type
system
developed
development
process
used
Critical
systems
need
detailed
requirements
safety
security
analyzed
detail
find
possible
requirements
errors
system
developed
separate
company
e
g
outsourcing
system
specifications
need
detailed
precise
house
iterative
development
process
used
requirements
document
less
detailed
Details
added
requirements
ambiguities
resolved
development
system
Figure
shows
one
possible
organization
requirements
document
based
IEEE
standard
requirements
documents
IEEE
standard
generic
one
adapted
specific
uses
case
standard
extended
include
information
predicted
system
evolution
information
helps
maintainers
system
allows
designers
include
support
future
system
features
Specify
requirements
read
check
meet
needs
Customers
specify
changes
requirements
Use
requirements
document
plan
bid
system
plan
system
development
process
Use
requirements
understand
system
developed
Use
requirements
develop
validation
tests
system
Use
requirements
understand
system
relationships
parts
@@@@@@@@@@
Chapter
Requirements
engineering
chapter
Description
Preface
Figure
structure
requirements
document
Introduction
Glossary
User
requirements
definition
System
architecture
System
requirements
specification
System
models
System
evolution
Appendices
Index
defines
expected
readership
document
describe
version
history
including
rationale
creation
new
version
summary
changes
made
version
describes
need
system
briefly
describe
system
s
functions
explain
work
systems
describe
system
fits
overall
business
strategic
objectives
organization
commissioning
software
defines
technical
terms
used
document
make
assumptions
experience
expertise
reader
describe
services
provided
user
nonfunctional
system
requirements
described
section
description
use
natural
language
diagrams
notations
understandable
customers
Product
process
standards
followed
specified
chapter
presents
high
level
overview
anticipated
system
architecture
showing
distribution
functions
across
system
modules
Architectural
components
reused
highlighted
describes
functional
nonfunctional
requirements
detail
necessary
detail
added
nonfunctional
requirements
Interfaces
systems
defined
chapter
includes
graphical
system
models
showing
relationships
system
components
system
environment
Examples
possible
models
object
models
data
flow
models
semantic
data
models
describes
fundamental
assumptions
system
based
anticipated
changes
due
hardware
evolution
changing
user
needs
section
useful
system
designers
help
avoid
design
decisions
constrain
likely
future
changes
system
provide
detailed
specific
information
related
application
developed
example
hardware
database
descriptions
Hardware
requirements
define
minimal
optimal
configurations
system
Database
requirements
define
logical
organization
data
used
system
relationships
data
Several
indexes
document
included
well
normal
alphabetic
index
index
diagrams
index
functions
Naturally
information
included
requirements
document
depends
type
software
developed
approach
development
used
requirements
document
structure
like
shown
Figure
produced
complex
engineering
system
includes
hardware
software
developed
different
companies
requirements
document
likely
long
detailed
therefore
important
comprehensive
table
contents
document
index
included
readers
easily
find
information
need
contrast
requirements
document
house
software
product
leave
many
detailed
chapters
suggested
focus
defining
user
requirements
high
level
nonfunctional
system
requirements
system
designers
programmers
use
judgment
decide
meet
outline
user
requirements
system
@@@@@@@@@@
Requirements
validation
requirements
document
standards
number
large
organizations
U
S
Department
Defense
IEEE
defined
standards
requirements
documents
usually
generic
nevertheless
useful
basis
developing
detailed
organizational
standards
U
S
Institute
Electrical
Electronic
Engineers
IEEE
one
best
known
standards
providers
developed
standard
structure
requirements
documents
standard
appropriate
systems
military
command
control
systems
long
lifetime
usually
developed
group
organizations
http
software
engineering
book
com
web
requirements
standard
Requirements
validation
Requirements
validation
process
checking
requirements
define
system
customer
really
wants
overlaps
elicitation
analysis
concerned
finding
problems
requirements
Requirements
validation
critically
important
errors
requirements
document
lead
extensive
rework
costs
problems
discovered
development
system
service
cost
fixing
requirements
problem
making
system
change
usually
much
greater
repairing
design
coding
errors
change
requirements
usually
means
system
design
implementation
changed
Furthermore
system
retested
requirements
validation
process
different
types
checks
carried
requirements
requirements
document
checks
include
Validity
checks
check
requirements
reflect
real
needs
system
users
changing
circumstances
user
requirements
changed
since
originally
elicited
Consistency
checks
Requirements
document
conflict
contradictory
constraints
different
descriptions
system
function
Completeness
checks
requirements
document
include
requirements
define
functions
constraints
intended
system
user
Realism
checks
using
knowledge
existing
technologies
requirements
checked
ensure
implemented
proposed
budget
system
checks
take
account
budget
schedule
system
development
Verifiability
reduce
potential
dispute
customer
contractor
system
requirements
written
verifiable
means
able
write
set
tests
demonstrate
delivered
system
meets
specified
requirement
@@@@@@@@@@
Chapter
Requirements
engineering
requirements
reviews
requirements
review
process
group
people
system
customer
system
developer
read
requirements
document
detail
check
errors
anomalies
inconsistencies
detected
recorded
customer
developer
negotiate
identified
problems
solved
http
software
engineering
book
com
web
requirements
reviews
number
requirements
validation
techniques
used
individually
conjunction
one
another
Requirements
reviews
requirements
analyzed
systematically
team
reviewers
check
errors
inconsistencies
Prototyping
involves
developing
executable
model
system
using
end
users
customers
see
meets
needs
expectations
Stakeholders
experiment
system
feed
back
requirements
changes
development
team
Test
case
generation
Requirements
testable
tests
requirements
devised
part
validation
process
often
reveals
requirements
problems
test
difficult
impossible
design
usually
means
requirements
difficult
implement
reconsidered
Developing
tests
user
requirements
code
written
integral
part
test
driven
development
underestimate
problems
involved
requirements
validation
Ultimately
difficult
show
set
requirements
fact
meet
user
s
needs
Users
need
picture
system
operation
imagine
system
fit
work
hard
even
skilled
computer
professionals
perform
type
abstract
analysis
harder
still
system
users
result
rarely
find
requirements
problems
requirements
validation
process
Inevitably
requirements
changes
needed
correct
omissions
misunderstandings
agreement
reached
requirements
document
Requirements
change
requirements
large
software
systems
changing
One
reason
frequent
changes
systems
often
developed
address
wicked
problems
problems
cannot
completely
defined
Rittel
Webber
problem
cannot
fully
defined
software
requirements
bound
@@@@@@@@@@
Requirements
change
Changed
understanding
problem
Initial
understanding
problem
Changed
requirements
Initial
requirements
Figure
Requirements
evolution
Time
incomplete
software
development
process
stakeholders
understanding
problem
constantly
changing
Figure
system
requirements
evolve
reflect
changed
problem
understanding
system
installed
regularly
used
new
requirements
inevitably
emerge
partly
consequence
errors
omissions
original
requirements
corrected
However
changes
system
requirements
arise
changes
business
environment
system
business
technical
environment
system
changes
installation
New
hardware
introduced
existing
hardware
updated
necessary
interface
system
systems
Business
priorities
change
consequent
changes
system
support
required
new
legislation
regulations
introduced
require
system
compliance
people
pay
system
users
system
rarely
people
System
customers
impose
requirements
organizational
budgetary
constraints
conflict
end
user
requirements
delivery
new
features
added
user
support
system
meet
goals
Large
systems
usually
diverse
stakeholder
community
stakeholders
different
requirements
priorities
conflicting
contradictory
final
system
requirements
inevitably
compromise
stakeholders
given
priority
experience
often
discovered
balance
support
given
different
stakeholders
changed
requirements
re
prioritized
requirements
evolving
need
keep
track
individual
requirements
maintain
links
dependent
requirements
assess
impact
requirements
changes
therefore
need
formal
process
making
change
proposals
linking
system
requirements
process
requirements
management
start
soon
draft
version
requirements
document
available
Agile
development
processes
designed
cope
requirements
change
development
process
processes
user
proposes
requirements
change
change
go
formal
change
management
@@@@@@@@@@
Chapter
Requirements
engineering
enduring
volatile
requirements
requirements
susceptible
change
others
Enduring
requirements
requirements
associated
core
slow
change
activities
organization
Enduring
requirements
associated
fundamental
work
activities
Volatile
requirements
likely
change
usually
associated
supporting
activities
reflect
organization
work
rather
work
http
software
engineering
book
com
web
changing
requirements
process
Rather
user
prioritize
change
high
priority
decide
system
features
planned
next
iteration
dropped
change
implemented
problem
approach
users
necessarily
best
people
decide
requirements
change
cost
effective
systems
multiple
stakeholders
changes
benefit
stakeholders
others
often
better
independent
authority
balance
needs
stakeholders
decide
changes
accepted
Requirements
management
planning
Requirements
management
planning
concerned
establishing
set
evolving
requirements
managed
planning
stage
decide
number
issues
Requirements
identification
requirement
uniquely
identified
cross
referenced
requirements
used
traceability
assessments
change
management
process
set
activities
assess
impact
cost
changes
discuss
process
detail
following
section
Traceability
policies
policies
define
relationships
requirement
requirements
system
design
recorded
traceability
policy
define
records
maintained
Tool
support
Requirements
management
involves
processing
large
amounts
information
requirements
Tools
used
range
specialist
requirements
management
systems
shared
spreadsheets
simple
database
systems
Requirements
management
needs
automated
support
software
tools
chosen
planning
phase
need
tool
support
Requirements
storage
requirements
maintained
secure
managed
data
store
accessible
everyone
involved
requirements
engineering
process
@@@@@@@@@@
Requirements
change
Change
implementation
Change
analysis
costing
Problem
analysis
change
specification
Identified
problem
Revised
requirements
Figure
Requirements
change
management
Change
management
process
change
management
Figure
simplified
active
tool
support
available
Tools
keep
track
suggested
changes
responses
suggestions
Traceability
management
discussed
tool
support
traceability
allows
related
requirements
discovered
tools
available
use
natural
language
processing
techniques
help
discover
possible
relationships
requirements
small
systems
need
use
specialized
requirements
management
tools
Requirements
management
supported
using
shared
web
documents
spreadsheets
databases
However
larger
systems
specialized
tool
support
using
systems
DOORS
IBM
makes
much
easier
keep
track
large
number
changing
requirements
Requirements
change
management
Requirements
change
management
Figure
applied
proposed
changes
system
s
requirements
requirements
document
approved
Change
management
essential
need
decide
benefits
implementing
new
requirements
justified
costs
implementation
advantage
using
formal
process
change
management
change
proposals
treated
consistently
changes
requirements
document
made
controlled
way
three
principal
stages
change
management
process
Problem
analysis
change
specification
process
starts
identified
requirements
problem
sometimes
specific
change
proposal
stage
problem
change
proposal
analyzed
check
valid
analysis
fed
back
change
requestor
respond
specific
requirements
change
proposal
decide
withdraw
request
Change
analysis
costing
effect
proposed
change
assessed
using
traceability
information
general
knowledge
system
requirements
cost
making
change
estimated
terms
modifications
requirements
document
appropriate
system
design
implementation
analysis
completed
decision
made
proceed
requirements
change
@@@@@@@@@@
Chapter
Requirements
engineering
requirements
traceability
need
keep
track
relationships
requirements
sources
system
design
analyze
reasons
proposed
changes
impact
changes
likely
parts
system
need
able
trace
change
ripples
way
system
http
software
engineering
book
com
web
traceability
Change
implementation
requirements
document
necessary
system
design
implementation
modified
organize
requirements
document
make
changes
without
extensive
rewriting
reorganization
programs
changeability
documents
achieved
minimizing
external
references
making
document
sections
modular
possible
Thus
individual
sections
changed
replaced
without
affecting
parts
document
new
requirement
urgently
implemented
temptation
change
system
retrospectively
modify
requirements
document
inevitably
leads
requirements
specification
system
implementation
getting
step
system
changes
made
easy
forget
include
changes
requirements
document
circumstances
emergency
changes
system
made
cases
important
update
requirements
document
soon
possible
order
include
revised
requirements
Key
Points
Requirements
software
system
set
system
define
constraints
operation
implementation
Functional
requirements
statements
services
system
provide
descriptions
computations
carried
Non
functional
requirements
often
constrain
system
developed
development
process
used
product
requirements
organizational
requirements
external
requirements
often
relate
emergent
properties
system
therefore
apply
system
whole
requirements
engineering
process
includes
requirements
elicitation
requirements
specification
requirements
validation
requirements
management
Requirements
elicitation
iterative
process
represented
spiral
activities
requirements
discovery
requirements
classification
organization
requirements
negotiation
requirements
documentation
@@@@@@@@@@
Chapter
Website
Requirements
specification
process
formally
documenting
user
system
requirements
creating
software
requirements
document
software
requirements
document
agreed
statement
system
requirements
organized
system
customers
software
developers
use
Requirements
validation
process
checking
requirements
validity
consistency
completeness
realism
verifiability
Business
organizational
technical
changes
inevitably
lead
changes
requirements
software
system
Requirements
management
process
managing
controlling
changes
REadIng
Integrated
Requirements
Engineering
Tutorial
tutorial
paper
discusses
requirements
engineering
activities
adapted
fit
modern
software
engineering
practice
Sommerville
IEEE
Software
January
February
http
dx
doi
org
MS
Research
Directions
Requirements
Engineering
good
survey
requirements
engineering
research
highlights
future
research
challenges
area
address
issues
scale
agility
B
H
C
Cheng
J
M
Atlee
Proc
Conf
Future
Software
Engineering
IEEE
Computer
Society
http
dx
doi
org
FOSE
Mastering
Requirements
Process
rd
ed
well
written
easy
read
book
based
particular
method
VOLERE
includes
lots
good
general
advice
requirements
engineering
S
Robertson
J
Robertson
Addison
Wesley
WEbsItE
PowerPoint
slides
chapter
www
pearsonglobaleditions
com
Sommerville
Links
supporting
videos
http
software
engineering
book
com
videos
requirements
design
Requirements
document
insulin
pump
http
software
engineering
book
com
case
studies
insulin
pump
Mentcare
system
requirements
information
http
software
engineering
book
com
case
studies
mentcare
system
@@@@@@@@@@
Chapter
Requirements
engineering
ExERCIsEs
Identify
briefly
describe
four
types
requirements
defined
computer
based
system
Discover
ambiguities
omissions
following
statement
requirements
part
drone
system
intended
search
recovery
drone
quad
chopper
useful
search
recovery
operations
especially
remote
areas
extreme
weather
conditions
click
high
resolution
images
fly
according
path
preset
ground
operator
able
avoid
obstacles
returning
original
path
possible
drone
able
identify
various
objects
match
target
looking
Rewrite
description
using
structured
approach
described
chapter
Resolve
identified
ambiguities
sensible
way
Write
set
non
functional
requirements
drone
system
setting
expected
safety
response
time
Using
technique
suggested
natural
language
descriptions
presented
standard
format
write
plausible
user
requirements
following
functions
unattended
petrol
gas
pump
system
includes
credit
card
reader
customer
swipes
card
reader
specifies
amount
fuel
required
fuel
delivered
customer
s
account
debited
cash
dispensing
function
bank
ATM
Internet
banking
system
facility
allows
customers
transfer
funds
one
account
held
bank
another
account
bank
Suggest
engineer
responsible
drawing
system
requirements
specification
keep
track
relationships
functional
non
functional
requirements
Using
knowledge
ATM
used
develop
set
use
cases
serve
basis
understanding
requirements
ATM
system
minimize
mistakes
requirements
review
organization
decides
allocate
two
scribes
document
review
session
Explain
done
emergency
changes
made
systems
system
software
modified
changes
requirements
approved
Suggest
model
process
making
modifications
ensure
requirements
document
system
implementation
inconsistent
taken
job
software
user
contracted
previous
employer
develop
system
discover
company
s
interpretation
requirements
different
interpretation
taken
previous
employer
Discuss
@@@@@@@@@@
Chapter
References
situation
know
costs
current
employer
increase
ambiguities
resolved
However
responsibility
confidentiality
previous
employer
REFEREnCEs
Crabtree
Designing
Collaborative
Systems
Practical
Guide
Ethnography
London
Springer
Verlag
Davis
M
Software
Requirements
Objects
Functions
States
Englewood
Cliffs
NJ
Prentice
Hall
IBM
Rational
Doors
Next
Generation
Requirements
Engineering
Complex
Systems
https
jazz
net
products
rational
doors
next
generation
IEEE
IEEE
Recommended
Practice
Software
Requirements
Specifications
IEEE
Software
Engineering
Standards
Collection
Los
Alamitos
CA
IEEE
Computer
Society
Press
Jacobsen
M
Christerson
P
Jonsson
G
Overgaard
Object
Oriented
Software
Engineering
Wokingham
UK
Addison
Wesley
Martin
D
Sommerville
Patterns
Cooperative
Interaction
Linking
Ethnomethodology
Design
ACM
Transactions
Computer
Human
Interaction
March
doi
Rittel
H
M
Webber
Dilemmas
General
Theory
Planning
Policy
Sciences
doi
BF
Robertson
S
J
Robertson
Mastering
Requirements
Process
rd
ed
Boston
Addison
Wesley
Sommerville
T
Rodden
P
Sawyer
R
Bentley
M
Twidale
Integrating
Ethnography
Requirements
Engineering
Process
RE
San
Diego
CA
IEEE
Computer
Society
Press
doi
ISRE
Stevens
P
R
Pooley
Using
UML
Software
Engineering
Objects
Components
nd
ed
Harlow
UK
Addison
Wesley
Suchman
L
Office
Procedures
Practical
Action
Models
Work
System
Design
ACM
Transactions
Office
Information
Systems
doi
Viller
S
Sommerville
Ethnographically
Informed
Analysis
Software
Engineers
Int
J
Human
Computer
Studies
doi
ijhc
@@@@@@@@@@
System
modeling
Objectives
aim
chapter
introduce
system
models
developed
part
requirements
engineering
system
design
processes
read
chapter
understand
graphical
models
used
represent
software
systems
several
types
model
needed
fully
represent
system
understand
fundamental
system
modeling
perspectives
context
interaction
structure
behavior
understand
principal
diagram
types
Unified
Modeling
Language
UML
diagrams
used
system
modeling
introduced
model
driven
engineering
executable
system
automatically
generated
structural
behavioral
models
Contents
Context
models
Interaction
models
Structural
models
Behavioral
models
Model
driven
engineering
@@@@@@@@@@
Chapter
System
modeling
System
modeling
process
developing
abstract
models
system
model
presenting
different
view
perspective
system
System
modeling
now
usually
means
representing
system
using
kind
graphical
notation
based
diagram
types
Unified
Modeling
Language
UML
However
possible
develop
formal
mathematical
models
system
usually
detailed
system
specification
cover
graphical
modeling
using
UML
formal
modeling
briefly
discussed
Chapter
Models
used
requirements
engineering
process
help
derive
detailed
requirements
system
design
process
describe
system
engineers
implementing
system
implementation
document
system
s
structure
operation
develop
models
existing
system
system
developed
Models
existing
system
used
requirements
engineering
help
clarify
existing
system
used
focus
stakeholder
discussion
strengths
weaknesses
Models
new
system
used
requirements
engineering
help
explain
proposed
requirements
system
stakeholders
Engineers
use
models
discuss
design
proposals
document
system
implementation
use
model
driven
engineering
process
Brambilla
Cabot
Wimmer
generate
complete
partial
system
implementation
system
models
important
understand
system
model
complete
representation
system
purposely
leaves
detail
make
easier
understand
model
abstraction
system
studied
rather
alternative
representation
system
representation
system
maintain
information
entity
represented
abstraction
deliberately
simplifies
system
design
picks
salient
characteristics
example
PowerPoint
slides
accompany
book
abstraction
book
s
key
points
However
book
translated
English
Italian
alternative
representation
translator
s
intention
maintain
information
presented
English
develop
different
models
represent
system
different
perspectives
example
external
perspective
model
context
environment
system
interaction
perspective
model
interactions
system
environment
components
system
structural
perspective
model
organization
system
structure
data
processed
system
behavioral
perspective
model
dynamic
behavior
system
responds
events
@@@@@@@@@@
Chapter
System
modeling
Unified
Modeling
Language
Unified
Modeling
Language
UML
set
different
diagram
types
used
model
software
systems
emerged
work
s
object
oriented
modeling
similar
object
oriented
notations
integrated
create
UML
major
revision
UML
finalized
UML
universally
accepted
standard
approach
developing
models
software
systems
Variants
SysML
proposed
general
system
modeling
http
software
engineering
book
com
web
uml
developing
system
models
often
flexible
way
graphical
notation
used
need
stick
rigidly
details
notation
detail
rigor
model
depend
intend
use
three
ways
graphical
models
commonly
used
way
stimulate
focus
discussion
existing
proposed
system
purpose
model
stimulate
focus
discussion
among
software
engineers
involved
developing
system
models
incomplete
long
cover
key
points
discussion
use
modeling
notation
informally
models
normally
used
agile
modeling
Ambler
Jeffries
way
documenting
existing
system
models
used
documentation
complete
need
use
models
document
parts
system
However
models
correct
use
notation
correctly
accurate
description
system
detailed
system
description
used
generate
system
implementation
models
used
part
model
based
development
process
system
models
complete
correct
used
basis
generating
source
code
system
therefore
careful
confuse
similar
symbols
stick
block
arrowheads
different
meanings
chapter
use
diagrams
defined
Unified
Modeling
Language
UML
Rumbaugh
Jacobson
Booch
Booch
Rumbaugh
Jacobson
standard
language
object
oriented
modeling
UML
diagram
types
supports
creation
many
different
types
system
model
However
survey
Erickson
Siau
showed
users
UML
thought
five
diagram
types
represent
essentials
system
therefore
concentrate
five
UML
diagram
types
@@@@@@@@@@
Context
models
Activity
diagrams
show
activities
involved
process
data
processing
Use
case
diagrams
show
interactions
system
environment
Sequence
diagrams
show
interactions
actors
system
system
components
Class
diagrams
show
object
classes
system
associations
classes
State
diagrams
show
system
reacts
internal
external
events
Context
models
early
stage
specification
system
decide
system
boundaries
part
system
developed
involves
working
system
stakeholders
decide
functionality
included
system
processing
operations
carried
system
s
operational
environment
decide
automated
support
business
processes
implemented
software
developed
processes
manual
supported
different
systems
look
possible
overlaps
functionality
existing
systems
decide
new
functionality
implemented
decisions
made
early
process
limit
system
costs
time
needed
understanding
system
requirements
design
cases
boundary
system
environment
relatively
clear
example
automated
system
replacing
existing
manual
computerized
system
environment
new
system
usually
existing
system
s
environment
cases
flexibility
decide
constitutes
boundary
system
environment
requirements
engineering
process
example
say
developing
specification
Mentcare
patient
information
system
system
intended
manage
information
patients
attending
mental
health
clinics
treatments
prescribed
developing
specification
system
decide
system
focus
exclusively
collecting
information
consultations
using
systems
collect
personal
information
patients
collect
personal
patient
information
advantage
relying
systems
patient
information
avoid
duplicating
data
major
disadvantage
however
using
systems
make
slower
access
information
systems
unavailable
impossible
use
Mentcare
system
situations
user
base
system
diverse
users
wide
range
different
system
requirements
decide
define
@@@@@@@@@@
Chapter
System
modeling
system
Mentcare
system
Patient
record
system
system
Appointments
system
system
Admissions
system
system
Management
reporting
system
system
Prescription
system
system
HC
statistics
system
Figure
context
Mentcare
system
boundaries
explicitly
instead
develop
configurable
system
adapted
needs
different
users
approach
adopted
iLearn
systems
introduced
Chapter
users
range
young
children
t
read
young
adults
teachers
school
administrators
groups
need
different
system
boundaries
specified
configuration
system
allow
boundaries
specified
system
deployed
definition
system
boundary
value
free
judgment
Social
organizational
concerns
mean
position
system
boundary
determined
nontechnical
factors
example
system
boundary
deliberately
positioned
complete
analysis
process
carried
one
site
chosen
particularly
difficult
manager
need
consulted
positioned
system
cost
increased
system
development
division
therefore
expand
design
implement
system
decisions
boundaries
system
made
part
analysis
activity
definition
context
dependencies
system
environment
Normally
producing
simple
architectural
model
first
step
activity
Figure
context
model
shows
Mentcare
system
systems
environment
see
Mentcare
system
connected
appointments
system
general
patient
record
system
shares
data
system
connected
systems
management
reporting
hospital
admissions
statistics
system
collects
information
research
Finally
makes
use
prescription
system
generate
prescriptions
patients
medication
Context
models
normally
show
environment
includes
several
automated
systems
However
show
types
relationships
systems
environment
system
specified
External
systems
produce
data
consume
data
system
share
data
system
connected
directly
network
connected
physically
co
located
located
separate
buildings
@@@@@@@@@@
Context
models
Confirm
detention
decision
Find
secure
place
Admit
hospital
Transfer
police
station
Transfer
secure
hospital
Inform
next
kin
Inform
social
care
Inform
patient
rights
Update
register
system
Admissions
system
system
Mentcare
system
Mentcare
Record
detention
decision
dangerous
available
dangerous
available
Figure
process
model
involuntary
detention
relations
affect
requirements
design
system
defined
taken
account
Therefore
simple
context
models
used
along
models
business
process
models
describe
human
automated
processes
particular
software
systems
used
UML
activity
diagrams
used
show
business
processes
systems
used
Figure
UML
activity
diagram
shows
Mentcare
system
used
important
mental
health
care
process
involuntary
detention
Sometimes
patients
suffering
mental
health
problems
danger
others
therefore
detained
hospital
treatment
administered
detention
subject
strict
legal
safeguards
example
decision
detain
patient
regularly
reviewed
people
held
indefinitely
without
good
reason
One
critical
function
Mentcare
system
ensure
safeguards
implemented
rights
patients
respected
UML
activity
diagrams
show
activities
process
flow
control
one
activity
another
start
process
indicated
filled
circle
end
filled
circle
inside
another
circle
Rectangles
round
corners
represent
activities
specific
subprocesses
carried
include
objects
activity
charts
Figure
shows
systems
used
support
different
subprocesses
involuntary
detection
process
shown
separate
systems
using
UML
stereotype
feature
type
entity
box
chevrons
shown
Arrows
represent
flow
work
one
activity
another
solid
bar
indicates
activity
coordination
flow
one
activity
leads
@@@@@@@@@@
Chapter
System
modeling
Figure
Transfer
data
use
case
Medical
receptionist
Patient
record
system
Transfer
data
solid
bar
activities
complete
progress
possible
flow
solid
bar
leads
number
activities
executed
parallel
Therefore
Figure
activities
inform
social
care
patient
s
next
kin
well
update
detention
register
concurrent
Arrows
annotated
guards
square
brackets
specify
flow
followed
Figure
see
guards
showing
flows
patients
dangerous
dangerous
society
Patients
dangerous
society
detained
secure
facility
However
patients
suicidal
danger
admitted
appropriate
ward
hospital
kept
close
supervision
Interaction
models
systems
involve
interaction
kind
user
interaction
involves
user
inputs
outputs
interaction
software
developed
systems
environment
interaction
components
software
system
User
interaction
modeling
important
helps
identify
user
requirements
Modeling
system
system
interaction
highlights
communication
problems
arise
Modeling
component
interaction
helps
us
understand
proposed
system
structure
likely
deliver
required
system
performance
dependability
section
discusses
two
related
approaches
interaction
modeling
Use
case
modeling
mostly
used
model
interactions
system
external
agents
human
users
systems
Sequence
diagrams
used
model
interactions
system
components
external
agents
included
Use
case
models
sequence
diagrams
present
interactions
different
levels
detail
used
together
example
details
interactions
involved
high
level
use
case
documented
sequence
diagram
UML
includes
communication
diagrams
used
model
interactions
don
t
describe
diagram
type
communication
diagrams
simply
alternative
representation
sequence
diagrams
Use
case
modeling
Use
case
modeling
originally
developed
Ivar
Jacobsen
s
Jacobsen
et
al
UML
diagram
type
support
use
case
modeling
part
@@@@@@@@@@
Interaction
models
Mentcare
system
Transfer
data
Actors
Medical
receptionist
Patient
records
system
PRS
Figure
Tabular
description
Transfer
data
use
case
Description
receptionist
transfer
data
Mentcare
system
general
patient
record
database
maintained
health
authority
information
transferred
updated
personal
information
address
phone
number
etc
summary
patient
s
diagnosis
treatment
Data
Patient
s
personal
information
treatment
summary
Stimulus
User
command
issued
medical
receptionist
Response
Confirmation
PRS
updated
Comments
receptionist
appropriate
security
permissions
access
patient
information
PRS
UML
use
case
taken
simple
description
user
expects
system
interaction
discussed
use
cases
requirements
elicitation
Chapter
said
Chapter
find
use
case
models
useful
early
stages
system
design
rather
requirements
engineering
use
case
represents
discrete
task
involves
external
interaction
system
simplest
form
use
case
shown
ellipse
actors
involved
use
case
represented
stick
figures
Figure
shows
use
case
Mentcare
system
represents
task
uploading
data
Mentcare
system
general
patient
record
system
general
system
maintains
summary
data
patient
rather
data
consultation
recorded
Mentcare
system
Notice
two
actors
use
case
operator
transferring
data
patient
record
system
stick
figure
notation
originally
developed
cover
human
interaction
used
represent
external
systems
hardware
Formally
use
case
diagrams
use
lines
without
arrows
arrows
UML
indicate
direction
flow
messages
Obviously
use
case
messages
pass
directions
However
arrows
Figure
used
informally
indicate
medical
receptionist
initiates
transaction
data
transferred
patient
record
system
Use
case
diagrams
give
simple
overview
interaction
need
add
detail
complete
interaction
description
detail
simple
textual
description
structured
description
table
sequence
diagram
choose
appropriate
format
depending
use
case
level
detail
think
required
model
find
standard
tabular
format
useful
Figure
shows
tabular
description
Transfer
data
use
case
Composite
use
case
diagrams
show
number
different
use
cases
Sometimes
possible
include
possible
interactions
system
single
composite
use
case
diagram
However
impossible
number
use
cases
cases
develop
several
diagrams
shows
related
use
cases
example
Figure
shows
use
cases
Mentcare
system
@@@@@@@@@@
Chapter
System
modeling
Medical
receptionist
Register
patient
Transfer
data
Contact
patient
View
patient
info
Unregister
patient
Figure
Use
cases
involving
role
Medical
receptionist
actor
Medical
Receptionist
involved
accompanied
detailed
description
UML
includes
number
constructs
sharing
part
use
case
use
case
diagrams
constructs
sometimes
helpful
system
designers
experience
many
people
especially
end
users
find
difficult
understand
reason
constructs
described
Sequence
diagrams
Sequence
diagrams
UML
primarily
used
model
interactions
actors
objects
system
interactions
objects
UML
rich
syntax
sequence
diagrams
allows
many
different
kinds
interaction
modeled
space
allow
covering
possibilities
focus
basics
diagram
type
name
implies
sequence
diagram
shows
sequence
interactions
take
place
particular
use
case
use
case
instance
Figure
example
sequence
diagram
illustrates
basics
notation
diagram
models
interactions
involved
View
patient
information
use
case
medical
receptionist
see
patient
information
objects
actors
involved
listed
along
top
diagram
dotted
line
drawn
vertically
Annotated
arrows
indicate
interactions
objects
rectangle
dotted
lines
indicates
lifeline
object
concerned
e
time
object
instance
involved
computation
read
sequence
interactions
top
bottom
annotations
arrows
indicate
calls
objects
parameters
return
values
example
shows
notation
used
denote
alternatives
box
named
alt
used
@@@@@@@@@@
Interaction
models
Medical
Receptionist
P
PatientInfo
ViewInfo
PID
report
Info
PID
UID
authorize
Info
UID
Patient
info
D
Mentcare
DB
Authorization
authorization
Error
no
access
authorization
authorization
fail
alt
Figure
Sequence
diagram
View
patient
information
conditions
indicated
square
brackets
alternative
interaction
options
separated
dotted
line
read
Figure
follows
medical
receptionist
triggers
ViewInfo
method
instance
P
PatientInfo
object
class
supplying
patient
s
identifier
PID
identify
required
information
P
user
interface
object
displayed
form
showing
patient
information
instance
P
calls
database
return
information
required
supplying
receptionist
s
identifier
allow
security
checking
stage
important
receptionist
s
UID
comes
database
checks
authorization
system
receptionist
authorized
action
authorized
patient
information
returned
displayed
form
user
s
screen
authorization
fails
error
message
returned
box
denoted
alt
top
left
corner
choice
box
indicating
one
contained
interactions
executed
condition
selects
choice
shown
square
brackets
Figure
example
sequence
diagram
system
illustrates
two
additional
features
direct
communication
actors
system
creation
objects
part
sequence
operations
example
object
type
Summary
created
hold
summary
data
@@@@@@@@@@
Chapter
System
modeling
Medical
Receptionist
PRS
P
PatientInfo
login
D
Mentcare
DB
Authorization
authorization
sendInfo
sendSummary
updateInfo
updatePRS
UID
update
PID
update
OKMessage
summarize
UID
authorize
TF
UID
authorization
authorize
TF
UID
summary
update
PID
UpdateSummary
logout
alt
update
OKMessage
Figure
Sequence
diagram
uploaded
national
PRS
patient
records
system
read
diagram
Transfer
Data
follows
receptionist
logs
PRS
Two
options
available
shown
alt
box
allow
direct
transfer
updated
patient
information
Mentcare
database
PRS
transfer
summary
health
data
Mentcare
database
PRS
case
receptionist
s
permissions
checked
using
authorization
system
@@@@@@@@@@
Structural
models
Personal
information
transferred
directly
user
interface
object
PRS
Alternatively
summary
record
created
database
record
transferred
completion
transfer
PRS
issues
status
message
user
logs
off
Unless
using
sequence
diagrams
code
generation
detailed
documentation
don
t
include
every
interaction
diagrams
develop
system
models
early
development
process
support
requirements
engineering
high
level
design
many
interactions
depend
implementation
decisions
example
Figure
decision
get
user
identifier
check
authorization
one
delayed
implementation
involve
interacting
User
object
important
stage
need
include
sequence
diagram
Structural
models
Structural
models
software
display
organization
system
terms
components
make
system
relationships
Structural
models
static
models
show
organization
system
design
dynamic
models
show
organization
system
executing
things
dynamic
organization
system
set
interacting
threads
different
static
model
system
components
create
structural
models
system
discussing
designing
system
architecture
models
overall
system
architecture
detailed
models
objects
system
relationships
section
focus
use
class
diagrams
modeling
static
structure
object
classes
software
system
Architectural
design
important
topic
software
engineering
UML
component
package
deployment
diagrams
used
presenting
architectural
models
cover
architectural
modeling
Chapters
Class
diagrams
Class
diagrams
used
developing
object
oriented
system
model
show
classes
system
associations
classes
Loosely
object
class
thought
general
definition
one
kind
system
object
association
link
classes
indicating
relationship
exists
classes
Consequently
class
knowledge
associated
class
developing
models
early
stages
software
engineering
process
objects
represent
something
real
world
patient
@@@@@@@@@@
Chapter
System
modeling
Figure
UML
Classes
association
Patient
Patientrecord
PatientGeneralpractitionerConsultationConsultantMedicationTreatmentHospitalDoctorConditionreferred
byreferred
todiagnosed
withattendsprescribesprescribesinvolves
Figure
Classes
associations
Mentcare
system
prescription
doctor
implementation
developed
define
implementation
objects
represent
data
manipulated
system
section
focus
modeling
real
world
objects
part
requirements
early
software
design
processes
similar
approach
used
data
structure
modeling
Class
diagrams
UML
expressed
different
levels
detail
developing
model
first
stage
usually
look
world
identify
essential
objects
represent
classes
simplest
way
writing
diagrams
write
class
name
box
note
existence
association
drawing
line
classes
example
Figure
simple
class
diagram
showing
two
classes
Patient
Patient
Record
association
stage
need
say
association
Figure
develops
simple
class
diagram
Figure
show
objects
class
Patient
involved
relationships
number
classes
example
show
name
associations
give
reader
indication
type
relationship
exists
Figures
shows
important
feature
class
diagrams
ability
show
many
objects
involved
association
Figure
end
association
annotated
meaning
relationship
objects
classes
patient
exactly
one
record
record
maintains
information
exactly
one
patient
see
Figure
multiplicities
possible
define
exact
number
objects
involved
e
g
using
indicate
indefinite
number
objects
involved
association
example
multiplicity
Figure
relationship
Patient
Condition
shows
patient
suffer
several
conditions
condition
associated
several
patients
@@@@@@@@@@
Structural
models
Consultation
Doctors
Date
Time
Clinic
Reason
Medication
prescribed
Treatment
prescribed
Voice
notes
Transcript
New
Prescribe
RecordNotes
Transcribe
Figure
Consultation
class
level
detail
class
diagrams
look
like
semantic
data
models
Semantic
data
models
used
database
design
show
data
entities
associated
attributes
relations
entities
Hull
King
UML
include
diagram
type
database
modeling
models
data
using
objects
relationships
However
use
UML
represent
semantic
data
model
think
entities
semantic
data
model
simplified
object
classes
no
operations
attributes
object
class
attributes
relations
named
associations
object
classes
showing
associations
classes
best
represent
classes
simplest
possible
way
without
attributes
operations
define
objects
detail
add
information
attributes
object
s
characteristics
operations
object
s
functions
example
Patient
object
attribute
Address
include
operation
called
ChangeAddress
called
patient
indicates
moved
one
address
another
UML
show
attributes
operations
extending
simple
rectangle
represents
class
illustrate
Figure
shows
object
representing
consultation
doctor
patient
name
object
class
top
section
class
attributes
middle
section
includes
attribute
names
optionally
types
don
t
show
types
Figure
operations
called
methods
Java
OO
programming
languages
associated
object
class
lower
section
rectangle
show
operations
Figure
example
shown
Figure
assumed
doctors
record
voice
notes
transcribed
later
record
details
consultation
prescribe
medication
doctor
involved
use
Prescribe
method
generate
electronic
prescription
@@@@@@@@@@
Chapter
System
modeling
Doctor
General
practitioner
Hospital
doctor
Consultant
Team
doctor
Trainee
doctor
Qualified
doctorFigure
generalization
hierarchy
Generalization
Generalization
everyday
technique
use
manage
complexity
Rather
learn
detailed
characteristics
everything
experience
learn
general
classes
animals
cars
houses
etc
learn
characteristics
classes
reuse
knowledge
classifying
things
focus
differences
class
example
squirrels
rats
members
class
rodents
share
characteristics
rodents
General
statements
apply
class
members
example
rodents
teeth
gnawing
modeling
systems
often
useful
examine
classes
system
see
scope
generalization
class
creation
means
common
information
maintained
one
place
good
design
practice
means
changes
proposed
look
classes
system
see
affected
change
make
changes
general
level
object
oriented
languages
Java
generalization
implemented
using
class
inheritance
mechanisms
built
language
UML
specific
type
association
denote
generalization
illustrated
Figure
generalization
shown
arrowhead
pointing
general
class
indicates
general
practitioners
hospital
doctors
generalized
doctors
three
types
Hospital
Doctor
graduated
medical
school
supervised
Trainee
Doctor
work
unsupervised
part
consultant
s
team
Registered
Doctor
consultants
senior
doctors
full
decision
making
responsibilities
generalization
attributes
operations
associated
higher
level
classes
associated
lower
level
classes
lower
level
classes
subclasses
inherit
attributes
operations
superclasses
lower
level
classes
add
specific
attributes
operations
@@@@@@@@@@
Structural
models
Doctor
Name
Phone
Email
register
de
register
General
practitioner
Practice
Address
Hospital
doctor
Staff
Pager
Figure
generalization
hierarchy
added
detail
example
doctors
name
phone
number
hospital
doctors
staff
number
carry
pager
General
practitioners
don
t
attributes
work
independently
individual
practice
name
address
Figure
shows
part
generalization
hierarchy
extended
class
attributes
class
Doctor
operations
associated
class
Doctor
intended
register
de
register
doctor
Mentcare
system
Aggregation
Objects
real
world
often
made
different
parts
example
study
pack
course
composed
book
PowerPoint
slides
quizzes
recommendations
reading
Sometimes
system
model
need
illustrate
UML
provides
special
type
association
classes
called
aggregation
means
one
object
whole
composed
objects
parts
define
aggregation
diamond
shape
added
link
next
class
represents
whole
Figure
shows
patient
record
aggregate
Patient
indefinite
number
Consultations
record
maintains
personal
patient
information
well
individual
record
consultation
doctor
Patient
record
Patient
Consultation
Figure
aggregation
association
@@@@@@@@@@
Chapter
System
modeling
Data
flow
diagrams
Data
flow
diagrams
DFDs
system
models
show
functional
perspective
transformation
represents
single
function
process
DFDs
used
show
data
flows
sequence
processing
steps
example
processing
step
filtering
duplicate
records
customer
database
data
transformed
step
moving
next
stage
processing
steps
transformations
represent
software
processes
functions
data
flow
diagrams
used
document
software
design
Activity
diagrams
UML
used
represent
DFDs
http
software
engineering
book
com
web
dfds
Behavioral
models
Behavioral
models
models
dynamic
behavior
system
executing
show
happens
supposed
happen
system
responds
stimulus
environment
stimuli
data
events
Data
becomes
available
processed
system
availability
data
triggers
processing
event
happens
triggers
system
processing
Events
associated
data
case
Many
business
systems
data
processing
systems
primarily
driven
data
controlled
data
input
system
relatively
little
external
event
processing
processing
involves
sequence
actions
data
generation
output
example
phone
billing
system
accept
information
calls
made
customer
calculate
costs
calls
generate
bill
customer
contrast
real
time
systems
usually
event
driven
limited
data
processing
example
landline
phone
switching
system
responds
events
handset
activated
generating
dial
tone
pressing
keys
handset
capturing
phone
number
Data
driven
modeling
Data
driven
models
show
sequence
actions
involved
processing
input
data
generating
associated
output
used
analysis
requirements
show
end
end
processing
system
show
entire
sequence
actions
takes
place
initial
input
processed
corresponding
output
system
s
response
Data
driven
models
among
first
graphical
software
models
s
structured
design
methods
used
data
flow
diagrams
DFDs
way
illustrate
@@@@@@@@@@
Behavioral
models
Blood
sugar
sensor
Blood
sugar
level
Get
sensor
value
Sensor
data
Compute
sugar
level
Calculate
insulin
delivery
Insulin
pump
Pump
control
commands
Control
pump
Calculate
pump
commands
Insulin
requirement
Figure
activity
model
insulin
pump
s
operation
Figure
Order
processing
processing
steps
system
Data
flow
models
useful
tracking
documenting
data
associated
particular
process
moves
system
help
analysts
designers
understand
going
process
DFDs
simple
intuitive
accessible
stakeholders
types
model
usually
possible
explain
potential
system
users
participate
validating
model
Data
flow
diagrams
represented
UML
using
activity
diagram
type
described
Section
Figure
simple
activity
diagram
shows
chain
processing
involved
insulin
pump
software
see
processing
steps
represented
activities
rounded
rectangles
data
flowing
steps
represented
objects
rectangles
alternative
way
showing
sequence
processing
system
use
UML
sequence
diagrams
seen
diagrams
used
model
interaction
draw
messages
sent
left
right
show
sequential
data
processing
system
Figure
illustrates
using
sequence
model
processing
order
sending
supplier
Sequence
models
highlight
objects
system
data
flow
diagrams
highlight
operations
activities
practice
nonexperts
seem
find
data
flow
diagrams
intuitive
engineers
prefer
sequence
diagrams
Purchase
officer
Supplier
Order
datastore
OrdersBudget
Fillin
Validate
validation
Update
amount
Save
Send
@@@@@@@@@@
Chapter
System
modeling
Full
Full
power
Enabled
operate
oven
power
Half
power
Half
power
Full
power
Number
Door
open
Door
closed
Door
closed
Door
open
Start
set
power
Half
power
set
power
Set
time
get
number
exit
set
time
Disabled
Operation
Cancel
Waiting
display
time
Waiting
display
time
display
Ready
display
Waiting
Timer
Timer
Figure
state
diagram
microwave
oven
Event
driven
modeling
Event
driven
modeling
shows
system
responds
external
internal
events
based
assumption
system
finite
number
states
events
stimuli
cause
transition
one
state
another
example
system
controlling
valve
move
state
Valve
open
state
Valve
closed
operator
command
stimulus
received
view
system
particularly
appropriate
real
time
systems
Event
driven
modeling
used
extensively
designing
documenting
real
time
systems
Chapter
UML
supports
event
based
modeling
using
state
diagrams
based
Statecharts
Harel
State
diagrams
show
system
states
events
cause
transitions
one
state
another
show
flow
data
system
include
additional
information
computations
carried
state
use
example
control
software
simple
microwave
oven
illustrate
event
driven
modeling
Figure
Real
microwave
ovens
much
complex
system
simplified
system
easier
understand
simple
oven
switch
select
full
half
power
numeric
keypad
input
cooking
time
start
stop
button
alphanumeric
display
@@@@@@@@@@
Behavioral
models
Cook
run
generator
Done
buzzer
secs
Waiting
Alarm
display
event
check
status
Checking
Turntable
fault
Emitter
fault
Disabled
Timeout
Time
Door
open
Cancel
Operation
Figure
state
model
Operation
state
assumed
sequence
actions
using
microwave
follows
Select
power
level
half
power
full
power
Input
cooking
time
using
numeric
keypad
Press
Start
food
cooked
given
time
safety
reasons
oven
operate
door
open
completion
cooking
buzzer
sounded
oven
simple
display
used
display
various
alerts
warning
messages
UML
state
diagrams
rounded
rectangles
represent
system
states
include
brief
description
following
actions
taken
state
labeled
arrows
represent
stimuli
force
transition
one
state
another
indicate
start
end
states
using
filled
circles
activity
diagrams
Figure
see
system
starts
waiting
state
responds
initially
full
power
half
power
button
Users
change
minds
selecting
one
press
button
time
set
door
closed
Start
button
enabled
Pushing
button
starts
oven
operation
cooking
takes
place
specified
time
end
cooking
cycle
system
returns
waiting
state
problem
state
based
modeling
number
possible
states
increases
rapidly
large
system
models
therefore
need
hide
detail
models
One
way
using
notion
superstate
encapsulates
number
separate
states
superstate
looks
like
single
state
high
level
model
expanded
show
detail
separate
diagram
illustrate
concept
consider
Operation
state
Figure
superstate
expanded
shown
Figure
@@@@@@@@@@
Chapter
System
modeling
State
Description
Waiting
oven
waiting
input
display
shows
current
time
Half
power
oven
power
set
watts
display
shows
Half
power
Full
power
oven
power
set
watts
display
shows
Full
power
Set
time
cooking
time
set
user
s
input
value
display
shows
cooking
time
selected
updated
time
set
Disabled
Oven
operation
disabled
safety
Interior
oven
light
Display
shows
ready
Enabled
Oven
operation
enabled
Interior
oven
light
off
Display
shows
Ready
cook
Operation
Oven
operation
Interior
oven
light
Display
shows
timer
countdown
completion
cooking
buzzer
sounded
seconds
Oven
light
Display
shows
Cooking
complete
buzzer
sounding
Stimulus
Description
Half
power
user
pressed
half
power
button
Figure
States
stimuli
microwave
oven
Full
power
user
pressed
full
power
button
Timer
user
pressed
one
timer
buttons
Number
user
pressed
numeric
key
Door
open
oven
door
switch
closed
Door
closed
oven
door
switch
closed
Start
user
pressed
Start
button
Cancel
user
pressed
Cancel
button
Operation
state
includes
number
substates
shows
operation
starts
status
check
problems
discovered
alarm
indicated
operation
disabled
Cooking
involves
running
microwave
generator
specified
time
completion
buzzer
sounded
door
opened
operation
system
moves
disabled
state
shown
Figure
State
models
system
provide
overview
event
processing
normally
extend
detailed
description
stimuli
system
states
use
table
list
states
events
stimulate
state
transitions
along
description
state
event
Figure
shows
tabular
description
state
stimuli
force
state
transitions
generated
Model
driven
engineering
Model
driven
engineering
MDE
approach
software
development
whereby
models
rather
programs
principal
outputs
development
process
@@@@@@@@@@
Model
driven
architecture
Brambilla
Cabot
Wimmer
programs
execute
hardware
software
platform
generated
automatically
models
Proponents
MDE
argue
raises
level
abstraction
software
engineering
engineers
no
longer
concerned
programming
language
details
specifics
execution
platforms
Model
driven
engineering
developed
idea
model
driven
architecture
MDA
proposed
Object
Management
Group
OMG
new
software
development
paradigm
Mellor
Scott
Weise
MDA
focuses
design
implementation
stages
software
development
MDE
concerned
aspects
software
engineering
process
Therefore
topics
model
based
requirements
engineering
software
processes
model
based
development
model
based
testing
part
MDE
considered
MDA
MDA
approach
system
engineering
adopted
number
large
companies
support
development
processes
section
focuses
use
MDA
software
implementation
rather
discuss
general
aspects
MDE
take
general
model
driven
engineering
slow
companies
adopted
approach
throughout
software
development
life
cycle
blog
den
Haan
discusses
possible
reasons
MDE
widely
adopted
den
Haan
Model
driven
architecture
Model
driven
architecture
Mellor
Scott
Weise
Stahl
Voelter
model
focused
approach
software
design
implementation
uses
subset
UML
models
describe
system
models
different
levels
abstraction
created
high
level
platform
independent
model
possible
principle
generate
working
program
without
manual
intervention
MDA
method
recommends
three
types
abstract
system
model
produced
computation
independent
model
CIM
CIMs
model
important
domain
abstractions
used
system
sometimes
called
domain
models
develop
several
different
CIMs
reflecting
different
views
system
example
security
CIM
identify
important
security
abstractions
asset
role
patient
record
CIM
describe
abstractions
patients
consultations
platform
independent
model
PIM
PIMs
model
operation
system
without
reference
implementation
PIM
usually
described
using
UML
models
show
static
system
structure
responds
external
internal
events
@@@@@@@@@@
Chapter
System
modeling
Platform
specific
model
Platform
independent
model
Executable
code
Computation
independent
model
Figure
MDA
transformations
Translator
Translator
Translator
Platform
Language
Domain
specific
specific
patterns
specific
guidelines
rules
patterns
Platform
specific
models
PSM
PSMs
transformations
platform
independent
model
separate
PSM
application
platform
principle
layers
PSM
layer
adding
platform
specific
detail
first
level
PSM
middleware
specific
database
independent
specific
database
chosen
database
specific
PSM
generated
Model
based
engineering
allows
engineers
think
systems
high
level
abstraction
without
concern
details
implementation
reduces
likelihood
errors
speeds
design
implementation
process
allows
creation
reusable
platform
independent
application
models
using
powerful
tools
system
implementations
generated
different
platforms
model
Therefore
adapt
system
new
platform
technology
write
model
translator
platform
available
platform
independent
models
rapidly
re
hosted
new
platform
Fundamental
MDA
notion
transformations
models
defined
applied
automatically
software
tools
illustrated
Figure
diagram
shows
final
level
automatic
transformation
transformation
applied
PSM
generate
executable
code
run
designated
software
platform
Therefore
principle
least
executable
software
generated
high
level
system
model
practice
completely
automated
translation
models
code
rarely
possible
translation
high
level
CIM
PIM
models
remains
research
problem
production
systems
human
intervention
illustrated
using
stick
figure
Figure
normally
required
particularly
difficult
problem
automated
model
transformation
need
link
concepts
used
different
CIMS
example
concept
role
security
CIM
includes
role
driven
access
control
mapped
onto
concept
staff
member
hospital
CIM
person
understands
security
hospital
environment
make
mapping
@@@@@@@@@@
Model
driven
architecture
Platform
independent
model
Java
program
C
code
generator
Java
code
generator
J
EE
Translator
Net
Translator
C
program
J
EE
specific
model
NET
specific
modelFigure
Multiple
platform
specific
models
translation
platform
independent
platform
specific
models
simpler
technical
problem
Commercial
tools
open
source
tools
Koegel
available
provide
translators
PIMS
common
platforms
Java
J
EE
use
extensive
library
platform
specific
rules
patterns
convert
PIM
PSM
several
PSMs
PIM
system
software
system
intended
run
different
platforms
e
g
J
EE
NET
principle
maintain
single
PIM
PSMs
platform
automatically
generated
Figure
MDA
support
tools
include
platform
specific
translators
sometimes
offer
partial
support
translating
PIMS
PSMs
execution
environment
system
standard
execution
platform
J
EE
Java
includes
application
systems
specific
application
libraries
created
company
external
services
user
interface
libraries
vary
one
company
another
off
shelf
tool
support
available
takes
account
Therefore
MDA
introduced
organization
special
purpose
translators
created
make
use
facilities
available
local
environment
one
reason
many
companies
reluctant
take
model
driven
approaches
development
want
develop
maintain
tools
rely
small
software
companies
go
business
tool
development
Without
specialist
tools
model
based
development
requires
additional
manual
coding
reduces
cost
effectiveness
approach
believe
several
reasons
MDA
mainstream
approach
software
development
Models
good
way
facilitating
discussions
software
design
However
follow
abstractions
useful
discussions
right
abstractions
implementation
decide
use
completely
different
implementation
approach
based
reuse
off
shelf
application
systems
complex
systems
implementation
major
problem
requirements
engineering
security
dependability
integration
legacy
@@@@@@@@@@
Chapter
System
modeling
Executable
UML
fundamental
notion
behind
model
driven
engineering
completely
automated
transformation
models
code
possible
achieve
able
construct
graphical
models
clearly
defined
meanings
compiled
executable
code
need
way
adding
information
graphical
models
ways
operations
defined
model
implemented
possible
using
subset
UML
called
Executable
UML
xUML
Mellor
Balcer
http
software
engineering
book
com
web
xuml
systems
testing
significant
Consequently
gains
use
MDA
limited
arguments
platform
independence
valid
large
long
lifetime
systems
platforms
obsolete
system
s
lifetime
software
products
information
systems
developed
standard
platforms
Windows
Linux
savings
use
MDA
likely
outweighed
costs
introduction
tooling
widespread
adoption
agile
methods
period
MDA
evolving
diverted
attention
away
model
driven
approaches
success
stories
MDA
OMG
mostly
come
companies
developing
systems
products
include
hardware
software
software
products
long
lifetime
modified
reflect
changing
hardware
technologies
domain
application
automotive
air
traffic
control
etc
often
well
understood
formalized
CIM
Hutchinson
colleagues
Hutchinson
Rouncefield
Whittle
report
industrial
use
MDA
work
confirms
successes
use
model
driven
development
systems
products
assessment
suggests
companies
mixed
results
adopting
approach
majority
users
report
using
MDA
increased
productivity
reduced
maintenance
costs
found
MDA
particularly
useful
facilitating
reuse
led
major
productivity
improvements
uneasy
relationship
agile
methods
model
driven
architecture
notion
extensive
front
modeling
contradicts
fundamental
ideas
agile
manifesto
suspect
agile
developers
feel
comfortable
model
driven
engineering
Ambler
pioneer
development
agile
methods
suggests
aspects
MDA
used
agile
processes
Ambler
considers
automated
code
generation
impractical
However
Zhang
Patel
report
Motorola
s
success
using
agile
development
automated
code
generation
Zhang
Patel
@@@@@@@@@@
Chapter
reading
Key
Points
model
abstract
view
system
deliberately
ignores
system
details
Complementary
system
models
developed
show
system
s
context
interactions
structure
behavior
Context
models
show
system
modeled
positioned
environment
systems
processes
help
define
boundaries
system
developed
Use
case
diagrams
sequence
diagrams
used
describe
interactions
users
systems
system
designed
Use
cases
describe
interactions
system
external
actors
sequence
diagrams
add
information
showing
interactions
system
objects
Structural
models
show
organization
architecture
system
Class
diagrams
used
define
static
structure
classes
system
associations
Behavioral
models
used
describe
dynamic
behavior
executing
system
behavior
modeled
perspective
data
processed
system
events
stimulate
responses
system
Activity
diagrams
used
model
processing
data
activity
represents
one
process
step
State
diagrams
used
model
system
s
behavior
response
internal
external
events
Model
driven
engineering
approach
software
development
system
represented
set
models
automatically
transformed
executable
code
readIng
introductory
books
UML
provide
information
notation
cover
UML
changed
slightly
last
years
books
years
old
still
relevant
Using
UML
Software
Engineering
Objects
Components
nd
ed
book
short
readable
introduction
use
UML
system
specification
design
think
excellent
learning
understanding
UML
notation
less
comprehensive
complete
descriptions
UML
found
UML
reference
manual
P
Stevens
R
Pooley
Addison
Wesley
Model
driven
Software
Engineering
Practice
quite
comprehensive
book
model
driven
approaches
focus
model
driven
design
implementation
well
UML
covers
development
domain
specific
modeling
languages
M
Brambilla
J
Cabot
M
Wimmer
Morgan
Claypool
@@@@@@@@@@
Chapter
System
modeling
Website
PowerPoint
slides
chapter
www
pearsonglobaleditions
com
Sommerville
Links
supporting
videos
http
software
engineering
book
com
videos
requirements
design
exercises
Scope
creep
defined
continuous
increase
scope
project
significantly
increase
project
cost
Explain
proper
model
system
context
help
prevent
scope
creeps
way
system
boundary
defined
appropriate
context
model
created
serious
implications
complexity
cost
project
Give
two
examples
applicable
asked
develop
system
help
planning
large
scale
events
parties
weddings
graduation
celebrations
birthday
parties
Using
activity
diagram
model
process
context
system
shows
activities
involved
planning
party
booking
venue
organizing
invitations
etc
system
elements
used
stage
Mentcare
system
propose
set
use
cases
illustrates
interactions
doctor
sees
patients
prescribes
medicine
treatments
Mentcare
system
Develop
sequence
diagram
showing
interactions
involved
student
registers
course
university
Courses
limited
enrollment
registration
process
include
checks
places
available
Assume
student
accesses
electronic
course
catalog
find
available
courses
Look
carefully
messages
mailboxes
represented
email
system
use
Model
object
classes
used
system
implementation
represent
mailbox
email
message
Based
experience
bank
ATM
draw
activity
diagram
models
data
processing
involved
customer
withdraws
cash
machine
Draw
sequence
diagram
system
Explain
want
develop
activity
sequence
diagrams
modeling
behavior
system
Draw
state
diagrams
control
software
automatic
washing
machine
different
programs
different
types
clothes
software
DVD
player
control
software
camera
mobile
phone
Ignore
flash
one
phone
@@@@@@@@@@
Chapter
References
principle
possible
generate
working
programs
high
level
model
without
manual
intervention
using
model
driven
architectures
Discuss
current
challenges
stand
way
existence
completely
automated
translation
tools
reFerenCeS
Ambler
S
W
Object
Primer
Agile
Model
Driven
Development
UML
rd
ed
Cambridge
UK
Cambridge
University
Press
Ambler
S
W
R
Jeffries
Agile
Modeling
Effective
Practices
Extreme
Programming
Unified
Process
New
York
John
Wiley
Sons
Booch
G
J
Rumbaugh
Jacobson
Unified
Modeling
Language
User
Guide
nd
ed
Boston
Addison
Wesley
Brambilla
M
J
Cabot
M
Wimmer
Model
Driven
Software
Engineering
Practice
San
Rafael
CA
Morgan
Claypool
Den
Haan
J
No
Future
Model
Driven
Development
http
www
theenterprisearchitect
eu
archive
no
future
model
drivendevelopment
Erickson
J
K
Siau
Theoretical
Practical
Complexity
Modeling
Methods
Comm
ACM
doi
Harel
D
Statecharts
Visual
Formalism
Complex
Systems
Sci
Comput
Programming
doi
Hull
R
R
King
Semantic
Database
Modeling
Survey
Applications
Research
Issues
ACM
Computing
Surveys
doi
Hutchinson
J
M
Rouncefield
J
Whittle
Model
Driven
Engineering
Practices
Industry
th
Int
Conf
Software
Engineering
doi
Jacobsen
M
Christerson
P
Jonsson
G
Overgaard
Object
Oriented
Software
Engineering
Wokingham
UK
Addison
Wesley
Koegel
M
EMF
Tutorial
Every
Eclipse
Developer
Know
EMF
http
eclipsesource
com
blogs
tutorials
emf
tutorial
Mellor
S
J
M
J
Balcer
Executable
UML
Boston
Addison
Wesley
Mellor
S
J
K
Scott
D
Weise
MDA
Distilled
Principles
Model
Driven
Architecture
Boston
Addison
Wesley
OMG
Model
Driven
Architecture
Success
Stories
http
www
omg
org
mda
products
success
htm
@@@@@@@@@@
Chapter
System
modeling
Rumbaugh
J
Jacobson
G
Booch
Unified
Modelling
Language
Reference
Manual
nd
ed
Boston
Addison
Wesley
Stahl
T
M
Voelter
Model
Driven
Software
Development
Technology
Engineering
Management
New
York
John
Wiley
Sons
Zhang
Y
S
Patel
Agile
Model
Driven
Development
Practice
IEEE
Software
doi
MS
@@@@@@@@@@
Architectural
design
Objectives
objective
chapter
introduce
concepts
software
architecture
architectural
design
read
chapter
understand
architectural
design
software
important
understand
decisions
made
software
architecture
architectural
design
process
introduced
idea
Architectural
patterns
well
tried
ways
organizing
software
architectures
reused
system
designs
understand
Application
Specific
Architectural
patterns
used
transaction
processing
language
processing
systems
Contents
Architectural
design
decisions
Architectural
views
Architectural
patterns
Application
architectures
@@@@@@@@@@
Chapter
Architectural
design
Architectural
design
concerned
understanding
software
system
organized
designing
overall
structure
system
model
software
development
process
described
Chapter
architectural
design
first
stage
software
design
process
critical
link
design
requirements
engineering
identifies
main
structural
components
system
relationships
output
architectural
design
process
architectural
model
describes
system
organized
set
communicating
components
agile
processes
generally
accepted
early
stage
agile
development
process
focus
designing
overall
system
architecture
Incremental
development
architectures
usually
successful
Refactoring
components
response
changes
usually
relatively
easy
However
refactoring
system
architecture
expensive
need
modify
system
components
adapt
architectural
changes
help
understand
mean
system
architecture
look
Figure
diagram
shows
abstract
model
architecture
packing
robot
system
robotic
system
pack
different
kinds
objects
uses
vision
component
pick
objects
conveyor
identify
type
object
select
right
kind
packaging
system
moves
objects
delivery
conveyor
packaged
places
packaged
objects
another
conveyor
architectural
model
shows
components
links
practice
significant
overlap
processes
requirements
engineering
architectural
design
Ideally
system
specification
VisionsystemObjectidentificationsystemPackagingselectionsystemPackingsystemConveyorcontrollerArmcontrollerGrippercontroller
Figure
architecture
packing
robot
control
system
@@@@@@@@@@
Chapter
Architectural
design
include
design
information
ideal
unrealistic
however
except
small
systems
need
identify
main
architectural
components
reflect
high
level
features
system
Therefore
part
requirements
engineering
process
propose
abstract
system
architecture
associate
groups
system
functions
features
large
scale
components
subsystems
use
decomposition
discuss
requirements
detailed
features
system
stakeholders
design
software
architectures
two
levels
abstraction
call
architecture
small
architecture
large
Architecture
small
concerned
architecture
individual
programs
level
concerned
way
individual
program
decomposed
components
chapter
mostly
concerned
program
architectures
Architecture
large
concerned
architecture
complex
enterprise
systems
include
systems
programs
program
components
enterprise
systems
distributed
different
computers
owned
managed
different
companies
cover
architecture
large
Chapters
Software
architecture
important
affects
performance
robustness
distributability
maintainability
system
Bosch
Bosch
explains
individual
components
implement
functional
system
requirements
dominant
influence
non
functional
system
characteristics
system
s
architecture
Chen
et
al
Chen
Ali
Babar
Nuseibeh
confirmed
study
architecturally
significant
requirements
found
non
functional
requirements
significant
effect
system
s
architecture
Bass
et
al
Bass
Clements
Kazman
suggest
explicitly
designing
documenting
software
architecture
three
advantages
Stakeholder
communication
architecture
high
level
presentation
system
used
focus
discussion
range
different
stakeholders
System
analysis
Making
system
architecture
explicit
early
stage
system
development
requires
analysis
Architectural
design
decisions
profound
effect
system
meet
critical
requirements
performance
reliability
maintainability
Large
scale
reuse
architectural
model
compact
manageable
description
system
organized
components
interoperate
system
architecture
often
systems
similar
requirements
support
large
scale
software
reuse
explain
Chapter
product
line
architectures
approach
reuse
architecture
reused
across
range
related
systems
@@@@@@@@@@
Chapter
Architectural
design
System
architectures
often
modeled
informally
using
simple
block
diagrams
Figure
box
diagram
represents
component
Boxes
boxes
indicate
component
decomposed
subcomponents
Arrows
mean
data
control
signals
passed
component
component
direction
arrows
see
many
examples
type
architectural
model
Booch
s
handbook
software
architecture
Booch
Block
diagrams
present
high
level
picture
system
structure
people
different
disciplines
involved
system
development
process
readily
understand
spite
widespread
use
Bass
et
al
Bass
Clements
Kazman
dislike
informal
block
diagrams
describing
architecture
claim
informal
diagrams
poor
architectural
representations
show
type
relationships
among
system
components
components
externally
visible
properties
apparent
contradictions
architectural
theory
industrial
practice
arise
two
ways
architectural
model
program
used
way
encouraging
discussions
system
design
high
level
architectural
view
system
useful
communication
system
stakeholders
project
planning
cluttered
detail
Stakeholders
relate
understand
abstract
view
system
discuss
system
whole
without
confused
detail
architectural
model
identifies
key
components
developed
managers
start
assigning
people
plan
development
systems
way
documenting
architecture
designed
aim
produce
complete
system
model
shows
different
components
system
interfaces
connections
argument
model
detailed
architectural
description
makes
easier
understand
evolve
system
Block
diagrams
good
way
supporting
communications
people
involved
software
design
process
intuitive
domain
experts
software
engineers
relate
participate
discussions
system
Managers
find
helpful
planning
project
many
projects
block
diagrams
architectural
description
Ideally
architecture
system
documented
detail
better
use
rigorous
notation
architectural
description
Various
architectural
description
languages
Bass
Clements
Kazman
developed
purpose
detailed
complete
description
means
less
scope
misunderstanding
relationships
architectural
components
However
developing
detailed
architectural
description
expensive
time
consuming
process
practically
impossible
know
cost
effective
approach
widely
used
@@@@@@@@@@
Architectural
design
decisions
generic
application
architecture
act
template
system
designed
system
distributed
across
hardware
cores
processors
Architectural
patterns
styles
used
fundamental
approach
used
structure
system
structural
components
system
decomposed
sub
components
strategy
used
control
operation
components
system
architectural
organization
best
delivering
non
functional
requirements
system
architecture
system
documented
Figure
Architectural
design
decisions
Architectural
design
decisions
Architectural
design
creative
process
design
system
organization
satisfy
functional
non
functional
requirements
system
no
formulaic
architectural
design
process
depends
type
system
developed
background
experience
system
architect
specific
requirements
system
Consequently
think
best
consider
architectural
design
series
decisions
made
rather
sequence
activities
architectural
design
process
system
architects
make
number
structural
decisions
profoundly
affect
system
development
process
Based
knowledge
experience
consider
fundamental
questions
shown
Figure
software
system
unique
systems
application
domain
often
similar
architectures
reflect
fundamental
concepts
domain
example
application
product
lines
applications
built
around
core
architecture
variants
satisfy
specific
customer
requirements
designing
system
architecture
decide
system
broader
application
classes
common
decide
much
knowledge
application
architectures
reuse
embedded
systems
apps
designed
personal
computers
mobile
devices
design
distributed
architecture
system
However
large
systems
distributed
systems
system
software
distributed
across
many
different
computers
choice
distribution
architecture
@@@@@@@@@@
Chapter
Architectural
design
key
decision
affects
performance
reliability
system
major
topic
right
cover
Chapter
architecture
software
system
based
particular
Architectural
pattern
style
terms
come
mean
thing
Architectural
pattern
description
system
organization
Garlan
Shaw
client
server
organization
layered
architecture
Architectural
patterns
capture
essence
architecture
used
different
software
systems
aware
common
patterns
used
strengths
weaknesses
making
decisions
architecture
system
cover
several
frequently
used
patterns
Section
Garlan
Shaw
s
notion
architectural
style
covers
questions
list
fundamental
architectural
questions
shown
Figure
choose
appropriate
structure
client
server
layered
structuring
enable
meet
system
requirements
decompose
structural
system
units
decide
strategy
decomposing
components
subcomponents
Finally
control
modeling
process
develop
general
model
control
relationships
various
parts
system
make
decisions
execution
components
controlled
close
relationship
non
functional
system
characteristics
software
architecture
choice
architectural
style
structure
depend
non
functional
requirements
system
Performance
performance
critical
requirement
architecture
designed
localize
critical
operations
small
number
components
components
deployed
computer
rather
distributed
across
network
mean
using
relatively
large
components
rather
small
finer
grain
components
Using
large
components
reduces
number
component
communications
interactions
related
system
features
take
place
component
consider
runtime
system
organizations
allow
system
replicated
executed
different
processors
Security
security
critical
requirement
layered
structure
architecture
used
critical
assets
protected
innermost
layers
high
level
security
validation
applied
layers
Safety
safety
critical
requirement
architecture
designed
safety
related
operations
co
located
single
component
small
number
components
reduces
costs
problems
safety
validation
make
possible
provide
related
protection
systems
safely
shut
system
event
failure
Availability
availability
critical
requirement
architecture
designed
include
redundant
components
possible
replace
update
components
without
stopping
system
describe
fault
tolerant
system
architectures
high
availability
systems
Chapter
@@@@@@@@@@
Architectural
views
Maintainability
maintainability
critical
requirement
system
architecture
designed
using
fine
grain
self
contained
components
readily
changed
Producers
data
separated
consumers
shared
data
structures
avoided
Obviously
potential
conflict
architectures
example
using
large
components
improves
performance
using
small
fine
grain
components
improves
maintainability
performance
maintainability
important
system
requirements
however
compromise
found
sometimes
using
different
Architectural
patterns
styles
separate
parts
system
Security
now
critical
requirement
design
architecture
maintains
security
satisfying
non
functional
requirements
Evaluating
architectural
design
difficult
true
test
architecture
well
system
meets
functional
non
functional
requirements
use
However
evaluation
comparing
design
reference
architectures
generic
Architectural
patterns
Bosch
s
description
Bosch
non
functional
characteristics
Architectural
patterns
help
architectural
evaluation
Architectural
views
explained
introduction
chapter
architectural
models
software
system
used
focus
discussion
software
requirements
design
Alternatively
used
document
design
used
basis
detailed
design
implementation
system
section
discuss
two
issues
relevant
views
perspectives
useful
designing
documenting
system
s
architecture
notations
used
describing
architectural
models
impossible
represent
relevant
information
system
s
architecture
single
diagram
graphical
model
show
one
view
perspective
system
show
system
decomposed
modules
runtime
processes
interact
different
ways
system
components
distributed
across
network
useful
different
times
design
documentation
usually
need
present
multiple
views
software
architecture
different
opinions
views
required
Krutchen
Krutchen
well
known
view
model
software
architecture
suggests
@@@@@@@@@@
Chapter
Architectural
design
SystemarchitectureLogicalviewPhysicalviewProcessviewDevelopmentview
Figure
Architectural
views
four
fundamental
architectural
views
linked
common
use
cases
scenarios
Figure
suggests
following
views
logical
view
shows
key
abstractions
system
objects
object
classes
possible
relate
system
requirements
entities
logical
view
process
view
shows
runtime
system
composed
interacting
processes
view
useful
making
judgments
non
functional
system
characteristics
performance
availability
development
view
shows
software
decomposed
development
shows
breakdown
software
components
implemented
single
developer
development
team
view
useful
software
managers
programmers
physical
view
shows
system
hardware
software
components
distributed
across
processors
system
view
useful
systems
engineers
planning
system
deployment
Hofmeister
et
al
Hofmeister
Nord
Soni
suggest
use
similar
views
add
notion
conceptual
view
view
abstract
view
system
basis
decomposing
high
level
requirements
detailed
specifications
help
engineers
make
decisions
components
reused
represent
product
line
discussed
Chapter
rather
single
system
Figure
describes
architecture
packing
robot
example
conceptual
system
view
practice
conceptual
views
system
s
architecture
developed
design
process
used
explain
system
architecture
stakeholders
inform
architectural
decision
making
design
process
views
developed
different
aspects
system
discussed
rarely
necessary
develop
complete
description
perspectives
possible
associate
Architectural
patterns
discussed
next
section
different
views
system
@@@@@@@@@@
Architectural
patterns
differing
views
software
architects
use
UML
describing
documenting
software
architectures
survey
Lange
Chaudron
Muskens
showed
UML
used
mostly
applied
informal
way
authors
paper
argued
bad
thing
disagree
view
UML
designed
describing
object
oriented
systems
architectural
design
stage
often
want
describe
systems
higher
level
abstraction
Object
classes
close
implementation
useful
architectural
description
don
t
find
UML
useful
design
process
prefer
informal
notations
quicker
write
easily
drawn
whiteboard
UML
value
documenting
architecture
detail
using
model
driven
development
discussed
Chapter
number
researchers
Bass
Clements
Kazman
proposed
use
specialized
architectural
description
languages
ADLs
describe
system
architectures
basic
elements
ADLs
components
connectors
include
rules
guidelines
well
formed
architectures
However
ADLs
specialist
languages
domain
application
specialists
find
hard
understand
use
ADLs
value
using
domain
specific
ADLs
part
model
driven
development
think
part
mainstream
software
engineering
practice
Informal
models
notations
UML
remain
commonly
used
ways
documenting
system
architectures
Users
agile
methods
claim
detailed
design
documentation
mostly
unused
therefore
waste
time
money
develop
documents
largely
agree
view
think
except
critical
systems
worth
developing
detailed
architectural
description
Krutchen
s
four
perspectives
develop
views
useful
communication
worry
architectural
documentation
complete
Architectural
patterns
idea
patterns
way
presenting
sharing
reusing
knowledge
software
systems
adopted
number
areas
software
engineering
trigger
publication
book
object
oriented
design
patterns
Gamma
et
al
prompted
development
types
patterns
patterns
organizational
design
Coplien
Harrison
usability
patterns
Usability
Group
patterns
cooperative
interaction
Martin
Sommerville
configuration
management
patterns
Berczuk
Appleton
Architectural
patterns
proposed
s
name
architectural
styles
Shaw
Garlan
detailed
five
volume
series
handbooks
pattern
oriented
software
architecture
published
Buschmann
et
al
Schmidt
et
al
Buschmann
Henney
Schmidt
b
Kircher
Jain
section
introduce
Architectural
patterns
briefly
describe
selection
Architectural
patterns
commonly
used
Patterns
described
standard
way
Figures
using
mixture
narrative
description
diagrams
@@@@@@@@@@
Chapter
Architectural
design
Name
MVC
Model
View
Controller
Figure
Model
View
Controller
MVC
pattern
Figure
organization
Model
View
Controller
Description
Separates
presentation
interaction
system
data
system
structured
three
logical
components
interact
Model
component
manages
system
data
associated
operations
data
View
component
defines
manages
data
presented
user
Controller
component
manages
user
interaction
e
g
key
presses
mouse
clicks
etc
passes
interactions
View
Model
See
Figure
Example
Figure
shows
architecture
web
based
application
system
organized
using
MVC
pattern
used
Used
multiple
ways
view
interact
data
used
future
requirements
interaction
presentation
data
unknown
Advantages
Allows
data
change
independently
representation
vice
versa
Supports
presentation
data
different
ways
changes
made
one
representation
shown
Disadvantages
involve
additional
code
code
complexity
data
model
interactions
simple
detailed
information
patterns
use
refer
published
pattern
handbooks
think
Architectural
pattern
stylized
abstract
description
good
practice
tried
tested
different
systems
environments
Architectural
pattern
describe
system
organization
successful
previous
systems
include
information
appropriate
use
pattern
details
pattern
s
strengths
weaknesses
Figure
describes
well
known
Model
View
Controller
pattern
pattern
basis
interaction
management
many
web
based
systems
supported
language
frameworks
stylized
pattern
description
includes
pattern
Controller
View
View
selection
State
change
Change
notification
State
query
User
events
Maps
user
actions
model
updates
Selects
view
Renders
model
Requests
model
updates
Sends
user
events
controller
Model
Encapsulates
application
state
Notifies
view
state
changes
@@@@@@@@@@
Architectural
patterns
Controller
View
Model
Form
display
Update
request
Change
notification
Refresh
request
User
events
Browser
HTTP
request
processing
Application
specific
logic
Data
validation
Dynamic
page
generation
Forms
management
Business
logic
Database
Figure
Web
application
architecture
using
MVC
pattern
name
brief
description
graphical
model
example
type
system
pattern
used
include
information
pattern
used
advantages
disadvantages
Graphical
models
architecture
associated
MVC
pattern
shown
Figures
present
architecture
different
views
Figure
conceptual
view
Figure
shows
runtime
system
architecture
pattern
used
interaction
management
web
based
system
short
space
impossible
describe
generic
patterns
used
software
development
Instead
present
selected
examples
patterns
widely
used
capture
good
architectural
design
principles
Layered
architecture
notions
separation
independence
fundamental
architectural
design
allow
changes
localized
MVC
pattern
shown
Figure
separates
elements
system
allowing
change
independently
example
adding
new
view
changing
existing
view
done
without
changes
underlying
data
model
Layered
Architecture
pattern
another
way
achieving
separation
independence
pattern
shown
Figure
system
functionality
organized
separate
layers
layer
relies
facilities
services
offered
layer
immediately
beneath
layered
approach
supports
incremental
development
systems
layer
developed
services
provided
layer
made
available
users
architecture
changeable
portable
interface
unchanged
new
layer
extended
functionality
replace
existing
layer
@@@@@@@@@@
Chapter
Architectural
design
Name
Layered
architecture
Description
Organizes
system
layers
related
functionality
associated
layer
layer
provides
services
layer
lowest
level
layers
represent
core
services
likely
used
throughout
system
See
Figure
interact
directly
lower
level
layers
rather
layer
immediately
Performance
problem
multiple
levels
interpretation
service
request
processed
layer
without
changing
parts
system
Furthermore
layer
interfaces
change
new
facilities
added
layer
adjacent
layer
affected
layered
systems
localize
machine
dependencies
makes
easier
provide
multi
platform
implementations
application
system
machine
dependent
layers
need
reimplemented
take
account
facilities
different
operating
system
database
Figure
Layered
Architecture
pattern
Example
layered
model
digital
learning
system
support
learning
subjects
schools
Figure
used
Used
building
new
facilities
top
existing
systems
development
spread
across
several
teams
team
responsibility
layer
functionality
requirement
multilevel
security
Advantages
Allows
replacement
entire
layers
long
interface
maintained
Redundant
facilities
e
g
authentication
provided
layer
increase
dependability
system
Disadvantages
practice
providing
clean
separation
layers
often
difficult
high
level
layer
Figure
example
layered
architecture
four
layers
lowest
layer
includes
system
support
software
typically
database
operating
system
support
next
layer
application
layer
includes
components
concerned
application
functionality
utility
components
used
application
components
third
layer
concerned
user
interface
management
providing
user
authentication
authorization
top
layer
providing
user
interface
facilities
course
number
layers
arbitrary
layers
Figure
split
two
layers
User
interface
User
interface
management
Authentication
authorization
Core
business
logic
application
functionality
System
utilities
System
support
OS
database
etc
Figure
generic
layered
architecture
@@@@@@@@@@
Architectural
patterns
Browser
based
user
interface
iLearn
app
Configuration
services
Group
management
Application
management
Identity
management
Application
services
Email
Messaging
Video
conferencing
Newspaper
archive
Word
processing
Simulation
Video
storage
Resource
finder
Spreadsheet
Virtual
learning
environment
History
archive
Utility
services
Figure
architecture
iLearn
system
Authentication
User
storage
Logging
monitoring
Application
storage
Interfacing
Search
Figure
shows
iLearn
digital
learning
system
introduced
Chapter
four
layer
architecture
follows
pattern
see
another
example
Layered
Architecture
pattern
Figure
Section
shows
organization
Mentcare
system
Repository
architecture
layered
architecture
MVC
patterns
examples
patterns
view
presented
conceptual
organization
system
next
example
Repository
Figure
pattern
Figure
describes
set
interacting
components
share
data
Repository
pattern
Name
Repository
Description
data
system
managed
central
repository
accessible
system
components
Components
interact
directly
repository
Example
Figure
example
IDE
components
use
repository
system
design
information
software
tool
generates
information
available
use
tools
used
use
pattern
system
large
volumes
information
generated
stored
long
time
use
data
driven
systems
inclusion
data
repository
triggers
action
tool
Advantages
Components
independent
need
know
existence
components
Changes
made
one
component
propagated
components
data
managed
consistently
e
g
backups
done
time
one
place
Disadvantages
repository
single
point
failure
problems
repository
affect
whole
system
inefficiencies
organizing
communication
repository
Distributing
repository
across
several
computers
difficult
@@@@@@@@@@
Chapter
Architectural
design
ProjectrepositoryDesigntranslatorJavaeditorUMLeditorsCodegeneratorsDesignanalyzerReportgeneratorPythoneditorFigure
repository
architecture
IDE
majority
systems
use
large
amounts
data
organized
around
shared
database
repository
model
therefore
suited
applications
data
generated
one
component
used
another
Examples
type
system
include
command
control
systems
management
information
systems
Computer
Aided
Design
CAD
systems
interactive
development
environments
software
Figure
illustrates
situation
repository
used
diagram
shows
IDE
includes
different
tools
support
model
driven
development
repository
case
version
controlled
environment
discussed
Chapter
keeps
track
changes
software
allows
rollback
earlier
versions
Organizing
tools
around
repository
efficient
way
sharing
large
amounts
data
no
need
transmit
data
explicitly
one
component
another
However
components
operate
around
agreed
repository
data
model
Inevitably
compromise
specific
needs
tool
difficult
impossible
integrate
new
components
data
models
fit
agreed
schema
practice
difficult
distribute
repository
number
machines
possible
distribute
logically
centralized
repository
involves
maintaining
multiple
copies
data
Keeping
consistent
date
adds
overhead
system
repository
architecture
shown
Figure
repository
passive
control
responsibility
components
using
repository
alternative
approach
derived
artificial
intelligence
AI
systems
uses
blackboard
model
triggers
components
particular
data
available
appropriate
data
repository
unstructured
Decisions
tool
activated
made
data
analyzed
model
introduced
Nii
Nii
Bosch
Bosch
includes
good
discussion
style
relates
system
quality
attributes
Client
server
architecture
Repository
pattern
concerned
static
structure
system
show
runtime
organization
next
example
Client
Server
pattern
Figure
illustrates
commonly
used
runtime
organization
distributed
@@@@@@@@@@
Architectural
patterns
Name
Client
server
Description
client
server
architecture
system
presented
set
services
service
delivered
separate
server
Clients
users
services
access
servers
make
use
server
failure
Performance
unpredictable
depends
network
well
system
Management
problems
arise
servers
owned
different
organizations
systems
system
follows
Client
Server
pattern
organized
set
services
associated
servers
clients
access
use
services
major
components
model
Figure
Client
Server
pattern
Example
Figure
example
film
video
DVD
library
organized
client
server
system
used
Used
data
shared
database
accessed
range
locations
servers
replicated
used
load
system
variable
Advantages
principal
advantage
model
servers
distributed
across
network
General
functionality
e
g
printing
service
available
clients
need
implemented
services
Disadvantages
service
single
point
failure
susceptible
denial
service
attacks
set
servers
offer
services
components
Examples
servers
include
print
servers
offer
printing
services
file
servers
offer
file
management
services
compile
server
offers
programming
language
compilation
services
Servers
software
components
several
servers
run
computer
set
clients
call
services
offered
servers
normally
several
instances
client
program
executing
concurrently
different
computers
network
allows
clients
access
services
Client
server
systems
usually
implemented
distributed
systems
connected
using
Internet
protocols
Client
server
architectures
usually
thought
distributed
systems
architectures
logical
model
independent
services
running
separate
servers
implemented
single
computer
important
benefit
separation
independence
Services
servers
changed
without
affecting
parts
system
Clients
know
names
available
servers
services
provide
However
servers
need
know
identity
clients
many
clients
accessing
services
Clients
access
services
provided
server
remote
procedure
calls
using
request
reply
protocol
http
client
makes
request
server
waits
receives
reply
server
@@@@@@@@@@
Chapter
Architectural
design
Catalog
server
Library
catalogue
Video
server
Film
store
Picture
server
Photo
store
Web
server
Film
photo
info
Client
Client
Client
Client
Internet
Figure
client
server
architecture
film
library
Figure
example
system
based
client
server
model
multiuser
web
based
system
providing
film
photograph
library
system
several
servers
manage
display
different
types
media
Video
frames
need
transmitted
quickly
synchrony
relatively
low
resolution
compressed
store
video
server
handle
video
compression
decompression
different
formats
Still
pictures
however
maintained
high
resolution
appropriate
maintain
separate
server
catalog
able
deal
variety
queries
provide
links
web
information
system
include
data
film
video
clips
e
commerce
system
supports
sale
photographs
film
video
clips
client
program
simply
integrated
user
interface
constructed
using
web
browser
access
services
important
advantage
client
server
model
distributed
architecture
Effective
use
made
networked
systems
many
distributed
processors
easy
add
new
server
integrate
rest
system
upgrade
servers
transparently
without
affecting
parts
system
cover
distributed
architectures
Chapter
explain
client
server
model
variants
detail
Pipe
filter
architecture
final
example
general
Architectural
pattern
Pipe
Filter
pattern
Figure
model
runtime
organization
system
functional
transformations
process
inputs
produce
outputs
Data
flows
one
another
transformed
moves
sequence
processing
step
implemented
transform
Input
data
flows
transforms
converted
output
transformations
execute
sequentially
parallel
data
processed
transform
item
item
single
batch
@@@@@@@@@@
Architectural
patterns
Name
Pipe
filter
Description
processing
data
system
organized
processing
component
filter
discrete
carries
one
type
data
transformation
data
flows
pipe
one
component
another
processing
Example
Figure
example
pipe
filter
system
used
processing
invoices
used
Commonly
used
data
processing
applications
batch
transaction
based
inputs
processed
separate
stages
generate
related
outputs
Advantages
Easy
understand
supports
transformation
reuse
Workflow
style
matches
structure
many
business
processes
Evolution
adding
transformations
straightforward
implemented
sequential
concurrent
system
Disadvantages
format
data
transfer
agreed
communicating
transformations
transformation
parse
input
unparse
output
agreed
form
increases
system
overhead
mean
impossible
reuse
architectural
components
use
incompatible
data
structures
Figure
Pipe
Filter
pattern
Figure
example
pipe
filter
architecture
name
pipe
filter
comes
original
Unix
system
possible
link
processes
using
pipes
passed
text
stream
one
process
another
Systems
conform
model
implemented
combining
Unix
commands
using
pipes
control
facilities
Unix
shell
term
filter
used
transformation
filters
data
process
input
data
stream
Variants
pattern
use
since
computers
first
used
automatic
data
processing
transformations
sequential
data
processed
batches
pipe
filter
architectural
model
becomes
batch
sequential
model
common
architecture
data
processing
systems
billing
systems
architecture
embedded
system
organized
process
pipeline
process
executing
concurrently
cover
use
pattern
embedded
systems
Chapter
example
type
system
architecture
used
batch
processing
application
shown
Figure
organization
issued
invoices
customers
week
payments
made
reconciled
invoices
Issue
receipts
Find
payments
due
Receipts
Issue
payment
reminder
Reminders
Read
issued
invoices
Identify
payments
Invoices
Payments
@@@@@@@@@@
Chapter
Architectural
design
Architectural
patterns
control
specific
Architectural
patterns
reflect
commonly
used
ways
organizing
control
system
include
centralized
control
based
one
component
calling
components
event
based
control
system
reacts
external
events
http
software
engineering
book
com
web
archpatterns
invoices
paid
receipt
issued
invoices
paid
allowed
payment
time
reminder
issued
Pipe
filter
systems
best
suited
batch
processing
systems
embedded
systems
limited
user
interaction
Interactive
systems
difficult
write
using
pipe
filter
model
need
stream
data
processed
simple
textual
input
output
modeled
way
graphical
user
interfaces
complex
O
formats
control
strategy
based
events
mouse
clicks
menu
selections
difficult
implement
sequential
stream
conforms
pipe
filter
model
Application
architectures
Application
systems
intended
meet
business
organizational
need
businesses
much
common
need
hire
people
issue
invoices
keep
accounts
Businesses
operating
sector
use
common
sector
specific
applications
Therefore
well
general
business
functions
phone
companies
need
systems
connect
meter
calls
manage
network
issue
bills
customers
Consequently
application
systems
used
businesses
much
common
commonalities
led
development
software
architectures
describe
structure
organization
particular
types
software
systems
Application
architectures
encapsulate
principal
characteristics
class
systems
example
real
time
systems
generic
architectural
models
different
system
types
data
collection
systems
monitoring
systems
instances
systems
differ
detail
common
architectural
structure
reused
developing
new
systems
type
application
architecture
reimplemented
developing
new
systems
However
many
business
systems
application
architecture
reuse
implicit
generic
application
systems
configured
create
new
application
see
widespread
use
Enterprise
Resource
Planning
ERP
systems
off
shelf
configurable
application
systems
systems
accounting
stock
control
systems
standard
architecture
components
components
configured
adapted
create
specific
business
application
@@@@@@@@@@
Application
architectures
Application
architectures
several
examples
application
architectures
book
s
website
include
descriptions
batch
data
processing
systems
resource
allocation
systems
event
based
editing
systems
http
software
engineering
book
com
web
apparch
example
system
supply
chain
management
adapted
different
types
suppliers
goods
contractual
arrangements
software
designer
use
models
application
architectures
number
ways
starting
point
architectural
design
process
unfamiliar
type
application
developing
base
initial
design
generic
application
architecture
specialize
specific
system
developed
design
checklist
developed
architectural
design
application
system
compare
generic
application
architecture
check
design
consistent
generic
architecture
way
organizing
work
development
team
application
architectures
identify
stable
structural
features
system
architectures
many
cases
possible
develop
parallel
assign
work
group
members
implement
different
components
architecture
means
assessing
components
reuse
components
able
reuse
compare
generic
structures
see
comparable
components
application
architecture
vocabulary
talking
applications
discussing
specific
application
trying
compare
applications
use
concepts
identified
generic
architecture
talk
applications
many
types
application
system
cases
seem
different
However
superficially
dissimilar
applications
much
common
thus
share
abstract
application
architecture
illustrate
describing
architectures
two
types
application
Transaction
processing
applications
Transaction
processing
applications
database
centered
applications
process
user
requests
information
update
information
database
common
types
interactive
business
systems
organized
way
user
actions
t
interfere
integrity
database
maintained
class
system
includes
interactive
banking
systems
e
commerce
systems
information
systems
booking
systems
@@@@@@@@@@
Chapter
Architectural
design
Figure
structure
transaction
processing
applications
O
processing
ApplicationlogicTransactionmanager
Database
Language
processing
systems
Language
processing
systems
systems
user
s
intentions
expressed
formal
language
programming
language
language
processing
system
processes
language
internal
format
interprets
internal
representation
best
known
language
processing
systems
compilers
translate
high
level
language
programs
machine
code
However
language
processing
systems
used
interpret
command
languages
databases
information
systems
markup
languages
XML
chosen
particular
types
system
large
number
web
based
business
systems
transaction
processing
systems
software
development
relies
language
processing
systems
Transaction
processing
systems
Transaction
processing
systems
designed
process
user
requests
information
database
requests
update
database
Lewis
Bernstein
Kifer
Technically
database
transaction
part
sequence
operations
treated
single
unit
atomic
unit
operations
transaction
completed
database
changes
made
permanent
ensures
failure
operations
transaction
lead
inconsistencies
database
user
perspective
transaction
coherent
sequence
operations
satisfies
goal
find
times
flights
London
Paris
user
transaction
require
database
changed
necessary
package
technical
database
transaction
example
database
transaction
customer
request
withdraw
money
bank
account
using
ATM
involves
checking
customer
account
balance
see
sufficient
funds
available
modifying
balance
amount
withdrawn
sending
commands
ATM
deliver
cash
steps
completed
transaction
incomplete
customer
accounts
database
changed
Transaction
processing
systems
usually
interactive
systems
users
make
asynchronous
requests
service
Figure
illustrates
conceptual
architectural
structure
transaction
processing
applications
First
user
makes
request
system
O
processing
component
request
processed
application
specific
logic
transaction
created
passed
transaction
manager
usually
embedded
database
management
system
transaction
manager
ensured
transaction
properly
completed
signals
application
processing
finished
Transaction
processing
systems
organized
pipe
filter
architecture
system
components
responsible
input
processing
output
@@@@@@@@@@
Application
architectures
Input
Process
Output
Get
customer
account
id
Query
account
Print
details
Return
card
Dispense
cash
Update
account
Validate
card
Select
service
ATM
Figure
software
architecture
ATM
system
Database
ATM
example
consider
banking
system
allows
customers
query
accounts
withdraw
cash
ATM
system
composed
two
cooperating
software
components
ATM
software
account
processing
software
bank
s
database
server
input
output
components
implemented
software
ATM
processing
component
part
bank
s
database
server
Figure
shows
architecture
system
illustrating
functions
input
process
output
components
Information
systems
systems
involve
interaction
shared
database
considered
transaction
based
information
systems
information
system
allows
controlled
access
large
base
information
library
catalog
flight
timetable
records
patients
hospital
Information
systems
web
based
systems
user
interface
implemented
web
browser
Figure
presents
general
model
information
system
system
modeled
using
layered
approach
discussed
Section
top
layer
User
interface
Authentication
andUser
communications
authorization
Information
retrieval
modification
Transaction
management
Database
Figure
Layered
information
system
architecture
@@@@@@@@@@
Chapter
Architectural
design
Web
browser
Form
menu
Login
Role
checking
manager
Data
validation
Security
Patient
info
Data
import
management
manager
export
Report
generation
Transaction
management
Patient
database
Figure
architecture
Mentcare
system
supports
user
interface
bottom
layer
system
database
user
communications
layer
handles
input
output
user
interface
information
retrieval
layer
includes
application
specific
logic
accessing
updating
database
layers
model
map
directly
onto
servers
distributed
Internet
based
system
example
instantiation
layered
model
Figure
shows
architecture
Mentcare
system
Recall
system
maintains
manages
details
patients
consulting
specialist
doctors
mental
health
problems
added
detail
layer
model
identifying
components
support
user
communications
information
retrieval
access
top
layer
browser
based
user
interface
second
layer
provides
user
interface
functionality
delivered
web
browser
includes
components
allow
users
log
system
checking
components
ensure
operations
use
allowed
role
layer
includes
form
menu
management
components
present
information
users
data
validation
components
check
information
consistency
third
layer
implements
functionality
system
provides
components
implement
system
security
patient
information
creation
updating
import
export
patient
data
databases
report
generators
create
management
reports
Finally
lowest
layer
built
using
commercial
database
management
system
provides
transaction
management
persistent
data
storage
Information
resource
management
systems
sometimes
transaction
processing
systems
example
e
commerce
systems
Internet
based
resource
management
systems
accept
electronic
orders
goods
services
arrange
delivery
goods
services
customer
e
commerce
@@@@@@@@@@
Application
architectures
Source
language
instructions
Translator
Check
syntax
Check
semantics
Generate
Abstract
m
c
instructions
Interpreter
Figure
Data
Fetch
Results
architecture
Execute
language
processing
system
system
application
specific
layer
includes
additional
functionality
supporting
shopping
cart
users
place
number
items
separate
transactions
pay
together
single
transaction
organization
servers
systems
usually
reflects
four
layer
generic
model
presented
Figure
systems
often
implemented
distributed
systems
multitier
client
server
architecture
web
server
responsible
user
communications
user
interface
implemented
using
web
browser
application
server
responsible
implementing
application
specific
logic
well
information
storage
retrieval
requests
database
server
moves
information
database
handles
transaction
management
Using
multiple
servers
allows
high
throughput
makes
possible
handle
thousands
transactions
per
minute
demand
increases
servers
added
level
cope
extra
processing
involved
Language
processing
systems
Language
processing
systems
translate
one
language
alternative
representation
language
programming
languages
execute
resulting
code
Compilers
translate
programming
language
machine
code
language
processing
systems
translate
XML
data
description
commands
query
database
alternative
XML
representation
Natural
language
processing
systems
translate
one
natural
language
another
example
French
Norwegian
possible
architecture
language
processing
system
programming
language
illustrated
Figure
source
language
instructions
define
@@@@@@@@@@
Chapter
Architectural
design
Figure
repository
architecture
language
Repository
processing
system
Formatter
Editor
Code
generator
program
executed
translator
converts
instructions
abstract
machine
instructions
interpreted
another
component
fetches
instructions
execution
executes
using
necessary
data
environment
output
process
result
interpreting
instructions
input
data
many
compilers
interpreter
system
hardware
processes
machine
instructions
abstract
machine
real
processor
However
dynamically
typed
languages
Ruby
Python
interpreter
software
component
Programming
language
compilers
part
general
program
ming
environment
generic
architecture
Figure
includes
fol
lowing
components
lexical
analyzer
takes
input
language
tokens
converts
internal
form
symbol
table
holds
information
names
entities
variables
class
names
object
names
etc
used
text
translated
syntax
analyzer
checks
syntax
language
translated
uses
defined
grammar
language
builds
syntax
tree
syntax
tree
internal
structure
representing
program
compiled
semantic
analyzer
uses
information
syntax
tree
symbol
table
check
semantic
correctness
input
language
text
code
generator
walks
syntax
tree
generates
abstract
machine
code
components
included
analyze
transform
syntax
tree
improve
efficiency
remove
redundancy
generated
machine
code
Syntax
analyzer
Lexical
analyzer
Semantic
analyzer
Abstract
syntax
tree
Grammar
definition
Symbol
table
Output
definition
Optimizer
@@@@@@@@@@
Application
architectures
Reference
architectures
Reference
architectures
capture
important
features
system
architectures
domain
Essentially
include
everything
application
architecture
reality
unlikely
individual
application
include
features
shown
reference
architecture
main
purpose
reference
architectures
evaluate
compare
design
proposals
educate
people
architectural
characteristics
domain
http
software
engineering
book
com
web
refarch
types
language
processing
system
natural
language
translator
additional
components
dictionary
output
system
translation
input
text
Figure
illustrates
language
processing
system
part
integrated
set
programming
support
tools
example
symbol
table
syntax
tree
act
central
information
repository
Tools
tool
fragments
communicate
information
sometimes
embedded
tools
grammar
definition
definition
output
format
program
taken
tools
put
repository
Therefore
syntax
directed
editor
check
syntax
program
correct
typed
program
formatter
create
listings
program
highlight
different
syntactic
elements
therefore
easier
read
understand
Alternative
Architectural
patterns
used
language
processing
system
Garlan
Shaw
Compilers
implemented
using
composite
repository
pipe
filter
model
compiler
architecture
symbol
table
repository
shared
data
phases
lexical
syntactic
semantic
analysis
organized
sequentially
shown
Figure
communicate
shared
symbol
table
pipe
filter
model
language
compilation
effective
batch
environments
programs
compiled
executed
without
user
interaction
example
translation
one
XML
document
another
less
effective
compiler
integrated
language
processing
tools
structured
editing
system
interactive
debugger
program
formatter
situation
changes
one
component
need
reflected
immediately
components
better
organize
system
around
repository
shown
Figure
implementing
general
language
oriented
programming
environment
Lexical
analysis
Syntactic
analysis
Semantic
analysis
Code
generation
Symbol
table
Syntax
tree
Figure
pipe
filter
compiler
architecture
@@@@@@@@@@
Chapter
Architectural
design
Key
Points
software
architecture
description
software
system
organized
Properties
system
performance
security
availability
influenced
architecture
used
Architectural
design
decisions
include
decisions
type
application
distribution
system
architectural
styles
used
ways
architecture
documented
evaluated
Architectures
documented
several
different
perspectives
views
Possible
views
include
conceptual
view
logical
view
process
view
development
view
physical
view
Architectural
patterns
means
reusing
knowledge
generic
system
architectures
describe
architecture
explain
used
point
advantages
disadvantages
Commonly
used
Architectural
patterns
include
model
view
controller
layered
architecture
repository
client
server
pipe
filter
Generic
models
application
systems
architectures
help
us
understand
operation
applications
compare
applications
type
validate
application
system
designs
assess
large
scale
components
reuse
Transaction
processing
systems
interactive
systems
allow
information
database
remotely
accessed
modified
number
users
Information
systems
resource
management
systems
examples
transaction
processing
systems
Language
processing
systems
used
translate
texts
one
language
another
carry
instructions
specified
input
language
include
translator
abstract
machine
executes
generated
language
reAding
Software
Architecture
Perspectives
Emerging
Discipline
first
book
software
architecture
good
discussion
different
architectural
styles
still
relevant
M
Shaw
D
Garlan
Prentice
Hall
Golden
Age
Software
Architecture
paper
surveys
development
software
architecture
beginnings
s
usage
st
century
lot
technical
content
interesting
historical
overview
M
Shaw
P
Clements
IEEE
Software
March
April
http
doi
dx
org
MS
Software
Architecture
Practice
rd
ed
practical
discussion
software
architectures
oversell
benefits
architectural
design
provides
clear
business
rationale
explaining
architectures
important
L
Bass
P
Clements
R
Kazman
Addison
Wesley
@@@@@@@@@@
Chapter
Exercises
Handbook
Software
Architecture
work
progress
Grady
Booch
one
early
evangelists
software
architecture
documenting
architectures
range
software
systems
see
reality
rather
academic
abstraction
Available
web
intended
appear
book
G
Booch
http
www
handbookofsoftwarearchitecture
com
Website
PowerPoint
slides
chapter
www
pearsonglobaleditions
com
Sommerville
Links
supporting
videos
http
software
engineering
book
com
videos
requirements
design
exercises
describing
system
explain
start
design
system
architecture
requirements
specification
complete
asked
prepare
deliver
presentation
nontechnical
manager
justify
hiring
system
architect
new
project
Write
list
bullet
points
setting
key
points
presentation
explain
importance
software
architecture
Performance
security
pose
conflicting
non
functional
requirements
architecting
software
systems
Make
argument
support
statement
Draw
diagrams
showing
conceptual
view
process
view
architectures
following
systems
ticket
machine
used
passengers
railway
station
computer
controlled
video
conferencing
system
allows
video
audio
computer
data
visible
several
participants
time
robot
floor
cleaner
intended
clean
relatively
clear
spaces
corridors
cleaner
able
sense
walls
obstructions
software
system
built
allow
drones
autonomously
herd
cattle
farms
drones
remotely
controlled
human
operators
Explain
multiple
architectural
patterns
fit
together
help
build
kind
system
Suggest
architecture
system
iTunes
used
sell
distribute
music
Internet
Architectural
patterns
basis
proposed
architecture
information
system
developed
maintain
information
assets
owned
utility
company
buildings
vehicles
equipment
intended
@@@@@@@@@@
Chapter
Architectural
design
updatable
staff
working
field
using
mobile
devices
new
asset
information
becomes
available
company
several
existing
asset
databases
integrated
system
Design
layered
architecture
asset
management
system
based
generic
information
system
architecture
shown
Figure
Using
generic
model
language
processing
system
presented
design
architecture
system
accepts
natural
language
commands
translates
database
queries
language
SQL
Using
basic
model
information
system
presented
Figure
suggest
components
part
information
system
allows
users
view
box
office
events
available
tickets
prices
eventually
buy
tickets
separate
profession
software
architect
role
work
independently
customer
design
software
system
architecture
separate
software
company
implement
system
difficulties
establishing
profession
reFerenCes
Bass
L
P
Clements
R
Kazman
Software
Architecture
Practice
rd
ed
Boston
Addison
Wesley
Berczuk
S
P
B
Appleton
Software
Configuration
Management
Patterns
Effective
Teamwork
Practical
Integration
Boston
Addison
Wesley
Booch
G
Handbook
Software
Architecture
http
handbookofsoftwarearchitecture
com
Bosch
J
Design
Use
Software
Architectures
Harlow
UK
Addison
Wesley
Buschmann
F
K
Henney
D
C
Schmidt
Pattern
Oriented
Software
Architecture
Volume
Pattern
Language
Distributed
Computing
New
York
John
Wiley
Sons
b
Pattern
Oriented
Software
Architecture
Volume
Patterns
Pattern
Languages
New
York
John
Wiley
Sons
Buschmann
F
R
Meunier
H
Rohnert
P
Sommerlad
Pattern
Oriented
Software
Architecture
Volume
System
Patterns
New
York
John
Wiley
Sons
Chen
L
M
Ali
Babar
B
Nuseibeh
Characterizing
Architecturally
Significant
Requirements
IEEE
Software
doi
MS
Coplien
J
O
N
B
Harrison
Organizational
Patterns
Agile
Software
Development
Englewood
Cliffs
NJ
Prentice
Hall
Gamma
E
R
Helm
R
Johnson
J
Vlissides
Design
Patterns
Elements
Reusable
Object
Oriented
Software
Reading
MA
Addison
Wesley
@@@@@@@@@@
Chapter
References
Garlan
D
M
Shaw
Introduction
Software
Architecture
Advances
Software
Engineering
Knowledge
Engineering
edited
V
Ambriola
G
Tortora
London
World
Scientific
Publishing
Co
Hofmeister
C
R
Nord
D
Soni
Applied
Software
Architecture
Boston
Addison
Wesley
Kircher
M
P
Jain
Pattern
Oriented
Software
Architecture
Volume
Patterns
Resource
Management
New
York
John
Wiley
Sons
Krutchen
P
View
Model
Software
Architecture
IEEE
Software
doi
Lange
C
F
J
M
R
V
Chaudron
J
Muskens
UML
Software
Architecture
Design
Description
IEEE
Software
doi
MS
Lewis
P
M
J
Bernstein
M
Kifer
Databases
Transaction
Processing
Application
Oriented
Approach
Boston
Addison
Wesley
Martin
D
Sommerville
Patterns
Cooperative
Interaction
Linking
Ethnomethodology
Design
ACM
Transactions
Computer
Human
Interaction
March
doi
Nii
H
P
Blackboard
Systems
Parts
AI
Magazine
http
www
aaai
org
ojs
index
php
aimagazine
article
view
Schmidt
D
M
Stal
H
Rohnert
F
Buschmann
Pattern
Oriented
Software
Architecture
Volume
Patterns
Concurrent
Networked
Objects
New
York
John
Wiley
Sons
Shaw
M
D
Garlan
Software
Architecture
Perspectives
Emerging
Discipline
Englewood
Cliffs
NJ
Prentice
Hall
Usability
Group
Usability
Patterns
University
Brighton
http
www
bton
ac
uk
Research
patterns
home
html
@@@@@@@@@@
Design
implementation
Objectives
objectives
chapter
introduce
object
oriented
software
design
using
UML
highlight
important
implementation
concerns
read
chapter
understand
important
activities
general
object
oriented
design
process
understand
different
models
used
document
object
oriented
design
know
idea
design
patterns
way
reusing
design
knowledge
experience
introduced
key
issues
considered
implementing
software
including
software
reuse
open
source
development
Contents
Object
oriented
design
using
UML
Design
patterns
Implementation
issues
Open
source
development
@@@@@@@@@@
Chapter
Design
implementation
Software
design
implementation
stage
software
engineering
process
executable
software
system
developed
simple
systems
software
engineering
means
software
design
implementation
software
engineering
activities
merged
process
However
large
systems
software
design
implementation
one
number
software
engineering
processes
requirements
engineering
verification
validation
etc
Software
design
implementation
activities
invariably
interleaved
Software
design
creative
activity
identify
software
components
relationships
based
customer
s
requirements
Implementation
process
realizing
design
program
Sometimes
separate
design
stage
design
modeled
documented
times
design
programmer
s
head
roughly
sketched
whiteboard
sheets
paper
Design
solve
problem
design
process
However
isn
t
necessary
appropriate
describe
design
detail
using
UML
design
description
language
Design
implementation
closely
linked
normally
take
implementation
issues
account
developing
design
example
using
UML
document
design
right
thing
programming
object
oriented
language
Java
C
less
useful
think
developing
using
dynamically
typed
language
like
Python
no
point
using
UML
implementing
system
configuring
off
shelf
package
discussed
Chapter
agile
methods
usually
work
informal
sketches
design
leave
design
decisions
programmers
One
important
implementation
decisions
made
early
stage
software
project
build
buy
application
software
many
types
application
now
possible
buy
off
shelf
application
systems
adapted
tailored
users
requirements
example
want
implement
medical
records
system
buy
package
already
used
hospitals
usually
cheaper
faster
use
approach
rather
developing
new
system
conventional
programming
language
develop
application
system
reusing
off
shelf
product
design
process
focuses
configure
system
product
meet
application
requirements
don
t
develop
design
models
system
models
system
objects
interactions
discuss
reuse
based
approach
development
Chapter
assume
readers
book
experience
program
design
implementation
something
acquire
learn
program
master
elements
programming
language
like
Java
Python
probably
learned
good
programming
practice
programming
languages
studied
well
debug
programs
developed
Therefore
don
t
cover
programming
topics
Instead
chapter
two
aims
show
system
modeling
architectural
design
covered
Chapters
put
practice
developing
object
oriented
software
design
@@@@@@@@@@
Chapter
Design
implementation
introduce
important
implementation
issues
usually
covered
programming
books
include
software
reuse
configuration
management
open
source
development
vast
number
different
development
platforms
chapter
biased
toward
particular
programming
language
implementation
technology
Therefore
presented
examples
using
UML
rather
programming
language
Java
Python
Object
oriented
design
using
UML
object
oriented
system
made
interacting
objects
maintain
local
state
provide
operations
state
representation
state
private
cannot
accessed
directly
outside
object
Object
oriented
design
processes
involve
designing
object
classes
relationships
classes
classes
define
objects
system
interactions
design
realized
executing
program
objects
created
dynamically
class
definitions
Objects
include
data
operations
manipulate
data
therefore
understood
modified
stand
alone
entities
Changing
implementation
object
adding
services
affect
system
objects
objects
associated
things
often
clear
mapping
real
world
entities
hardware
components
controlling
objects
system
improves
understandability
maintainability
design
develop
system
design
concept
detailed
object
oriented
design
need
Understand
define
context
external
interactions
system
Design
system
architecture
Identify
principal
objects
system
Develop
design
models
Specify
interfaces
Like
creative
activities
design
clear
cut
sequential
process
develop
design
getting
ideas
proposing
solutions
refining
solutions
information
becomes
available
inevitably
backtrack
retry
problems
arise
Sometimes
explore
options
detail
see
work
times
ignore
details
late
process
Sometimes
use
notations
UML
precisely
clarify
aspects
design
times
notations
used
informally
stimulate
discussions
explain
object
oriented
software
design
developing
design
part
embedded
software
wilderness
weather
station
introduced
Chapter
Wilderness
weather
stations
deployed
remote
areas
weather
station
@@@@@@@@@@
Object
oriented
design
using
UML
Control
system
n
Weatherinformationsystem
n
Weatherstation
n
Figure
System
context
Satellite
weather
station
records
local
weather
information
periodically
transfers
weather
information
system
using
satellite
link
System
context
interactions
first
stage
software
design
process
develop
understanding
relationships
software
designed
external
environment
essential
deciding
provide
required
system
functionality
structure
system
communicate
environment
discussed
Chapter
understanding
context
lets
establish
boundaries
system
Setting
system
boundaries
helps
decide
features
implemented
system
designed
features
associated
systems
case
need
decide
functionality
distributed
control
system
weather
stations
embedded
software
weather
station
System
context
models
interaction
models
present
complementary
views
relationships
system
environment
system
context
model
structural
model
demonstrates
systems
environment
system
developed
interaction
model
dynamic
model
shows
system
interacts
environment
used
context
model
system
represented
using
associations
Associations
simply
show
relationships
entities
involved
association
document
environment
system
using
simple
block
diagram
showing
entities
system
associations
Figure
shows
systems
environment
weather
station
weather
information
system
onboard
satellite
system
control
system
cardinality
information
link
shows
single
control
system
several
weather
stations
one
satellite
one
general
weather
information
system
model
interactions
system
environment
use
abstract
approach
include
much
detail
One
way
use
use
case
model
discussed
Chapters
use
case
represents
@@@@@@@@@@
Chapter
Design
implementation
Weather
station
use
cases
Report
weather
send
weather
data
weather
information
system
Report
status
send
status
information
weather
information
system
Restart
weather
station
shut
restart
system
Shutdown
shut
weather
station
Reconfigure
reconfigure
weather
station
software
Powersave
put
weather
station
power
saving
mode
Remote
control
send
control
commands
weather
station
subsystem
http
software
engineering
book
com
web
ws
use
cases
interaction
system
possible
interaction
named
ellipse
external
entity
involved
interaction
represented
stick
figure
use
case
model
weather
station
shown
Figure
shows
weather
station
interacts
weather
information
system
report
weather
data
status
weather
station
hardware
interactions
control
system
issue
specific
weather
station
control
commands
stick
figure
used
UML
represent
systems
well
human
users
use
cases
described
structured
natural
language
helps
designers
identify
objects
system
gives
understanding
system
intended
use
standard
format
description
clearly
identifies
information
exchanged
interaction
initiated
explain
Chapter
embedded
systems
often
modeled
describing
Shutdown
Report
weather
Restart
Report
status
Reconfigure
Weather
information
system
Control
system
Powersave
Remote
control
Figure
Weather
station
use
cases
@@@@@@@@@@
Object
oriented
design
using
UML
System
Weather
station
Use
case
Report
weather
Actors
Weather
information
system
Weather
station
Data
weather
station
sends
summary
weather
data
collected
instruments
collection
period
weather
information
system
data
sent
maximum
minimum
average
ground
air
temperatures
maximum
minimum
average
air
pressures
maximum
minimum
average
wind
speeds
total
rainfall
wind
direction
sampled
minute
intervals
Stimulus
weather
information
system
establishes
satellite
communication
link
weather
station
requests
transmission
data
Response
summarized
data
sent
weather
information
system
Comments
Weather
stations
usually
asked
report
per
hour
frequency
differ
one
station
another
modified
future
Figure
Use
case
description
Report
weather
respond
internal
external
stimuli
Therefore
stimuli
associated
responses
listed
description
Figure
shows
description
Report
weather
use
case
Figure
based
approach
Architectural
design
interactions
software
system
system
s
environment
defined
use
information
basis
designing
system
architecture
course
need
combine
knowledge
general
knowledge
principles
architectural
design
detailed
domain
knowledge
identify
major
components
make
system
interactions
design
system
organization
using
architectural
pattern
layered
client
server
model
high
level
architectural
design
weather
station
software
shown
Figure
weather
station
composed
independent
subsystems
communicate
subsystem
Data
collection
subsystem
Communications
subsystem
Configuration
manager
subsystem
Fault
manager
subsystem
Power
manager
subsystem
Instruments
Communication
link
Figure
High
level
architecture
weather
station
@@@@@@@@@@
Chapter
Design
implementation
Figure
Architecture
data
collection
system
Data
collection
Transmitter
Receiver
WeatherData
broadcasting
messages
common
infrastructure
shown
Communication
link
Figure
subsystem
listens
messages
infrastructure
picks
messages
intended
listener
model
commonly
used
architectural
style
distributed
systems
communications
subsystem
receives
control
command
shutdown
command
picked
subsystems
shut
correct
way
key
benefit
architecture
easy
support
different
configurations
subsystems
sender
message
need
address
message
particular
subsystem
Figure
shows
architecture
data
collection
subsystem
included
Figure
Transmitter
Receiver
objects
concerned
managing
communications
WeatherData
object
encapsulates
information
collected
instruments
transmitted
weather
information
system
arrangement
follows
producer
consumer
pattern
discussed
Chapter
Object
class
identification
stage
design
process
ideas
essential
objects
system
designing
understanding
design
develops
refine
ideas
system
objects
use
case
description
helps
identify
objects
operations
system
description
Report
weather
use
case
obvious
need
implement
objects
representing
instruments
collect
weather
data
object
representing
summary
weather
data
usually
need
high
level
system
object
objects
encapsulate
system
interactions
defined
use
cases
objects
mind
start
identify
general
object
classes
system
object
oriented
design
evolved
s
various
ways
identifying
object
classes
object
oriented
systems
suggested
Use
grammatical
analysis
natural
language
description
system
constructed
Objects
attributes
nouns
operations
services
verbs
Abbott
Use
tangible
entities
things
application
domain
aircraft
roles
manager
events
request
interactions
meetings
locations
@@@@@@@@@@
Object
oriented
design
using
UML
WeatherStation
identifier
reportWeather
reportStatus
powerSave
instruments
remoteControl
commands
reconfigure
commands
restart
instruments
shutdown
instruments
WeatherData
airTemperatures
groundTemperatures
windSpeeds
windDirections
pressures
rainfall
collect
summarize
Ground
thermometer
gt
Ident
temperature
get
test
Anemometer
Ident
windSpeed
windDirection
get
test
Barometer
bar
Ident
pressure
height
get
test
Figure
Weather
station
objects
offices
organizational
units
companies
Wirfs
Brock
Wilkerson
Weiner
Use
scenario
based
analysis
various
scenarios
system
use
identified
analyzed
turn
scenario
analyzed
team
responsible
analysis
identify
required
objects
attributes
operations
Beck
Cunningham
practice
use
several
knowledge
sources
discover
object
classes
Object
classes
attributes
operations
initially
identified
informal
system
description
starting
point
design
Information
application
domain
knowledge
scenario
analysis
used
refine
extend
initial
objects
information
collected
requirements
documents
discussions
users
analyses
existing
systems
well
objects
representing
entities
external
system
design
implementation
objects
used
provide
general
services
searching
validity
checking
wilderness
weather
station
object
identification
based
tangible
hardware
system
don
t
space
include
system
objects
shown
five
object
classes
Figure
Ground
thermometer
Anemometer
Barometer
objects
application
domain
objects
WeatherStation
WeatherData
objects
identified
system
description
scenario
use
case
description
WeatherStation
object
class
provides
basic
interface
weather
station
environment
operations
based
interactions
shown
Figure
use
single
object
class
includes
interactions
Alternatively
design
system
interface
several
different
classes
one
class
per
interaction
@@@@@@@@@@
Chapter
Design
implementation
WeatherData
object
class
responsible
processing
report
weather
command
sends
summarized
data
weather
station
instruments
weather
information
system
Ground
thermometer
Anemometer
Barometer
object
classes
directly
related
instruments
system
reflect
tangible
hardware
entities
system
operations
concerned
controlling
hardware
objects
operate
autonomously
collect
data
specified
frequency
store
collected
data
locally
data
delivered
WeatherData
object
request
use
knowledge
application
domain
identify
objects
attributes
services
Weather
stations
often
located
remote
places
include
various
instruments
sometimes
go
wrong
Instrument
failures
reported
automatically
implies
need
attributes
operations
check
correct
functioning
instruments
many
remote
weather
stations
weather
station
identifier
uniquely
identified
communications
weather
stations
installed
different
times
types
instrument
different
Therefore
instrument
uniquely
identified
database
instrument
information
maintained
stage
design
process
focus
objects
without
thinking
objects
implemented
identified
objects
refine
object
design
look
common
features
design
inheritance
hierarchy
system
example
identify
Instrument
superclass
defines
common
features
instruments
identifier
get
test
operations
add
new
attributes
operations
superclass
attribute
records
often
data
collected
Design
models
Design
system
models
discussed
Chapter
show
objects
object
classes
system
show
associations
relationships
entities
models
bridge
system
requirements
implementation
system
abstract
unnecessary
detail
doesn
t
hide
relationships
system
requirements
However
include
enough
detail
programmers
make
implementation
decisions
level
detail
need
design
model
depends
design
process
used
close
links
requirements
engineers
designers
programmers
abstract
models
required
Specific
design
decisions
made
system
implemented
problems
resolved
informal
discussions
Similarly
agile
development
used
outline
design
models
whiteboard
required
@@@@@@@@@@
Object
oriented
design
using
UML
However
plan
based
development
process
used
need
detailed
models
links
requirements
engineers
designers
programmers
indirect
e
g
system
designed
one
part
organization
implemented
elsewhere
precise
design
descriptions
needed
communication
Detailed
models
derived
high
level
abstract
models
used
team
members
common
understanding
design
important
step
design
process
therefore
decide
design
models
need
level
detail
required
models
depends
type
system
developed
sequential
data
processing
system
quite
different
embedded
real
time
system
need
use
different
types
design
models
UML
supports
different
types
models
discussed
Chapter
many
models
widely
used
Minimizing
number
models
produced
reduces
costs
design
time
required
complete
design
process
use
UML
develop
design
develop
two
kinds
design
model
Structural
models
describe
static
structure
system
using
object
classes
relationships
Important
relationships
documented
stage
generalization
inheritance
relationships
uses
used
relationships
composition
relationships
Dynamic
models
describe
dynamic
structure
system
show
expected
runtime
interactions
system
objects
Interactions
documented
include
sequence
service
requests
made
objects
state
changes
triggered
object
interactions
think
three
UML
model
types
particularly
useful
adding
detail
use
case
architectural
models
Subsystem
models
show
logical
groupings
objects
coherent
subsystems
represented
using
form
class
diagram
subsystem
shown
package
enclosed
objects
Subsystem
models
structural
models
Sequence
models
show
sequence
object
interactions
represented
using
UML
sequence
collaboration
diagram
Sequence
models
dynamic
models
State
machine
models
show
objects
change
state
response
events
represented
UML
using
state
diagrams
State
machine
models
dynamic
models
subsystem
model
useful
static
model
shows
design
organized
logically
related
groups
objects
already
shown
type
model
Figure
present
subsystems
weather
mapping
system
well
subsystem
models
design
detailed
object
models
showing
objects
systems
associations
inheritance
generalization
aggregation
etc
However
danger
@@@@@@@@@@
Chapter
Design
implementation
Weather
SatComms
request
report
acknowledge
reportWeather
get
summary
reply
report
acknowledge
WeatherStation
Commslink
summarize
WeatherData
acknowledge
send
report
acknowledge
information
system
Figure
Sequence
diagram
describing
much
modeling
make
detailed
decisions
impledata
collection
mentation
really
best
left
system
implemented
Sequence
models
dynamic
models
describe
mode
interaction
sequence
object
interactions
take
place
documenting
design
produce
sequence
model
significant
interaction
developed
use
case
model
sequence
model
use
case
identified
Figure
example
sequence
model
shown
UML
sequence
diagram
diagram
shows
sequence
interactions
take
place
external
system
requests
summarized
data
weather
station
read
sequence
diagrams
top
bottom
SatComms
object
receives
request
weather
information
system
collect
weather
report
weather
station
acknowledges
receipt
request
stick
arrowhead
sent
message
indicates
external
system
wait
reply
carry
processing
SatComms
sends
message
WeatherStation
via
satellite
link
create
summary
collected
weather
data
stick
arrowhead
indicates
SatComms
suspend
waiting
reply
WeatherStation
sends
message
Commslink
object
summarize
weather
data
case
squared
off
style
arrowhead
indicates
instance
WeatherStation
object
class
waits
reply
Commslink
calls
summarize
method
object
WeatherData
waits
reply
@@@@@@@@@@
Object
oriented
design
using
UML
transmission
done
remoteControl
reportStatus
restart
shutdown
test
complete
weather
summary
complete
clock
collection
done
OperationreportWeather
Shutdown
Running
Testing
Transmitting
Collecting
Summarizing
Controlled
Configuring
reconfigure
configuration
done
powerSave
Figure
Weather
weather
data
summary
computed
returned
WeatherStation
via
station
state
diagram
Commslink
object
WeatherStation
calls
SatComms
object
transmit
summarized
data
weather
information
system
satellite
communications
system
SatComms
WeatherStation
objects
implemented
concurrent
processes
execution
suspended
resumed
SatComms
object
instance
listens
messages
external
system
decodes
messages
initiates
weather
station
operations
Sequence
diagrams
used
model
combined
behavior
group
objects
want
summarize
behavior
object
subsystem
response
messages
events
use
state
machine
model
shows
object
instance
changes
state
depending
messages
receives
discuss
Chapter
UML
includes
state
diagrams
describe
state
machine
models
Figure
state
diagram
weather
station
system
shows
responds
requests
various
services
read
diagram
follows
system
state
Shutdown
respond
restart
reconfigure
powerSave
message
unlabeled
arrow
black
blob
indicates
Shutdown
state
initial
state
restart
message
causes
transition
normal
operation
powerSave
reconfigure
messages
cause
transition
state
system
reconfigures
state
diagram
shows
reconfiguration
allowed
system
shut
@@@@@@@@@@
Chapter
Design
implementation
Running
state
system
expects
messages
shutdown
message
received
object
returns
shutdown
state
reportWeather
message
received
system
moves
Summarizing
state
summary
complete
system
moves
Transmitting
state
information
transmitted
remote
system
returns
Running
state
signal
clock
received
system
moves
Collecting
state
collects
data
instruments
instrument
instructed
turn
collect
data
associated
sensors
remoteControl
message
received
system
moves
controlled
state
responds
different
set
messages
remote
control
room
shown
diagram
State
diagrams
useful
high
level
models
system
object
s
operation
However
don
t
need
state
diagram
objects
system
Many
system
objects
system
simple
operation
easily
described
without
state
model
Interface
specification
important
part
design
process
specification
interfaces
components
design
need
specify
interfaces
objects
subsystems
designed
parallel
interface
specified
developers
objects
assume
interface
implemented
Interface
design
concerned
specifying
detail
interface
object
group
objects
means
defining
signatures
semantics
services
provided
object
group
objects
Interfaces
specified
UML
using
notation
class
diagram
However
no
attribute
section
UML
stereotype
interface
included
name
part
semantics
interface
defined
using
object
constraint
language
OCL
discuss
use
OCL
Chapter
explain
used
describe
semantics
components
include
details
data
representation
interface
design
attributes
defined
interface
specification
However
include
operations
access
update
data
data
representation
hidden
easily
changed
without
affecting
objects
use
data
leads
design
inherently
maintainable
example
array
representation
stack
changed
list
representation
without
affecting
objects
use
stack
contrast
normally
expose
attributes
object
model
clearest
way
describing
essential
characteristics
objects
simple
relationship
objects
interfaces
object
several
interfaces
viewpoint
methods
provides
supported
directly
Java
interfaces
declared
separately
objects
objects
implement
interfaces
Equally
group
objects
accessed
single
interface
@@@@@@@@@@
Design
patterns
Figure
Weather
station
interfaces
interface
Reporting
weatherReport
WS
Ident
Wreport
statusReport
WS
Ident
Sreport
interface
Remote
Control
startInstrument
instrument
iStatus
stopInstrument
instrument
iStatus
collectData
instrument
iStatus
provideData
instrument
string
Figure
shows
two
interfaces
defined
weather
station
left
hand
interface
reporting
interface
defines
operation
names
used
generate
weather
status
reports
map
directly
operations
WeatherStation
object
remote
control
interface
provides
four
operations
map
onto
single
method
WeatherStation
object
case
individual
operations
encoded
command
string
associated
remoteControl
method
shown
Figure
Design
patterns
Design
patterns
derived
ideas
put
forward
Christopher
Alexander
Alexander
suggested
certain
common
patterns
building
design
inherently
pleasing
effective
pattern
description
problem
essence
solution
solution
reused
different
settings
pattern
detailed
specification
Rather
think
description
accumulated
wisdom
experience
well
tried
solution
common
problem
quote
Hillside
Group
website
hillside
net
patterns
dedicated
maintaining
information
patterns
encapsulates
role
reuse
Patterns
Pattern
Languages
ways
describe
best
practices
good
designs
capture
experience
way
possible
others
reuse
experience
Patterns
made
huge
impact
object
oriented
software
design
well
tested
solutions
common
problems
vocabulary
talking
design
therefore
explain
design
describing
patterns
used
particularly
true
best
known
design
patterns
originally
described
Gang
Four
patterns
book
published
Gamma
et
al
important
pattern
descriptions
published
series
books
authors
Siemens
large
European
technology
company
Buschmann
et
al
Schmidt
et
al
Kircher
Jain
Buschmann
Henney
Schmidt
b
Patterns
way
reusing
knowledge
experience
designers
Design
patterns
usually
associated
object
oriented
design
Published
patterns
often
rely
object
characteristics
inheritance
polymorphism
provide
generality
However
general
principle
encapsulating
experience
pattern
HIllside
Group
hillside
net
patterns
@@@@@@@@@@
Chapter
Design
implementation
Pattern
name
Observer
Description
Separates
display
state
object
object
allows
alternative
displays
provided
object
state
changes
displays
automatically
notified
updated
reflect
change
Problem
description
many
situations
provide
multiple
displays
state
information
graphical
display
tabular
display
known
information
specified
alternative
presentations
support
interaction
state
changed
displays
updated
pattern
used
situations
one
display
format
state
information
required
necessary
object
maintains
state
information
know
specific
display
formats
used
Solution
description
involves
two
abstract
objects
Subject
Observer
two
concrete
objects
ConcreteSubject
ConcreteObject
inherit
attributes
related
abstract
objects
abstract
objects
include
general
operations
applicable
situations
state
displayed
maintained
ConcreteSubject
inherits
operations
Subject
allowing
add
remove
Observers
observer
corresponds
display
issue
notification
state
changed
ConcreteObserver
maintains
copy
state
ConcreteSubject
implements
Update
interface
Observer
allows
copies
kept
step
ConcreteObserver
automatically
displays
state
reflects
changes
state
updated
UML
model
pattern
shown
Figure
Consequences
subject
knows
abstract
Observer
know
details
concrete
class
Therefore
minimal
coupling
objects
lack
knowledge
optimizations
enhance
display
performance
impractical
Changes
subject
cause
set
linked
updates
observers
generated
necessary
one
equally
applicable
kind
software
design
instance
Figure
Observer
pattern
configuration
patterns
instantiating
reusable
application
systems
Gang
Four
defined
four
essential
elements
design
patterns
book
patterns
name
meaningful
reference
pattern
description
problem
area
explains
pattern
applied
solution
description
parts
design
solution
relationships
responsibilities
concrete
design
description
template
design
solution
instantiated
different
ways
often
expressed
graphically
shows
relationships
objects
object
classes
solution
statement
consequences
results
trade
offs
applying
pattern
help
designers
understand
pattern
used
particular
situation
Gamma
co
authors
break
problem
description
motivation
description
pattern
useful
applicability
description
situations
pattern
used
description
solution
describe
pattern
structure
participants
collaborations
implementation
illustrate
pattern
description
use
Observer
pattern
taken
Gang
Four
s
patterns
book
shown
Figure
description
use
@@@@@@@@@@
Design
patterns
B
C
D
Observer
B
C
D
Observer
Subject
AB
C
D
Figure
Multiple
displays
four
essential
description
elements
include
brief
statement
pattern
pattern
used
situations
different
presentations
object
s
state
required
separates
object
displayed
different
forms
presentation
illustrated
Figure
shows
two
different
graphical
presentations
dataset
Graphical
representations
normally
used
illustrate
object
classes
patterns
relationships
supplement
pattern
description
add
detail
solution
description
Figure
representation
UML
Observer
pattern
use
patterns
design
need
recognize
design
problem
facing
associated
pattern
applied
Examples
problems
documented
Gang
Four
s
original
patterns
book
include
Tell
several
objects
state
object
changed
Observer
pattern
Tidy
interfaces
number
related
objects
often
devel
Figure
UML
oped
incrementally
Fa
ade
pattern
model
Observer
pattern
Subject
Observer
Attach
Observer
Detach
Observer
Notify
Update
ConcreteSubject
GetState
subjectState
ConcreteObserver
Update
observerState
observerState
subject
GetState
return
subjectState
o
observers
o
Update
@@@@@@@@@@
Chapter
Design
implementation
Provide
standard
way
accessing
elements
collection
irrespective
collection
implemented
Iterator
pattern
Allow
possibility
extending
functionality
existing
class
runtime
Decorator
pattern
Patterns
support
high
level
concept
reuse
try
reuse
executable
components
inevitably
constrained
detailed
design
decisions
made
implementers
components
range
particular
algorithms
used
implement
components
objects
types
component
interfaces
design
decisions
conflict
requirements
reusing
component
impossible
introduces
inefficiencies
system
Using
patterns
means
reuse
ideas
adapt
implementation
suit
system
developing
start
designing
system
difficult
know
advance
need
particular
pattern
Therefore
using
patterns
design
process
often
involves
developing
design
experiencing
problem
recognizing
pattern
used
certainly
possible
focus
general
purpose
patterns
documented
original
patterns
book
However
problem
different
one
find
difficult
find
appropriate
pattern
among
hundreds
different
patterns
proposed
Patterns
great
idea
need
experience
software
design
use
effectively
recognize
situations
pattern
applied
Inexperienced
programmers
even
read
pattern
books
find
hard
decide
reuse
pattern
need
develop
special
purpose
solution
Implementation
issues
Software
engineering
includes
activities
involved
software
development
initial
requirements
system
maintenance
management
deployed
system
critical
stage
process
course
system
implementation
create
executable
version
software
Implementation
involve
developing
programs
high
low
level
programming
languages
tailoring
adapting
generic
off
shelf
systems
meet
specific
requirements
organization
assume
readers
book
understand
programming
principles
programming
experience
chapter
intended
offer
language
independent
approach
haven
t
focused
issues
good
programming
practice
language
specific
examples
need
used
Instead
introduce
aspects
implementation
particularly
important
software
engineering
often
covered
programming
texts
Reuse
modern
software
constructed
reusing
existing
components
systems
developing
software
make
much
use
possible
existing
code
@@@@@@@@@@
Implementation
issues
System
Figure
Software
reuse
Software
reuse
Abstraction
Architectural
design
patterns
Application
systems
COTS
Component
Component
frameworks
Object
Programming
language
libraries
Configuration
management
development
process
many
different
versions
software
component
created
don
t
keep
track
versions
configuration
management
system
liable
include
wrong
versions
components
system
Host
target
development
Production
software
usually
execute
computer
software
development
environment
Rather
develop
one
computer
host
system
execute
separate
computer
target
system
host
target
systems
sometimes
type
often
completely
different
Reuse
s
s
new
software
developed
scratch
writing
code
high
level
programming
language
significant
reuse
software
reuse
functions
objects
programming
language
libraries
However
costs
schedule
pressure
meant
approach
increasingly
unviable
especially
commercial
Internet
based
systems
Consequently
approach
development
based
reuse
existing
software
now
norm
many
types
system
development
reuse
based
approach
now
widely
used
web
based
systems
kinds
scientific
software
increasingly
embedded
systems
engineering
Software
reuse
possible
number
different
levels
shown
Figure
abstraction
level
level
don
t
reuse
software
directly
rather
use
knowledge
successful
abstractions
design
software
Design
patterns
architectural
patterns
covered
Chapter
ways
representing
abstract
knowledge
reuse
@@@@@@@@@@
Chapter
Design
implementation
object
level
level
directly
reuse
objects
library
rather
writing
code
implement
type
reuse
find
appropriate
libraries
discover
objects
methods
offer
functionality
need
example
need
process
email
messages
Java
program
use
objects
methods
JavaMail
library
component
level
Components
collections
objects
object
classes
operate
together
provide
related
functions
services
often
adapt
extend
component
adding
code
example
component
level
reuse
build
user
interface
using
framework
set
general
object
classes
implement
event
handling
display
management
etc
add
connections
data
displayed
write
code
define
specific
display
details
screen
layout
colors
system
level
level
reuse
entire
application
systems
function
usually
involves
kind
configuration
systems
done
adding
modifying
code
reusing
software
product
line
using
system
s
configuration
interface
commercial
systems
now
built
way
generic
application
systems
systems
adapted
reused
Sometimes
approach
involve
integrating
several
application
systems
create
new
system
reusing
existing
software
develop
new
systems
quickly
fewer
development
risks
lower
cost
reused
software
tested
applications
reliable
new
software
However
costs
associated
reuse
costs
time
spent
looking
software
reuse
assessing
meets
needs
test
software
make
sure
work
environment
especially
different
development
environment
applicable
costs
buying
reusable
software
large
off
theshelf
systems
costs
high
costs
adapting
configuring
reusable
software
components
systems
reflect
requirements
system
developing
costs
integrating
reusable
software
elements
using
software
different
sources
new
code
developed
Integrating
reusable
software
different
providers
difficult
expensive
providers
make
conflicting
assumptions
respective
software
reused
reuse
existing
knowledge
software
first
thing
think
starting
software
development
project
consider
@@@@@@@@@@
Implementation
issues
ComponentversionsReleasemanagementChangeproposalsSystemreleasesChangemanagementSystemversionsVersionmanagementSystembuildingFigure
Configuration
management
possibilities
reuse
designing
software
detail
wish
adapt
design
reuse
existing
software
assets
discussed
Chapter
reuse
oriented
development
process
search
reusable
elements
modify
requirements
design
make
best
use
importance
reuse
modern
software
engineering
devote
several
chapters
Part
book
topic
Chapters
Configuration
management
software
development
change
happens
time
change
management
absolutely
essential
several
people
involved
developing
software
system
make
sure
team
members
don
t
interfere
s
work
two
people
working
component
changes
coordinated
Otherwise
one
programmer
make
changes
overwrite
s
work
ensure
everyone
access
date
versions
software
components
otherwise
developers
redo
work
already
done
something
goes
wrong
new
version
system
able
go
back
working
version
system
component
Configuration
management
name
given
general
process
managing
changing
software
system
aim
configuration
management
support
system
integration
process
developers
access
project
code
documents
controlled
way
find
changes
made
compile
link
components
create
system
shown
Figure
four
fundamental
configuration
management
activities
Version
management
support
provided
keep
track
different
versions
software
components
Version
management
systems
include
facilities
coordinate
development
several
programmers
stop
one
developer
overwriting
code
submitted
system
someone
System
integration
support
provided
help
developers
define
versions
components
used
create
version
system
@@@@@@@@@@
Chapter
Design
implementation
Host
Target
Development
Execution
platform
platform
Download
software
IDE
Libraries
Compilers
Related
systems
Testing
tools
Databases
Figure
Host
target
development
description
used
build
system
automatically
compiling
linking
required
components
Problem
tracking
support
provided
allow
users
report
bugs
problems
allow
developers
see
working
problems
fixed
Release
management
new
versions
software
system
released
customers
Release
management
concerned
planning
functionality
new
releases
organizing
software
distribution
Software
configuration
management
tools
support
activities
tools
usually
installed
integrated
development
environment
Eclipse
Version
management
supported
using
version
management
system
Subversion
Pilato
Collins
Sussman
Fitzpatrick
Git
Loeliger
McCullough
support
multi
site
multi
team
development
System
integration
support
built
language
rely
separate
tool
set
GNU
build
system
Bug
tracking
issue
tracking
systems
Bugzilla
used
report
bugs
issues
keep
track
fixed
comprehensive
set
tools
built
around
Git
system
available
Github
http
github
com
importance
professional
software
engineering
discuss
change
configuration
management
detail
Chapter
Host
target
development
professional
software
development
based
host
target
model
Figure
Software
developed
one
computer
host
runs
separate
machine
target
generally
talk
development
platform
host
execution
platform
target
platform
hardware
includes
installed
operating
system
plus
supporting
software
database
management
system
development
platforms
interactive
development
environment
@@@@@@@@@@
Implementation
issues
Sometimes
development
platform
execution
platform
making
possible
develop
software
test
machine
Therefore
develop
Java
target
environment
Java
Virtual
Machine
principle
every
computer
programs
portable
one
machine
another
However
particularly
embedded
systems
mobile
systems
development
execution
platforms
different
need
move
developed
software
execution
platform
testing
run
simulator
development
machine
Simulators
often
used
developing
embedded
systems
simulate
hardware
devices
sensors
events
environment
system
deployed
Simulators
speed
development
process
embedded
systems
developer
execution
platform
no
need
download
software
target
hardware
However
simulators
expensive
develop
usually
available
popular
hardware
architectures
target
system
installed
middleware
software
need
use
need
able
test
system
using
software
impractical
install
software
development
machine
even
target
platform
license
restrictions
case
need
transfer
developed
code
execution
platform
test
system
software
development
platform
provide
range
tools
support
software
engineering
processes
include
integrated
compiler
syntax
directed
editing
system
allows
create
edit
compile
code
language
debugging
system
Graphical
editing
tools
tools
edit
UML
models
Testing
tools
JUnit
automatically
run
set
tests
new
version
program
Tools
support
refactoring
program
visualization
Configuration
management
tools
manage
source
code
versions
integrate
build
systems
addition
standard
tools
development
system
include
specialized
tools
static
analyzers
discussed
Chapter
Normally
development
environments
teams
include
shared
server
runs
change
configuration
management
system
perhaps
system
support
requirements
management
Software
development
tools
now
usually
installed
integrated
development
environment
IDE
IDE
set
software
tools
supports
different
aspects
software
development
common
framework
user
interface
Generally
IDEs
created
support
development
specific
programming
@@@@@@@@@@
Chapter
Design
implementation
UML
deployment
diagrams
UML
deployment
diagrams
show
software
components
physically
deployed
processors
deployment
diagram
shows
hardware
software
system
middleware
used
connect
different
components
system
Essentially
think
deployment
diagrams
way
defining
documenting
target
environment
http
software
engineering
book
com
web
deployment
language
Java
language
IDE
developed
specially
instantiation
general
purpose
IDE
specific
language
support
tools
general
purpose
IDE
framework
hosting
software
tools
provides
data
management
facilities
software
developed
integration
mechanisms
allow
tools
work
together
best
known
general
purpose
IDE
Eclipse
environment
http
www
eclipse
org
environment
based
plug
architecture
specialized
different
languages
Java
application
domains
Therefore
install
Eclipse
tailor
specific
needs
adding
plug
ins
example
add
set
plug
ins
support
networked
systems
development
Java
Vogel
embedded
systems
engineering
using
C
part
development
process
need
make
decisions
developed
software
deployed
target
platform
straightforward
embedded
systems
target
usually
single
computer
However
distributed
systems
need
decide
specific
platforms
components
deployed
Issues
consider
making
decision
hardware
software
requirements
component
component
designed
specific
hardware
architecture
relies
software
system
obviously
deployed
platform
provides
required
hardware
software
support
availability
requirements
system
High
availability
systems
require
components
deployed
one
platform
means
event
platform
failure
alternative
implementation
component
available
Component
communications
lot
intercomponent
communication
usually
best
deploy
platform
platforms
physically
close
one
another
reduces
communications
latency
delay
time
message
sent
one
component
received
another
document
decisions
hardware
software
deployment
using
UML
deployment
diagrams
show
software
components
distributed
across
hardware
platforms
developing
embedded
system
take
account
target
characteristics
physical
size
power
capabilities
need
real
time
responses
sensor
events
physical
characteristics
actuators
real
time
operating
system
discuss
embedded
systems
engineering
Chapter
@@@@@@@@@@
Open
source
development
Open
source
development
Open
source
development
approach
software
development
source
code
software
system
published
volunteers
invited
participate
development
process
Raymond
roots
Free
Software
Foundation
www
fsf
org
advocates
source
code
proprietary
rather
available
users
examine
modify
wish
assumption
code
controlled
developed
small
core
group
rather
users
code
Open
source
software
extended
idea
using
Internet
recruit
much
larger
population
volunteer
developers
Many
users
code
principle
least
contributor
open
source
project
report
fix
bugs
propose
new
features
functionality
However
practice
successful
open
source
systems
still
rely
core
group
developers
control
changes
software
Open
source
software
backbone
Internet
software
engineering
Linux
operating
system
widely
used
server
system
open
source
Apache
web
server
important
universally
used
open
source
products
Java
Eclipse
IDE
mySQL
database
management
system
Android
operating
system
installed
millions
mobile
devices
Major
players
computer
industry
IBM
Oracle
support
open
source
movement
base
software
open
source
products
Thousands
lesser
known
open
source
systems
components
used
usually
cheap
even
free
acquire
open
source
software
normally
download
open
source
software
without
charge
However
want
documentation
support
pay
costs
usually
fairly
low
key
benefit
using
open
source
products
widely
used
open
source
systems
reliable
large
population
users
willing
fix
problems
rather
report
problems
developer
wait
new
release
system
Bugs
discovered
repaired
quickly
usually
possible
proprietary
software
company
involved
software
development
two
open
source
issues
considered
product
developed
make
use
open
source
components
open
source
approach
used
software
development
answers
questions
depend
type
software
developed
background
experience
development
team
developing
software
product
sale
time
market
reduced
costs
critical
developing
software
domain
high
quality
open
source
systems
available
save
time
money
using
systems
However
developing
software
specific
set
organizational
requirements
using
open
source
components
option
integrate
software
existing
systems
incompatible
available
@@@@@@@@@@
Chapter
Design
implementation
open
source
systems
Even
however
quicker
cheaper
modify
open
source
system
rather
redevelop
functionality
need
Many
software
product
companies
now
using
open
source
approach
development
especially
specialized
systems
business
model
reliant
selling
software
product
rather
selling
support
product
believe
involving
open
source
community
allow
software
developed
cheaply
quickly
create
community
users
software
companies
believe
adopting
open
source
approach
reveal
confidential
business
knowledge
competitors
reluctant
adopt
development
model
However
working
small
company
open
source
software
reassure
customers
able
support
software
company
goes
business
Publishing
source
code
system
mean
people
wider
community
necessarily
help
development
successful
open
source
products
platform
products
rather
application
systems
limited
number
developers
interested
specialized
application
systems
Making
software
system
open
source
guarantee
community
involvement
thousands
open
source
projects
Sourceforge
GitHub
handful
downloads
However
users
software
concerns
availability
future
making
software
open
source
means
take
copy
reassured
lose
access
Open
source
licensing
fundamental
principle
open
source
development
source
code
freely
available
mean
anyone
wish
code
Legally
developer
code
company
individual
owns
code
place
restrictions
used
including
legally
binding
conditions
open
source
software
license
St
Laurent
open
source
developers
believe
open
source
component
used
develop
new
system
system
open
source
Others
willing
allow
code
used
without
restriction
developed
systems
proprietary
sold
closed
source
systems
open
source
licenses
Chapman
variants
one
three
general
models
GNU
General
Public
License
GPL
called
reciprocal
license
simplistically
means
use
open
source
software
licensed
GPL
license
make
software
open
source
GNU
Lesser
General
Public
License
LGPL
variant
GPL
license
write
components
link
open
source
code
without
publish
source
components
However
change
licensed
component
publish
open
source
Berkley
Standard
Distribution
BSD
License
nonreciprocal
license
means
obliged
re
publish
changes
modifications
made
@@@@@@@@@@
Open
source
development
open
source
code
include
code
proprietary
systems
sold
use
open
source
components
acknowledge
original
creator
code
MIT
license
variant
BSD
license
similar
conditions
Licensing
issues
important
use
open
source
software
part
software
product
obliged
terms
license
make
product
open
source
trying
sell
software
wish
keep
secret
means
wish
avoid
using
GPL
licensed
open
source
software
development
building
software
runs
open
source
platform
reuse
open
source
components
licenses
problem
However
embed
open
source
software
software
need
processes
databases
keep
track
s
used
license
conditions
Bayersdorfer
Bayersdorfer
suggests
companies
managing
projects
use
open
source
Establish
system
maintaining
information
open
source
components
downloaded
used
keep
copy
license
component
valid
time
component
used
Licenses
change
need
know
conditions
agreed
aware
different
types
licenses
understand
component
licensed
used
decide
use
component
one
system
another
plan
use
systems
different
ways
aware
evolution
pathways
components
need
know
bit
open
source
project
components
developed
understand
change
future
Educate
people
open
source
s
enough
procedures
place
ensure
compliance
license
conditions
need
educate
developers
open
source
open
source
licensing
auditing
systems
place
Developers
tight
deadlines
tempted
break
terms
license
possible
software
place
detect
stop
Participate
open
source
community
rely
open
source
products
participate
community
help
support
development
open
source
approach
one
several
business
models
software
model
companies
release
source
software
sell
add
services
advice
association
sell
cloud
based
software
services
attractive
option
users
expertise
manage
open
source
system
specialized
versions
system
particular
clients
Open
source
therefore
likely
increase
importance
way
developing
distributing
software
@@@@@@@@@@
Chapter
Design
implementation
Key
Points
Software
design
implementation
interleaved
activities
level
detail
design
depends
type
system
developed
using
plan
driven
agile
approach
process
object
oriented
design
includes
activities
design
system
architecture
identify
objects
system
describe
design
using
different
object
models
document
component
interfaces
range
different
models
produced
object
oriented
design
process
include
static
models
class
models
generalization
models
association
models
dynamic
models
sequence
models
state
machine
models
Component
interfaces
defined
precisely
objects
use
UML
interface
stereotype
used
define
interfaces
developing
software
consider
possibility
reusing
existing
software
components
services
complete
systems
Configuration
management
process
managing
changes
evolving
software
system
essential
team
people
cooperating
develop
software
software
development
host
target
development
use
IDE
host
machine
develop
software
transferred
target
machine
execution
Open
source
development
involves
making
source
code
system
publicly
available
means
many
people
propose
changes
improvements
software
reaDIng
Design
Patterns
Elements
Reusable
Object
oriented
Software
original
software
patterns
handbook
introduced
software
patterns
wide
community
E
Gamma
R
Helm
R
Johnson
J
Vlissides
Addison
Wesley
Applying
UML
Patterns
Introduction
Object
oriented
Analysis
Design
Iterative
Development
rd
ed
Larman
writes
clearly
object
oriented
design
discusses
use
UML
good
introduction
using
patterns
design
process
years
old
remains
best
book
topic
available
C
Larman
Prentice
Hall
Producing
Open
Source
Software
Run
Successful
Free
Software
Project
book
comprehensive
guide
background
open
source
software
licensing
issues
practicalities
running
open
source
development
project
K
Fogel
O
Reilly
Media
Inc
reading
software
reuse
suggested
Chapter
configuration
management
Chapter
@@@@@@@@@@
Chapter
Exercises
Website
PowerPoint
slides
chapter
www
pearsonglobaleditions
com
Sommerville
Links
supporting
videos
http
software
engineering
book
com
videos
implementation
evolution
information
weather
information
system
http
software
engineering
book
com
case
studies
wilderness
weather
station
exercises
Using
tabular
notation
shown
Figure
specify
weather
station
use
cases
Report
status
Reconfigure
make
reasonable
assumptions
functionality
required
Assume
Mentcare
system
developed
using
object
oriented
approach
Draw
use
case
diagram
showing
least
six
possible
use
cases
system
Using
UML
graphical
notation
object
classes
design
following
object
classes
identifying
attributes
operations
Use
experience
decide
attributes
operations
associated
objects
messaging
system
mobile
cell
phone
tablet
printer
personal
computer
personal
music
system
bank
account
library
catalogue
shape
classified
D
D
Design
inheritance
hierarchy
include
different
kinds
D
D
shapes
Make
sure
identify
least
five
classes
shapes
Develop
design
weather
station
show
interaction
data
collection
subsystem
instruments
collect
weather
data
Use
sequence
diagrams
show
interaction
Identify
possible
objects
following
systems
develop
object
oriented
design
make
reasonable
assumptions
systems
deriving
design
group
diary
time
management
system
intended
support
timetabling
meetings
appointments
across
group
co
workers
appointment
made
@@@@@@@@@@
Chapter
Design
implementation
involves
number
people
system
finds
common
slot
diaries
arranges
appointment
time
no
common
slots
available
interacts
user
rearrange
personal
diary
make
room
appointment
filling
station
gas
station
set
fully
automated
operation
Drivers
swipe
credit
card
reader
connected
pump
card
verified
communication
credit
company
computer
fuel
limit
established
driver
take
fuel
required
fuel
delivery
complete
pump
hose
returned
holster
driver
s
credit
card
account
debited
cost
fuel
taken
credit
card
returned
debiting
card
invalid
pump
returns
fuel
dispensed
Draw
sequence
diagram
showing
interactions
objects
group
diary
system
group
people
arranging
meeting
Draw
UML
state
diagram
showing
possible
state
changes
group
diary
filling
station
system
code
integrated
larger
system
problems
surface
Explain
configuration
management
useful
handling
problems
small
company
developed
specialized
software
product
configures
specially
customer
New
customers
usually
specific
requirements
incorporated
system
pay
developed
integrated
product
software
company
opportunity
bid
new
contract
double
customer
base
new
customer
wishes
involvement
configuration
system
Explain
circumstances
good
idea
company
owning
software
make
open
source
reFerenCes
Abbott
R
Program
Design
Informal
English
Descriptions
Comm
ACM
doi
Alexander
C
Timeless
Way
Building
Oxford
UK
Oxford
University
Press
Bayersdorfer
M
Managing
Project
Open
Source
Components
ACM
Interactions
doi
Beck
K
W
Cunningham
Laboratory
Teaching
Object
Oriented
Thinking
Proc
OOPSLA
Conference
Object
Oriented
Programming
Systems
Languages
Applications
ACM
Press
doi
Buschmann
F
K
Henney
D
C
Schmidt
Pattern
Oriented
Software
Architecture
Volume
Pattern
Language
Distributed
Computing
New
York
John
Wiley
Sons
b
Pattern
Oriented
Software
Architecture
Volume
Patterns
Pattern
Languages
New
York
John
Wiley
Sons
@@@@@@@@@@
Chapter
References
Buschmann
F
R
Meunier
H
Rohnert
P
Sommerlad
Pattern
Oriented
Software
Architecture
Volume
System
Patterns
New
York
John
Wiley
Sons
Chapman
C
Short
Guide
Open
Source
Similar
Licences
Smashing
Magazine
http
www
smashingmagazine
com
short
guide
open
source
similar
licenses
Gamma
E
R
Helm
R
Johnson
J
Vlissides
Design
Patterns
Elements
Reusable
Object
Oriented
Software
Reading
MA
Addison
Wesley
Kircher
M
P
Jain
Pattern
Oriented
Software
Architecture
Volume
Patterns
Resource
Management
New
York
John
Wiley
Sons
Loeliger
J
M
McCullough
Version
Control
Git
Powerful
Tools
Techniques
Collaborative
Software
Development
Sebastopol
CA
O
Reilly
Associates
Pilato
C
B
Collins
Sussman
B
Fitzpatrick
Version
Control
Subversion
Sebastopol
CA
O
Reilly
Associates
Raymond
E
S
Cathedral
Bazaar
Musings
Linux
Open
Source
Accidental
Revolutionary
Sebastopol
CA
O
Reilly
Associates
Schmidt
D
M
Stal
H
Rohnert
F
Buschmann
Pattern
Oriented
Software
Architecture
Volume
Patterns
Concurrent
Networked
Objects
New
York
John
Wiley
Sons
St
Laurent
Understanding
Open
Source
Free
Software
Licensing
Sebastopol
CA
O
Reilly
Associates
Vogel
L
Eclipse
IDE
Tutorial
Hamburg
Germany
Vogella
Gmbh
Wirfs
Brock
R
B
Wilkerson
L
Weiner
Designing
Object
Oriented
Software
Englewood
Cliffs
NJ
Prentice
Hall
@@@@@@@@@@
Software
testing
Objectives
objective
chapter
introduce
software
testing
software
testing
processes
read
chapter
understand
stages
testing
testing
development
acceptance
testing
system
customers
introduced
techniques
help
choose
test
cases
geared
discovering
program
defects
understand
test
first
development
design
tests
writing
code
run
tests
automatically
know
three
distinct
types
testing
component
testing
system
testing
release
testing
understand
distinctions
development
testing
user
testing
Contents
Development
testing
Test
driven
development
Release
testing
User
testing
@@@@@@@@@@
Chapter
Software
testing
Testing
intended
show
program
intended
discover
program
defects
put
use
test
software
execute
program
using
artificial
data
check
results
test
run
errors
anomalies
information
program
s
non
functional
attributes
test
software
trying
two
things
Demonstrate
developer
customer
software
meets
requirements
custom
software
means
least
one
test
every
requirement
requirements
document
generic
software
products
means
tests
system
features
included
product
release
test
combinations
features
check
unwanted
interactions
Find
inputs
input
sequences
behavior
software
incorrect
undesirable
conform
specification
caused
defects
bugs
software
test
software
find
defects
trying
root
undesirable
system
behavior
system
crashes
unwanted
interactions
systems
incorrect
computations
data
corruption
first
validation
testing
expect
system
perform
correctly
using
set
test
cases
reflect
system
s
expected
use
second
defect
testing
test
cases
designed
expose
defects
test
cases
defect
testing
deliberately
obscure
need
reflect
system
normally
used
course
no
definite
boundary
two
approaches
testing
validation
testing
find
defects
system
defect
testing
tests
show
program
meets
requirements
Figure
shows
differences
validation
testing
defect
testing
Think
system
tested
black
box
system
accepts
inputs
input
set
generates
outputs
output
set
O
outputs
erroneous
outputs
set
O
generated
system
response
inputs
e
set
priority
defect
testing
find
inputs
set
ee
reveal
problems
system
Validation
testing
involves
testing
correct
inputs
outside
stimulate
system
generate
expected
correct
outputs
e
Testing
cannot
demonstrate
software
free
defects
behave
specified
every
circumstance
possible
test
overlooked
discover
problems
system
Edsger
Dijkstra
early
contributor
development
software
engineering
eloquently
stated
Dijkstra
Testing
show
presence
errors
absence
Testing
part
broader
process
software
verification
validation
V
V
Verification
validation
thing
often
confused
Barry
Boehm
pioneer
software
engineering
succinctly
expressed
difference
Boehm
Dijkstra
E
W
Humble
Programmer
Comm
ACM
doi
@@@@@@@@@@
Chapter
Software
testing
Figure
input
output
model
program
testing
System
Outputs
reveal
presence
defects
Ie
Input
test
data
OeOutput
test
results
Validation
building
right
product
Verification
building
product
right
Verification
validation
processes
concerned
checking
software
developed
meets
specification
delivers
functionality
expected
people
paying
software
checking
processes
start
soon
requirements
available
continue
stages
development
process
Software
verification
process
checking
software
meets
stated
functional
non
functional
requirements
Validation
general
process
aim
software
validation
ensure
software
meets
customer
s
expectations
goes
beyond
checking
conformance
specification
demonstrating
software
customer
expects
Validation
essential
discussed
Chapter
statements
requirements
reflect
real
wishes
needs
system
customers
users
goal
verification
validation
processes
establish
confidence
software
system
fit
purpose
means
system
good
enough
intended
use
level
required
confidence
depends
system
s
purpose
expectations
system
users
current
marketing
environment
system
Software
purpose
critical
software
important
reliable
example
level
confidence
required
software
used
control
safety
critical
system
much
higher
required
demonstrator
system
prototypes
new
product
ideas
User
expectations
previous
experiences
buggy
unreliable
software
users
sometimes
low
expectations
software
quality
surprised
software
fails
new
system
installed
users
Inputs
causing
anomalous
behavior
@@@@@@@@@@
Chapter
Software
testing
UML
design
models
Software
architecture
Requirements
specification
Database
schemas
Program
System
prototype
Testing
Inspections
Figure
Inspections
testing
tolerate
failures
benefits
use
outweigh
costs
failure
recovery
However
software
product
becomes
established
users
expect
reliable
Consequently
thorough
testing
later
versions
system
required
Marketing
environment
software
company
brings
system
market
take
account
competing
products
price
customers
willing
pay
system
required
schedule
delivering
system
competitive
environment
company
decide
release
program
fully
tested
debugged
wants
first
market
software
product
app
cheap
users
willing
tolerate
lower
level
reliability
well
software
testing
verification
validation
process
involve
software
inspections
reviews
Inspections
reviews
analyze
check
system
requirements
design
models
program
source
code
even
proposed
system
tests
static
V
V
techniques
don
t
need
execute
software
verify
Figure
shows
software
inspections
testing
support
V
V
different
stages
software
process
arrows
indicate
stages
process
techniques
used
Inspections
mostly
focus
source
code
system
readable
representation
software
requirements
design
model
inspected
inspect
system
use
knowledge
system
application
domain
programming
modeling
language
discover
errors
Software
inspection
three
advantages
testing
testing
errors
mask
hide
errors
error
leads
unexpected
outputs
never
sure
later
output
anomalies
due
new
error
side
effects
original
error
inspection
doesn
t
involve
executing
system
don
t
worry
interactions
errors
Consequently
single
inspection
session
discover
many
errors
system
@@@@@@@@@@
Chapter
Software
testing
Design
test
cases
Prepare
test
data
Run
program
test
data
Compare
results
test
cases
Test
cases
Test
data
Test
results
Test
reports
Figure
model
software
testing
process
Incomplete
versions
system
inspected
without
additional
costs
program
incomplete
need
develop
specialized
test
harnesses
test
parts
available
obviously
adds
system
development
costs
well
searching
program
defects
inspection
consider
broader
quality
attributes
program
compliance
standards
portability
maintainability
look
inefficiencies
inappropriate
algorithms
poor
programming
style
make
system
difficult
maintain
update
Program
inspections
old
idea
several
studies
experiments
shown
inspections
effective
defect
discovery
program
testing
Fagan
Fagan
reported
errors
program
detected
using
informal
program
inspections
Cleanroom
process
Prowell
et
al
claimed
defects
discovered
program
inspections
However
inspections
cannot
replace
software
testing
Inspections
good
discovering
defects
arise
unexpected
interactions
different
parts
program
timing
problems
problems
system
performance
small
companies
development
groups
difficult
expensive
put
together
separate
inspection
team
potential
team
members
developers
software
discuss
reviews
inspections
detail
Chapter
Quality
Management
Static
analysis
source
text
program
automatically
analyzed
discover
anomalies
explained
Chapter
chapter
focus
testing
testing
processes
Figure
abstract
model
traditional
testing
process
used
plan
driven
development
Test
cases
specifications
inputs
test
expected
output
system
test
results
plus
statement
tested
Test
data
inputs
devised
test
system
Test
data
sometimes
generated
automatically
automatic
test
case
generation
impossible
People
understand
system
supposed
involved
specify
expected
test
results
However
test
execution
automated
test
results
automatically
compared
predicted
results
no
need
person
look
errors
anomalies
test
run
@@@@@@@@@@
Development
testing
Test
planning
Test
planning
concerned
scheduling
resourcing
activities
testing
process
involves
defining
testing
process
taking
account
people
time
available
Usually
test
plan
created
defines
tested
predicted
testing
schedule
tests
recorded
critical
systems
test
plan
include
details
tests
run
software
http
software
engineering
book
com
web
test
planning
Typically
commercial
software
system
go
three
stages
testing
Development
testing
system
tested
development
discover
bugs
defects
System
designers
programmers
likely
involved
testing
process
Release
testing
separate
testing
team
tests
complete
version
system
released
users
aim
release
testing
check
system
meets
requirements
system
stakeholders
User
testing
users
potential
users
system
test
system
environment
software
products
user
internal
marketing
group
decides
software
marketed
released
sold
Acceptance
testing
one
type
user
testing
customer
formally
tests
system
decide
accepted
system
supplier
development
required
practice
testing
process
usually
involves
mixture
manual
automated
testing
manual
testing
tester
runs
program
test
data
compares
results
expectations
note
report
discrepancies
program
developers
automated
testing
tests
encoded
program
run
time
system
development
tested
faster
manual
testing
especially
involves
regression
testing
re
running
previous
tests
check
changes
program
introduced
new
bugs
Unfortunately
testing
never
completely
automated
automated
tests
check
program
supposed
practically
impossible
use
automated
testing
test
systems
depend
things
look
e
g
graphical
user
interface
test
program
unanticipated
side
effects
Development
testing
Development
testing
includes
testing
activities
carried
team
developing
system
tester
software
usually
programmer
developed
software
development
processes
use
programmer
tester
pairs
Cusamano
Selby
programmer
associated
tester
@@@@@@@@@@
Chapter
Software
testing
Debugging
Debugging
process
fixing
errors
problems
discovered
testing
Using
information
program
tests
debuggers
use
knowledge
programming
language
intended
outcome
test
locate
repair
program
error
debugging
program
usually
use
interactive
tools
provide
extra
information
program
execution
http
software
engineering
book
com
web
debugging
develops
tests
assists
testing
process
critical
systems
formal
process
used
separate
testing
group
development
team
group
responsible
developing
tests
maintaining
detailed
records
test
results
three
stages
development
testing
Unit
testing
individual
program
units
object
classes
tested
Unit
testing
focus
testing
functionality
objects
methods
Component
testing
several
individual
units
integrated
create
composite
components
Component
testing
focus
testing
component
interfaces
provide
access
component
functions
System
testing
components
system
integrated
system
tested
whole
System
testing
focus
testing
component
interactions
Development
testing
primarily
defect
testing
process
aim
testing
discover
bugs
software
therefore
usually
interleaved
debugging
process
locating
problems
code
changing
program
fix
problems
Unit
testing
Unit
testing
process
testing
program
components
methods
object
classes
Individual
functions
methods
simplest
type
component
tests
calls
routines
different
input
parameters
use
approaches
test
case
design
discussed
Section
design
function
method
tests
testing
object
classes
design
tests
provide
coverage
features
object
means
test
operations
associated
object
set
check
value
attributes
associated
object
put
object
possible
states
means
simulate
events
cause
state
change
Consider
example
weather
station
object
example
discussed
Chapter
attributes
operations
object
shown
Figure
@@@@@@@@@@
Development
testing
WeatherStation
identifier
reportWeather
reportStatus
powerSave
instruments
remoteControl
commands
reconfigure
commands
restart
instruments
shutdown
instruments
Figure
weather
station
object
interface
single
attribute
identifier
constant
set
weather
station
installed
therefore
need
test
checks
properly
set
need
define
test
cases
methods
associated
object
reportWeather
reportStatus
Ideally
test
methods
isolation
cases
test
sequences
necessary
example
test
method
shuts
weather
station
instruments
shutdown
need
executed
restart
method
Generalization
inheritance
makes
object
class
testing
complicated
t
simply
test
operation
class
defined
assume
work
expected
subclasses
inherit
operation
operation
inherited
make
assumptions
operations
attributes
assumptions
valid
subclasses
inherit
operation
therefore
test
inherited
operation
everywhere
used
test
states
weather
station
use
state
model
discussed
Chapter
Figure
Using
model
identify
sequences
state
transitions
tested
define
event
sequences
force
transitions
principle
test
every
possible
state
transition
sequence
practice
expensive
Examples
state
sequences
tested
weather
station
include
Shutdown
Running
Shutdown
Configuring
Running
Testing
Transmitting
Running
Running
Collecting
Running
Summarizing
Transmitting
Running
possible
automate
unit
testing
automated
unit
testing
make
use
test
automation
framework
JUnit
Tahchiev
et
al
write
run
program
tests
Unit
testing
frameworks
provide
generic
test
classes
extend
create
specific
test
cases
run
tests
implemented
report
often
graphical
unit
interface
GUI
success
otherwise
tests
entire
test
suite
often
run
seconds
possible
execute
tests
every
time
make
change
program
automated
test
three
parts
setup
part
initialize
system
test
case
namely
inputs
expected
outputs
@@@@@@@@@@
call
part
call
object
method
tested
assertion
part
compare
result
call
expected
result
assertion
evaluates
true
test
successful
false
failed
Sometimes
object
testing
dependencies
objects
implemented
use
slows
testing
process
example
object
calls
database
involve
slow
setup
process
used
cases
decide
use
mock
objects
Mock
objects
objects
interface
external
objects
used
simulate
functionality
example
mock
object
simulating
database
data
items
organized
array
accessed
quickly
without
overheads
calling
database
accessing
disks
Similarly
mock
objects
used
simulate
abnormal
operations
rare
events
example
system
intended
take
action
certain
times
day
mock
object
simply
return
times
irrespective
actual
clock
time
Choosing
unit
test
cases
Testing
expensive
time
consuming
important
choose
effective
unit
test
cases
Effectiveness
case
means
two
things
test
cases
show
used
expected
component
testing
supposed
defects
component
revealed
test
cases
therefore
design
two
kinds
test
case
first
reflect
normal
operation
program
show
component
works
example
testing
component
creates
initializes
new
patient
record
test
case
show
record
exists
database
fields
set
specified
kind
test
case
based
testing
experience
common
problems
arise
use
abnormal
inputs
check
properly
processed
crash
component
Two
strategies
effective
helping
choose
test
cases
Partition
testing
identify
groups
inputs
common
characteristics
processed
way
choose
tests
groups
Guideline
based
testing
use
testing
guidelines
choose
test
cases
guidelines
reflect
previous
experience
kinds
errors
programmers
often
make
developing
components
@@@@@@@@@@
Development
testing
Input
equivalence
partitions
Output
partitions
System
Possible
inputs
Figure
Equivalence
partitioning
Correct
outputs
Possible
outputs
input
data
output
results
program
thought
members
sets
common
characteristics
Examples
sets
positive
numbers
negative
numbers
menu
selections
Programs
normally
behave
comparable
way
members
set
test
program
computation
requires
two
positive
numbers
expect
program
behave
way
positive
numbers
equivalent
behavior
classes
sometimes
called
equivalence
partitions
domains
Bezier
One
systematic
approach
test
case
design
based
identifying
input
output
partitions
system
component
Test
cases
designed
inputs
outputs
lie
partitions
Partition
testing
used
design
test
cases
systems
components
Figure
large
shaded
ellipse
left
represents
set
possible
inputs
program
tested
smaller
unshaded
ellipses
represent
equivalence
partitions
program
tested
process
members
input
equivalence
partition
way
Output
equivalence
partitions
partitions
outputs
something
common
Sometimes
mapping
input
output
equivalence
partitions
However
case
need
define
separate
input
equivalence
partition
common
characteristic
inputs
generate
outputs
output
partition
shaded
area
left
ellipse
represents
inputs
invalid
shaded
area
right
ellipse
represents
exceptions
occur
responses
invalid
inputs
identified
set
partitions
choose
test
cases
partitions
good
rule
thumb
test
case
selection
choose
test
cases
boundaries
partitions
plus
cases
close
midpoint
partition
reason
designers
programmers
tend
consider
typical
values
inputs
developing
system
test
choosing
midpoint
partition
Boundary
values
often
atypical
e
g
zero
behave
differently
non
negative
numbers
sometimes
overlooked
developers
Program
failures
often
occur
processing
atypical
values
@@@@@@@@@@
Less
Number
input
values
Less
Input
values
Figure
Equivalence
partitions
identify
partitions
using
program
specification
user
documentation
experience
predict
classes
input
value
likely
detect
errors
example
say
program
specification
states
program
accepts
four
eight
inputs
five
digit
integers
greater
use
information
identify
input
partitions
possible
test
input
values
shown
Figure
use
specification
system
identify
equivalence
partitions
called
black
box
testing
don
t
need
knowledge
system
works
sometimes
useful
supplement
black
box
tests
white
box
testing
look
code
program
find
possible
tests
example
code
include
exceptions
handle
incorrect
inputs
use
knowledge
identify
exception
partitions
different
ranges
exception
handling
applied
Equivalence
partitioning
effective
approach
testing
helps
account
errors
programmers
often
make
processing
inputs
edges
partitions
use
testing
guidelines
help
choose
test
cases
Guidelines
encapsulate
knowledge
kinds
test
cases
effective
discovering
errors
example
testing
programs
sequences
arrays
lists
guidelines
help
reveal
defects
include
Test
software
sequences
single
value
Programmers
naturally
think
sequences
made
several
values
sometimes
embed
assumption
programs
Consequently
presented
single
value
sequence
program
work
properly
Use
different
sequences
different
sizes
different
tests
decreases
chances
program
defects
accidentally
produce
correct
output
accidental
characteristics
input
Derive
tests
first
middle
last
elements
sequence
accessed
approach
reveals
problems
partition
boundaries
@@@@@@@@@@
Development
testing
Path
testing
Path
testing
testing
strategy
aims
exercise
every
independent
execution
path
component
program
every
independent
path
executed
statements
component
executed
least
conditional
statements
tested
true
false
cases
object
oriented
development
process
path
testing
used
test
methods
associated
objects
http
software
engineering
book
com
web
path
testing
Whittaker
s
book
Whittaker
includes
many
examples
guidelines
used
test
case
design
general
guidelines
suggests
Choose
inputs
force
system
generate
error
messages
Design
inputs
cause
input
buffers
overflow
Repeat
input
series
inputs
numerous
times
Force
invalid
outputs
generated
Force
computation
results
large
small
gain
experience
testing
develop
guidelines
choose
effective
test
cases
give
examples
testing
guidelines
next
section
Component
testing
Software
components
often
made
several
interacting
objects
example
weather
station
system
reconfiguration
component
includes
objects
deal
aspect
reconfiguration
access
functionality
objects
component
interfaces
see
Chapter
Testing
composite
components
therefore
focus
showing
component
interface
interfaces
behave
according
specification
assume
unit
tests
individual
objects
component
completed
Figure
illustrates
idea
component
interface
testing
Assume
components
B
C
integrated
create
larger
component
subsystem
test
cases
applied
individual
components
rather
interface
composite
component
created
combining
components
Interface
errors
composite
component
detectable
testing
individual
objects
errors
result
interactions
objects
component
different
types
interface
program
components
consequently
different
types
interface
error
occur
Parameter
interfaces
interfaces
data
sometimes
function
references
passed
one
component
another
Methods
object
parameter
interface
@@@@@@@@@@
TestcasesTestcases
C
B
Figure
Interface
testing
Shared
memory
interfaces
interfaces
block
memory
shared
components
Data
placed
memory
one
subsystem
retrieved
subsystems
type
interface
used
embedded
systems
sensors
create
data
retrieved
processed
system
components
Procedural
interfaces
interfaces
one
component
encapsulates
set
procedures
called
components
Objects
reusable
components
form
interface
Message
passing
interfaces
interfaces
one
component
requests
service
another
component
passing
message
return
message
includes
results
executing
service
object
oriented
systems
form
interface
client
server
systems
Interface
errors
one
common
forms
error
complex
systems
Lutz
errors
fall
three
classes
Interface
misuse
calling
component
calls
component
makes
error
use
interface
type
error
common
parameter
interfaces
parameters
wrong
type
passed
wrong
order
wrong
number
parameters
passed
Interface
misunderstanding
calling
component
misunderstands
specification
interface
called
component
makes
assumptions
behavior
called
component
behave
expected
causes
unexpected
behavior
calling
component
example
binary
search
method
called
parameter
unordered
array
search
fail
Timing
errors
occur
real
time
systems
use
shared
memory
message
passing
interface
producer
data
consumer
data
@@@@@@@@@@
Development
testing
operate
different
speeds
Unless
particular
care
taken
interface
design
consumer
access
date
information
producer
information
updated
shared
interface
information
Testing
interface
defects
difficult
interface
faults
manifest
unusual
conditions
example
say
object
implements
queue
fixed
length
data
structure
calling
object
assume
queue
implemented
infinite
data
structure
check
queue
overflow
item
entered
condition
detected
testing
designing
sequence
test
cases
force
queue
overflow
tests
check
calling
objects
handle
overflow
However
rare
condition
testers
think
isn
t
worth
checking
writing
test
set
queue
object
problem
arise
interactions
faults
different
modules
objects
Faults
one
object
detected
object
behaves
unexpected
way
Say
object
calls
another
object
receive
service
calling
object
assumes
response
correct
called
service
faulty
way
returned
value
valid
incorrect
problem
therefore
immediately
detectable
becomes
obvious
later
computation
using
returned
value
goes
wrong
general
guidelines
interface
testing
Examine
code
tested
identify
call
external
component
Design
set
tests
values
parameters
external
components
extreme
ends
ranges
extreme
values
likely
reveal
interface
inconsistencies
pointers
passed
across
interface
test
interface
null
pointer
parameters
component
called
procedural
interface
design
tests
deliberately
cause
component
fail
Differing
failure
assumptions
one
common
specification
misunderstandings
Use
stress
testing
message
passing
systems
means
design
tests
generate
many
messages
likely
occur
practice
effective
way
revealing
timing
problems
several
components
interact
shared
memory
design
tests
vary
order
components
activated
tests
reveal
implicit
assumptions
made
programmer
order
shared
data
produced
consumed
Sometimes
better
use
inspections
reviews
rather
testing
look
interface
errors
Inspections
concentrate
component
interfaces
questions
assumed
interface
behavior
asked
inspection
process
@@@@@@@@@@
System
testing
System
testing
development
involves
integrating
components
create
version
system
testing
integrated
system
System
testing
checks
components
compatible
interact
correctly
transfer
right
data
right
time
across
interfaces
obviously
overlaps
component
testing
two
important
differences
system
testing
reusable
components
separately
developed
off
shelf
systems
integrated
newly
developed
components
complete
system
tested
Components
developed
different
team
members
subteams
integrated
stage
System
testing
collective
rather
individual
process
companies
system
testing
involve
separate
testing
team
no
involvement
designers
programmers
systems
emergent
behavior
means
system
functionality
characteristics
obvious
put
components
together
planned
emergent
behavior
tested
example
integrate
authentication
component
component
updates
system
database
system
feature
restricts
information
updating
authorized
users
Sometimes
however
emergent
behavior
unplanned
unwanted
develop
tests
check
system
supposed
System
testing
focus
testing
interactions
components
objects
make
system
test
reusable
components
systems
check
work
expected
integrated
new
components
interaction
testing
discover
component
bugs
revealed
component
used
components
system
Interaction
testing
helps
find
misunderstandings
made
component
developers
components
system
focus
interactions
use
case
based
testing
effective
approach
system
testing
Several
components
objects
normally
implement
use
case
system
Testing
use
case
forces
interactions
occur
developed
sequence
diagram
model
use
case
implementation
see
objects
components
involved
interaction
wilderness
weather
station
example
system
software
reports
summarized
weather
data
remote
computeras
described
Figure
Figure
shows
sequence
operations
weather
station
responds
request
collect
data
mapping
system
use
diagram
identify
operations
tested
help
design
test
cases
execute
tests
Therefore
issuing
request
report
result
execution
following
thread
methods
SatComms
request
WeatherStation
reportWeather
Commslink
Get
summary
WeatherData
summarize
@@@@@@@@@@
Development
testing
Weather
SatComms
request
report
acknowledge
reportWeather
get
summary
reply
report
acknowledge
WeatherStation
Commslink
summarise
WeatherData
acknowledge
send
report
acknowledge
information
system
Figure
Collect
weather
data
sequence
chart
sequence
diagram
helps
design
specific
test
cases
need
shows
inputs
required
outputs
created
input
request
report
associated
acknowledgment
report
ultimately
returned
request
testing
create
summarized
data
used
check
report
correctly
organized
input
request
report
WeatherStation
results
summarized
report
generated
test
isolation
creating
raw
data
corresponding
summary
prepared
test
SatComms
checking
WeatherStation
object
correctly
produces
summary
raw
data
used
test
WeatherData
object
course
simplified
sequence
diagram
Figure
show
exceptions
complete
use
case
scenario
test
take
exceptions
account
ensure
correctly
handled
systems
difficult
know
much
system
testing
essential
stop
testing
Exhaustive
testing
every
possible
program
execution
sequence
tested
impossible
Testing
therefore
based
subset
possible
test
cases
Ideally
software
companies
policies
choosing
subset
policies
based
general
testing
policies
policy
program
statements
executed
least
Alternatively
based
experience
system
usage
focus
testing
features
operational
system
example
@@@@@@@@@@
Incremental
integration
testing
System
testing
involves
integrating
different
components
testing
integrated
system
created
use
incremental
approach
integration
testing
integrate
component
test
system
integrate
another
component
test
problems
occur
probably
due
interactions
recently
integrated
component
Incremental
integration
testing
fundamental
agile
methods
regression
tests
run
every
time
new
increment
integrated
http
software
engineering
book
com
web
integration
system
functions
accessed
menus
tested
Combinations
functions
e
g
text
formatting
accessed
menu
tested
user
input
provided
functions
tested
correct
incorrect
input
clear
experience
major
software
products
word
processors
spreadsheets
similar
guidelines
normally
used
product
testing
features
software
used
isolation
normally
work
Problems
arise
Whittaker
explains
Whittaker
combinations
less
commonly
used
features
tested
together
gives
example
commonly
used
word
processor
using
footnotes
multicolumn
layout
causes
incorrect
layout
text
Automated
system
testing
usually
difficult
automated
unit
component
testing
Automated
unit
testing
relies
predicting
outputs
encoding
predictions
program
prediction
compared
result
However
point
implementing
system
generate
outputs
large
cannot
easily
predicted
able
examine
output
check
credibility
without
necessarily
able
create
advance
Test
driven
development
Test
driven
development
TDD
approach
program
development
interleave
testing
code
development
Beck
Jeffries
Melnik
develop
code
incrementally
along
set
tests
increment
don
t
start
working
next
increment
code
developed
passes
tests
Test
driven
development
introduced
part
XP
agile
development
method
However
now
gained
mainstream
acceptance
used
agile
plan
based
processes
@@@@@@@@@@
Test
driven
development
Identify
new
functionality
Write
test
Run
test
Implement
functionality
refactor
fail
pass
Figure
Test
driven
development
fundamental
TDD
process
shown
Figure
steps
process
follows
start
identifying
increment
functionality
required
normally
small
implementable
lines
code
write
test
functionality
implement
automated
test
means
test
executed
report
passed
failed
run
test
along
tests
implemented
Initially
implemented
functionality
new
test
fail
deliberate
shows
test
adds
something
test
set
implement
functionality
re
run
test
involve
refactoring
existing
code
improve
add
new
code
s
already
tests
run
successfully
move
implementing
next
chunk
functionality
automated
testing
environment
JUnit
environment
supports
Java
program
testing
Tahchiev
et
al
essential
TDD
code
developed
small
increments
able
run
every
test
time
add
functionality
refactor
program
Therefore
tests
embedded
separate
program
runs
tests
invokes
system
tested
Using
approach
run
hundreds
separate
tests
seconds
Test
driven
development
helps
programmers
clarify
ideas
code
segment
supposed
write
test
need
understand
intended
understanding
makes
easier
write
required
code
course
incomplete
knowledge
understanding
TDD
won
t
help
don
t
know
enough
write
tests
won
t
develop
required
code
example
computation
involves
division
check
dividing
numbers
zero
forget
write
test
checking
code
never
included
program
well
better
problem
understanding
benefits
test
driven
development
Code
coverage
principle
every
code
segment
write
least
one
associated
test
Therefore
confident
code
@@@@@@@@@@
system
executed
Code
tested
written
defects
discovered
early
development
process
Regression
testing
test
suite
developed
incrementally
program
developed
run
regression
tests
check
changes
program
introduced
new
bugs
Simplified
debugging
test
fails
obvious
problem
lies
newly
written
code
needs
checked
modified
need
use
debugging
tools
locate
problem
Reports
use
TDD
suggest
hardly
ever
necessary
use
automated
debugger
test
driven
development
Martin
System
documentation
tests
act
form
documentation
describe
code
Reading
tests
make
easier
understand
code
One
important
benefits
TDD
reduces
costs
regression
testing
Regression
testing
involves
running
test
sets
successfully
executed
changes
made
system
regression
test
checks
changes
introduced
new
bugs
system
new
code
interacts
expected
existing
code
Regression
testing
expensive
sometimes
impractical
system
manually
tested
costs
time
effort
high
try
choose
relevant
tests
re
run
easy
miss
important
tests
Automated
testing
dramatically
reduces
costs
regression
testing
Existing
tests
re
run
quickly
cheaply
making
change
system
test
first
development
existing
tests
run
successfully
functionality
added
programmer
confident
new
functionality
added
caused
revealed
problems
existing
code
Test
driven
development
value
new
software
development
functionality
implemented
new
code
using
components
standard
libraries
reusing
large
code
components
legacy
systems
need
write
tests
systems
whole
cannot
easily
decompose
separate
testable
elements
Incremental
test
driven
development
impractical
Test
driven
development
ineffective
multithreaded
systems
different
threads
interleaved
different
times
different
test
runs
produce
different
results
use
TDD
still
need
system
testing
process
validate
system
check
meets
requirements
system
stakeholders
System
testing
tests
performance
reliability
checks
system
things
shouldn
t
produce
unwanted
outputs
Andrea
Andrea
suggests
testing
tools
extended
integrate
aspects
system
testing
TDD
Test
driven
development
now
widely
used
mainstream
approach
software
testing
programmers
adopted
approach
happy
@@@@@@@@@@
Release
testing
find
productive
way
develop
software
claimed
use
TDD
encourages
better
structuring
program
improved
code
quality
However
experiments
verify
claim
inconclusive
Release
testing
Release
testing
process
testing
particular
release
system
intended
use
outside
development
team
Normally
system
release
customers
users
complex
project
however
release
teams
developing
related
systems
software
products
release
product
management
prepare
sale
two
important
distinctions
release
testing
system
testing
development
process
system
development
team
responsible
release
testing
Release
testing
process
validation
checking
ensure
system
meets
requirements
good
enough
use
system
customers
System
testing
development
team
focus
discovering
bugs
system
defect
testing
primary
goal
release
testing
process
convince
supplier
system
good
enough
use
released
product
delivered
customer
Release
testing
therefore
show
system
delivers
specified
functionality
performance
dependability
fail
normal
use
Release
testing
usually
black
box
testing
process
whereby
tests
derived
system
specification
system
treated
black
box
behavior
determined
studying
inputs
related
outputs
Another
name
functional
testing
called
tester
concerned
functionality
implementation
software
Requirements
based
testing
general
principle
good
requirements
engineering
practice
requirements
testable
requirement
written
test
designed
requirement
tester
check
requirement
satisfied
Requirements
based
testing
therefore
systematic
approach
test
case
design
consider
requirement
derive
set
tests
Requirements
based
testing
validation
rather
defect
testing
trying
demonstrate
system
properly
implemented
requirements
@@@@@@@@@@
example
consider
following
Mentcare
system
requirements
concerned
checking
drug
allergies
patient
known
allergic
particular
medication
prescription
medication
shall
result
warning
message
issued
system
user
prescriber
chooses
ignore
allergy
warning
shall
provide
reason
ignored
check
requirements
satisfied
need
develop
several
related
tests
Set
patient
record
no
known
allergies
Prescribe
medication
allergies
known
exist
Check
warning
message
issued
system
Set
patient
record
known
allergy
Prescribe
medication
patient
allergic
check
warning
issued
system
Set
patient
record
allergies
two
drugs
recorded
Prescribe
drugs
separately
check
correct
warning
drug
issued
Prescribe
two
drugs
patient
allergic
Check
two
warnings
correctly
issued
Prescribe
drug
issues
warning
overrule
warning
Check
system
requires
user
provide
information
explaining
warning
overruled
see
list
testing
requirement
mean
writing
single
test
normally
write
several
tests
ensure
coverage
requirement
keep
traceability
records
requirements
based
testing
link
tests
specific
requirements
tested
Scenario
testing
Scenario
testing
approach
release
testing
whereby
devise
typical
scenarios
use
use
scenarios
develop
test
cases
system
scenario
story
describes
one
way
system
used
Scenarios
realistic
real
system
users
able
relate
used
scenarios
user
stories
part
requirements
engineering
process
described
Chapter
able
reuse
testing
scenarios
short
paper
scenario
testing
Kaner
Kaner
suggests
scenario
test
narrative
story
credible
fairly
complex
motivate
stakeholders
relate
scenario
believe
@@@@@@@@@@
Release
testing
George
nurse
specializes
mental
health
care
One
responsibilities
visit
patients
home
check
treatment
effective
suffering
medication
side
effects
day
home
visits
George
logs
Mentcare
system
uses
print
schedule
home
visits
day
along
summary
information
patients
visited
requests
records
patients
downloaded
laptop
prompted
key
phrase
encrypt
records
laptop
One
patients
visits
Jim
treated
medication
depression
Jim
feels
medication
helping
believes
side
effect
keeping
awake
night
George
looks
Jim
s
record
prompted
key
phrase
decrypt
record
checks
drug
prescribed
queries
side
effects
Sleeplessness
known
side
effect
notes
problem
Jim
s
record
suggests
visit
clinic
medication
changed
Jim
agrees
George
enters
prompt
call
gets
back
clinic
make
appointment
physician
George
ends
consultation
system
re
encrypts
Jim
s
record
finishing
consultations
George
returns
clinic
uploads
records
patients
visited
database
system
generates
call
list
George
patients
contact
follow
information
make
clinic
appointments
Figure
user
important
system
passes
test
suggests
easy
story
Mentcare
system
evaluate
problems
system
release
testing
team
recognize
example
possible
scenario
Mentcare
system
Figure
describes
one
way
system
used
home
visit
scenario
tests
number
features
Mentcare
system
Authentication
logging
system
Downloading
uploading
specified
patient
records
laptop
Home
visit
scheduling
Encryption
decryption
patient
records
mobile
device
Record
retrieval
modification
Links
drugs
database
maintains
side
effect
information
system
call
prompting
release
tester
run
scenario
playing
role
George
observing
system
behaves
response
different
inputs
George
make
deliberate
mistakes
inputting
wrong
key
phrase
decode
records
checks
response
system
errors
carefully
note
problems
arise
including
performance
problems
system
slow
change
way
used
example
takes
long
encrypt
record
users
short
time
skip
stage
lose
laptop
unauthorized
person
view
patient
records
use
scenario
based
approach
normally
testing
several
require
ments
scenario
Therefore
well
checking
individual
requirements
checking
combinations
requirements
cause
problems
@@@@@@@@@@
Performance
testing
system
completely
integrated
possible
test
emergent
properties
performance
reliability
Performance
tests
designed
ensure
system
process
intended
load
usually
involves
running
series
tests
increase
load
system
performance
becomes
unacceptable
types
testing
performance
testing
concerned
demonstrating
system
meets
requirements
discovering
problems
defects
system
test
performance
requirements
achieved
construct
operational
profile
operational
profile
see
Chapter
set
tests
reflect
actual
mix
work
handled
system
Therefore
transactions
system
type
type
B
remainder
types
C
D
E
design
operational
profile
vast
majority
tests
type
Otherwise
get
accurate
test
operational
performance
system
approach
course
necessarily
best
approach
defect
testing
Experience
shown
effective
way
discover
defects
design
tests
around
limits
system
performance
testing
means
stressing
system
making
demands
outside
design
limits
software
known
stress
testing
Say
testing
transaction
processing
system
designed
process
transactions
per
second
start
testing
system
fewer
transactions
per
second
gradually
increase
load
system
beyond
transactions
per
second
well
beyond
maximum
design
load
system
system
fails
Stress
testing
helps
two
things
Test
failure
behavior
system
Circumstances
arise
unexpected
combination
events
load
placed
system
exceeds
maximum
anticipated
load
circumstances
system
failure
cause
data
corruption
unexpected
loss
user
services
Stress
testing
checks
overloading
system
causes
fail
soft
rather
collapse
load
Reveal
defects
show
system
fully
loaded
argued
defects
unlikely
cause
system
failures
normal
use
unusual
combinations
circumstances
stress
testing
replicates
Stress
testing
particularly
relevant
distributed
systems
based
network
processors
systems
often
exhibit
severe
degradation
heavily
loaded
network
becomes
swamped
coordination
data
different
processes
exchange
processes
slower
slower
wait
required
data
processes
Stress
testing
helps
discover
degradation
begins
add
checks
system
reject
transactions
beyond
point
@@@@@@@@@@
User
testing
User
testing
User
customer
testing
stage
testing
process
users
customers
provide
input
advice
system
testing
involve
formally
testing
system
commissioned
external
supplier
Alternatively
informal
process
users
experiment
new
software
product
see
like
check
need
User
testing
essential
even
comprehensive
system
release
testing
carried
Influences
user
s
working
environment
major
effect
reliability
performance
usability
robustness
system
practically
impossible
system
developer
replicate
system
s
working
environment
tests
developer
s
environment
inevitably
artificial
example
system
intended
use
hospital
used
clinical
environment
things
going
patient
emergencies
conversations
relatives
affect
use
system
developers
cannot
include
testing
environment
three
different
types
user
testing
Alpha
testing
selected
group
software
users
work
closely
development
team
test
early
releases
software
Beta
testing
release
software
made
available
larger
group
users
allow
experiment
raise
problems
discover
system
developers
Acceptance
testing
customers
test
system
decide
ready
accepted
system
developers
deployed
customer
environment
alpha
testing
users
developers
work
together
test
system
developed
means
users
identify
problems
issues
readily
apparent
development
testing
team
Developers
really
work
requirements
often
reflect
factors
affect
practical
use
software
Users
therefore
provide
information
practice
helps
design
realistic
tests
Alpha
testing
often
used
developing
software
products
apps
Experienced
users
products
willing
get
involved
alpha
testing
process
gives
early
information
new
system
features
exploit
reduces
risk
unanticipated
changes
software
disruptive
effects
business
However
alpha
testing
used
custom
software
developed
Agile
development
methods
advocate
user
involvement
development
process
users
play
key
role
designing
tests
system
Beta
testing
takes
place
early
sometimes
unfinished
release
software
system
made
available
larger
group
customers
users
evaluation
Beta
testers
selected
group
customers
early
adopters
system
@@@@@@@@@@
Define
acceptance
criteria
Test
criteria
Plan
acceptance
testing
Derive
acceptance
tests
Run
acceptance
tests
Negotiate
test
results
Accept
reject
system
Test
plan
Tests
Test
results
Testing
report
Define
acceptance
criteria
Test
criteria
Plan
acceptance
testing
Derive
acceptance
tests
Run
acceptance
tests
Negotiate
test
results
Accept
reject
system
Test
plan
Tests
Test
results
Testing
report
Figure
acceptance
testing
process
Alternatively
software
made
publicly
available
use
anyone
interested
experimenting
Beta
testing
mostly
used
software
products
used
many
different
settings
important
unlike
custom
product
developers
no
way
product
developer
limit
software
s
operating
environment
impossible
product
developers
know
replicate
settings
software
product
used
Beta
testing
therefore
used
discover
interaction
problems
software
features
operational
environment
Beta
testing
form
marketing
Customers
learn
system
Acceptance
testing
inherent
part
custom
systems
development
Customers
test
system
using
data
decide
accepted
system
developer
Acceptance
implies
final
payment
made
software
Figure
shows
six
stages
acceptance
testing
process
Define
acceptance
criteria
stage
ideally
take
place
early
process
contract
system
signed
acceptance
criteria
part
system
contract
approved
customer
developer
practice
however
difficult
define
criteria
early
process
Detailed
requirements
available
requirements
certainly
change
development
process
Plan
acceptance
testing
stage
involves
deciding
resources
time
budget
acceptance
testing
establishing
testing
schedule
acceptance
test
plan
discuss
required
coverage
requirements
order
system
features
tested
define
risks
testing
process
system
crashes
inadequate
performance
discuss
risks
mitigated
Derive
acceptance
tests
acceptance
criteria
established
tests
designed
check
system
acceptable
Acceptance
tests
aim
test
functional
non
functional
characteristics
e
g
performance
system
ideally
provide
complete
coverage
system
requirements
practice
difficult
establish
completely
objective
acceptance
criteria
often
scope
argument
test
shows
criterion
definitely
met
Run
acceptance
tests
agreed
acceptance
tests
executed
system
Ideally
step
take
place
actual
environment
system
used
disruptive
impractical
Therefore
user
testing
@@@@@@@@@@
User
testing
environment
set
run
tests
difficult
automate
process
part
acceptance
tests
involve
testing
interactions
end
users
system
training
end
users
required
Negotiate
test
results
unlikely
defined
acceptance
tests
pass
no
problems
system
case
acceptance
testing
complete
system
handed
commonly
problems
discovered
cases
developer
customer
negotiate
decide
system
good
enough
used
agree
developer
fix
identified
problems
Reject
accept
system
stage
involves
meeting
developers
customer
decide
system
accepted
system
good
enough
use
development
required
fix
identified
problems
complete
acceptance
testing
phase
repeated
think
acceptance
testing
clear
cut
contractual
issue
system
pass
acceptance
tests
accepted
payment
made
However
reality
complex
Customers
want
use
software
soon
benefits
immediate
deployment
bought
new
hardware
trained
staff
changed
processes
willing
accept
software
irrespective
problems
costs
using
software
greater
costs
working
around
problems
Therefore
outcome
negotiations
conditional
acceptance
system
customer
accept
system
deployment
begin
system
provider
agrees
repair
urgent
problems
deliver
new
version
customer
quickly
possible
agile
methods
Extreme
Programming
no
separate
acceptance
testing
activity
end
user
part
development
team
e
alpha
tester
provides
system
requirements
terms
user
stories
responsible
defining
tests
decide
developed
software
supports
user
stories
tests
therefore
equivalent
acceptance
tests
tests
automated
development
proceed
story
acceptance
tests
successfully
executed
users
embedded
software
development
team
ideally
typical
users
general
knowledge
system
used
However
difficult
find
users
acceptance
tests
true
reflection
system
used
practice
Furthermore
requirement
automated
testing
limits
flexibility
testing
interactive
systems
systems
acceptance
testing
require
groups
end
users
use
system
part
everyday
work
Therefore
embedded
user
attractive
notion
principle
necessarily
lead
high
quality
tests
system
problem
user
involvement
agile
teams
one
reason
many
companies
use
mix
agile
traditional
testing
system
developed
using
agile
techniques
completion
major
release
separate
acceptance
testing
used
decide
system
accepted
@@@@@@@@@@
Chapter
Software
testing
Key
Points
Testing
show
presence
errors
program
cannot
show
no
remaining
faults
Development
testing
responsibility
software
development
team
separate
team
responsible
testing
system
released
customers
user
testing
process
customers
system
users
provide
test
data
check
tests
successful
Development
testing
includes
unit
testing
test
individual
objects
methods
component
testing
test
related
groups
objects
system
testing
test
partial
complete
systems
testing
software
try
break
software
using
experience
guidelines
choose
types
test
cases
effective
discovering
defects
systems
possible
write
automated
tests
tests
embedded
program
run
every
time
change
made
system
Test
first
development
approach
development
whereby
tests
written
code
tested
Small
code
changes
made
code
refactored
tests
execute
successfully
Scenario
testing
useful
replicates
practical
use
system
involves
inventing
typical
usage
scenario
using
derive
test
cases
Acceptance
testing
user
testing
process
aim
decide
software
good
enough
deployed
used
planned
operational
environment
ReaDing
design
practical
test
cases
article
test
case
design
author
Japanese
company
good
reputation
delivering
software
faults
T
Yamaura
IEEE
Software
November
http
dx
doi
org
Test
driven
development
special
issue
test
driven
development
includes
good
general
overview
TDD
well
experience
papers
TDD
used
different
types
software
IEEE
Software
June
Exploratory
Software
Testing
practical
rather
theoretical
book
software
testing
develops
ideas
Whittaker
s
earlier
book
Break
Software
author
presents
set
experience
based
guidelines
software
testing
J
Whittaker
Addison
Wesley
Google
Tests
Software
book
testing
large
scale
cloud
based
systems
poses
whole
set
new
challenges
compared
custom
software
applications
don
t
think
Google
approach
used
directly
interesting
lessons
book
large
scale
system
testing
J
Whittaker
J
Arbon
J
Carollo
Addison
Wesley
@@@@@@@@@@
Chapter
Exercises
WebsiTe
PowerPoint
slides
chapter
www
pearsonglobaleditions
com
Sommerville
Links
supporting
videos
http
software
engineering
book
com
videos
implementation
evolution
exeRCises
Explain
number
known
defects
remaining
program
time
delivery
affects
product
support
Testing
meant
show
program
intended
testers
know
program
intended
people
argue
developers
involved
testing
code
testing
responsibility
separate
team
Give
arguments
testing
developers
asked
test
method
called
catWhiteSpace
Paragraph
object
paragraph
replaces
sequences
blank
characters
single
blank
character
Identify
testing
partitions
example
derive
set
tests
catWhiteSpace
method
regression
testing
Explain
use
automated
tests
testing
framework
JUnit
simplifies
regression
testing
Mentcare
system
constructed
adapting
off
shelf
information
system
think
differences
testing
system
testing
software
developed
using
object
oriented
language
Java
Write
scenario
used
help
design
tests
wilderness
weather
station
system
understand
term
stress
testing
Suggest
stress
test
Mentcare
system
benefits
involving
users
release
testing
early
stage
testing
process
disadvantages
user
involvement
common
approach
system
testing
test
important
functionalities
system
first
followed
less
important
functionalities
testing
budget
exhausted
Discuss
ethics
involved
identifying
important
means
@@@@@@@@@@
Chapter
Software
testing
ReFeRenCes
Andrea
J
Envisioning
Next
Generation
Functional
Testing
Tools
IEEE
Software
doi
MS
Beck
K
Test
Driven
Development
Example
Boston
Addison
Wesley
Bezier
B
Software
Testing
Techniques
nd
ed
New
York
Van
Nostrand
Reinhold
Boehm
B
W
Software
Engineering
R
D
Trends
Defense
Needs
Research
Directions
Software
Technology
edited
P
Wegner
Cambridge
MA
MIT
Press
Cusamano
M
R
W
Selby
Microsoft
Secrets
New
York
Simon
Schuster
Dijkstra
E
W
Humble
Programmer
Comm
ACM
doi
Fagan
M
E
Design
Code
Inspections
Reduce
Errors
Program
Development
IBM
Systems
J
Jeffries
R
G
Melnik
TDD
Art
Fearless
Programming
IEEE
Software
doi
MS
Kaner
C
Introduction
Scenario
Testing
Software
Testing
Quality
Engineering
October
Lutz
R
R
Analysing
Software
Requirements
Errors
Safety
Critical
Embedded
Systems
RE
San
Diego
CA
IEEE
doi
ISRE
Martin
R
C
Professionalism
Test
Driven
Development
IEEE
Software
doi
MS
Prowell
S
J
C
J
Trammell
R
C
Linger
J
H
Poore
Cleanroom
Software
Engineering
Technology
Process
Reading
MA
Addison
Wesley
Tahchiev
P
F
Leme
V
Massol
G
Gregory
JUnit
Action
nd
ed
Greenwich
CT
Manning
Publications
Whittaker
J
Exploratory
Software
Testing
Boston
Addison
Wesley
@@@@@@@@@@
Software
evolution
Objectives
objectives
chapter
explain
software
evolution
important
part
software
engineering
describe
challenges
maintaining
large
base
software
systems
developed
many
years
read
chapter
understand
software
systems
adapt
evolve
remain
useful
software
change
evolution
considered
integral
part
software
engineering
understand
meant
legacy
systems
systems
important
businesses
understand
legacy
systems
assessed
decide
scrapped
maintained
reengineered
replaced
learned
different
types
software
maintenance
factors
affect
costs
making
changes
legacy
software
systems
Contents
Evolution
processes
Legacy
systems
Software
maintenance
@@@@@@@@@@
Chapter
Software
evolution
Large
software
systems
usually
long
lifetime
example
military
infrastructure
systems
air
traffic
control
systems
lifetime
years
Business
systems
often
years
old
Enterprise
software
costs
lot
money
company
use
software
system
many
years
get
return
investment
Successful
software
products
apps
introduced
many
years
ago
new
versions
released
every
years
example
first
version
Microsoft
Word
introduced
around
years
lifetime
operational
software
systems
change
emain
useful
Business
changes
changes
user
expectations
generate
new
requirements
software
Parts
software
modified
correct
errors
found
operation
adapt
changes
hardware
software
platform
improve
performance
non
functional
characteristics
Software
products
apps
evolve
cope
platform
changes
new
features
introduced
competitors
Software
systems
therefore
adapt
evolve
lifetime
initial
deployment
final
retirement
Businesses
change
software
ensure
continue
get
value
systems
critical
business
assets
invest
change
maintain
value
assets
Consequently
large
companies
spend
maintaining
existing
systems
new
systems
development
Historical
data
suggests
somewhere
software
costs
evolution
costs
Lientz
Swanson
Erlikh
Jones
Jones
found
development
staff
United
States
involved
software
evolution
suggested
percentage
unlikely
fall
foreseeable
future
Software
evolution
particularly
expensive
enterprise
systems
individual
software
systems
part
broader
system
systems
cases
cannot
consider
changes
one
system
need
examine
changes
affect
broader
system
systems
Changing
one
system
mean
systems
environment
evolve
cope
change
Therefore
well
understanding
analyzing
impact
proposed
change
system
assess
change
affect
systems
operational
environment
Hopkins
Jenkins
Hopkins
Jenkins
coined
term
brownfield
software
development
describe
situations
software
systems
developed
managed
environment
dependent
software
systems
requirements
installed
software
systems
change
business
environment
change
new
releases
systems
incorporate
changes
updates
usually
created
regular
intervals
Software
engineering
therefore
spiral
process
requirements
design
implementation
testing
going
throughout
lifetime
system
Figure
start
creating
release
system
delivered
changes
proposed
development
release
starts
immediately
fact
need
evolution
obvious
even
system
deployed
later
releases
software
start
development
current
version
even
released
last
years
time
iterations
spiral
reduced
dramatically
widespread
use
Internet
new
versions
software
system
@@@@@@@@@@
Chapter
Software
evolution
SpecificationImplementionValidationOperationStartRelease
Release
Release
etc
Figure
spiral
model
development
evolution
released
every
years
Now
competitive
pressures
need
respond
quickly
user
feedback
gap
releases
apps
web
based
systems
weeks
rather
years
model
software
evolution
applicable
company
responsible
software
throughout
lifetime
seamless
transition
development
evolution
software
development
methods
processes
applied
throughout
lifetime
software
Software
products
apps
developed
using
approach
evolution
custom
software
however
usually
follows
different
model
system
customer
pay
software
company
develop
software
take
responsibility
support
evolution
using
staff
Alternatively
software
customer
issue
separate
contract
different
software
company
system
support
evolution
situation
likely
discontinuities
evolution
process
Requirements
design
documents
passed
one
company
another
Companies
merge
reorganize
inherit
software
companies
find
changed
transition
development
evolution
seamless
process
changing
software
delivery
called
software
maintenance
discuss
later
chapter
maintenance
involves
extra
process
activities
program
understanding
addition
normal
activities
software
development
Rajlich
Bennett
Rajlich
Bennett
propose
alternative
view
software
evolution
life
cycle
business
systems
model
distinguish
evolution
servicing
Evolution
phase
significant
changes
software
architecture
functionality
made
servicing
changes
made
relatively
small
essential
changes
phases
overlap
shown
Figure
According
Rajlich
Bennett
software
first
used
successfully
many
changes
requirements
stakeholders
proposed
implemented
@@@@@@@@@@
Chapter
Software
evolution
Software
Software
development
Software
evolution
servicing
Softwareretirement
Figure
Evolution
servicing
Time
evolution
phase
However
software
modified
structure
tends
degrade
system
changes
expensive
often
happens
years
use
environmental
changes
hardware
operating
systems
required
stage
life
cycle
software
reaches
transition
point
significant
changes
implementation
new
requirements
less
less
cost
effective
stage
software
moves
evolution
servicing
servicing
phase
software
still
useful
small
tactical
changes
made
stage
company
usually
considering
software
replaced
final
stage
software
still
used
essential
changes
made
Users
work
around
problems
discover
Eventually
software
retired
taken
use
often
incurs
costs
data
transferred
old
system
newer
replacement
system
Evolution
processes
software
processes
no
thing
standard
software
change
evolution
process
appropriate
evolution
process
software
system
depends
type
software
maintained
software
development
processes
used
organization
skills
people
involved
types
system
mobile
apps
evolution
informal
process
change
requests
mostly
come
conversations
system
users
developers
types
systems
embedded
critical
systems
software
evolution
formalized
structured
documentation
produced
stage
process
Formal
informal
system
change
proposals
driver
system
evolution
organizations
change
proposal
individual
group
suggests
changes
updates
existing
software
system
proposals
based
existing
requirements
implemented
released
system
requests
new
requirements
bug
reports
system
stakeholders
new
ideas
software
improvement
system
development
team
processes
change
identification
system
evolution
cyclical
continue
throughout
lifetime
system
Figure
change
proposal
accepted
needs
analysis
software
work
components
need
changed
analysis
allows
cost
impact
change
assessed
part
general
process
change
management
ensure
correct
versions
@@@@@@@@@@
Evolution
processes
Figure
Change
identification
evolution
processes
Figure
general
model
software
evolution
process
Change
proposalsNew
system
Change
identification
process
Software
evolution
process
components
included
system
release
discuss
change
configuration
management
Chapter
Figure
shows
activities
involved
software
evolution
process
includes
fundamental
activities
change
analysis
release
planning
system
implementation
releasing
system
customers
cost
impact
changes
assessed
see
much
system
affected
change
much
cost
implement
change
proposed
changes
accepted
new
release
system
planned
release
planning
proposed
changes
fault
repair
adaptation
new
functionality
considered
decision
made
changes
implement
next
version
system
changes
implemented
validated
new
version
system
released
process
iterates
new
set
changes
proposed
next
release
situations
development
evolution
integrated
change
implementation
simply
iteration
development
process
Revisions
system
designed
implemented
tested
difference
initial
development
evolution
customer
feedback
delivery
considered
planning
new
releases
application
different
teams
involved
critical
difference
development
evolution
first
stage
change
implementation
requires
program
understanding
Release
planning
Change
implementation
System
release
Impact
analysis
Change
requests
Platform
adaptation
System
enhancementFault
repair
@@@@@@@@@@
Chapter
Software
evolution
Figure
Change
implementation
RequirementsupdatingSoftwaredevelopmentRequirementsanalysisProposedchanges
program
understanding
phase
new
developers
understand
program
structured
delivers
functionality
proposed
change
affect
program
need
understanding
make
sure
implemented
change
cause
new
problems
introduced
existing
system
requirements
specification
design
documents
available
updated
evolution
process
reflect
changes
required
Figure
New
software
requirements
written
analyzed
validated
design
documented
using
UML
models
models
updated
proposed
changes
prototyped
part
change
analysis
process
assess
implications
costs
making
change
However
change
requests
sometimes
relate
problems
operational
systems
tackled
urgently
urgent
changes
arise
three
reasons
serious
system
fault
detected
repaired
allow
normal
operation
continue
address
serious
security
vulnerability
changes
systems
operating
environment
unexpected
effects
disrupt
normal
operation
unanticipated
changes
business
running
system
emergence
new
competitors
introduction
new
legislation
affects
system
cases
need
make
change
quickly
means
able
update
software
documentation
Rather
modify
requirements
design
make
emergency
fix
program
solve
immediate
problem
Figure
danger
requirements
software
design
code
inconsistent
intend
document
change
requirements
design
additional
emergency
fixes
software
needed
take
priority
documentation
Eventually
original
change
forgotten
system
documentation
code
never
realigned
problem
maintaining
multiple
representations
system
one
arguments
minimal
documentation
fundamental
agile
development
processes
Emergency
system
repairs
completed
quickly
possible
choose
quick
workable
solution
rather
best
solution
far
system
structure
concerned
tends
accelerate
process
software
ageing
future
changes
progressively
difficult
maintenance
costs
increase
Ideally
emergency
code
repairs
made
new
code
refactored
Modify
source
code
Deliver
modified
system
Analyze
source
code
Change
requests
Figure
emergency
repair
process
@@@@@@@@@@
Legacy
systems
improved
avoid
program
degradation
course
code
repair
reused
possible
However
alternative
better
solution
problem
discovered
time
available
analysis
Agile
methods
processes
discussed
Chapter
used
program
evolution
well
program
development
methods
based
incremental
development
making
transition
agile
development
postdelivery
evolution
seamless
However
problems
arise
handover
development
team
separate
team
responsible
system
evolution
two
potentially
problematic
situations
development
team
used
agile
approach
evolution
team
prefers
plan
based
approach
evolution
team
expect
detailed
documentation
support
evolution
rarely
produced
agile
processes
no
definitive
statement
system
requirements
modified
changes
made
system
plan
based
approach
used
development
evolution
team
prefers
use
agile
methods
case
evolution
team
start
scratch
developing
automated
tests
code
system
refactored
simplified
expected
agile
development
case
program
reengineering
required
improve
code
used
agile
development
process
Agile
techniques
test
driven
development
automated
regression
testing
useful
system
changes
made
System
changes
expressed
user
stories
customer
involvement
help
prioritize
changes
required
operational
system
Scrum
approach
focusing
backlog
work
done
help
prioritize
important
system
changes
short
evolution
simply
involves
continuing
agile
development
process
Agile
methods
used
development
however
modified
used
program
maintenance
evolution
practically
impossible
involve
users
development
team
change
proposals
come
wide
range
stakeholders
Short
development
cycles
interrupted
deal
emergency
repairs
gap
releases
lengthened
avoid
disrupting
operational
processes
Legacy
systems
Large
companies
started
computerizing
operations
s
past
years
software
systems
introduced
Many
systems
replaced
sometimes
several
times
business
changed
evolved
However
lot
old
systems
still
use
play
critical
part
running
business
older
software
systems
sometimes
called
legacy
systems
@@@@@@@@@@
Chapter
Software
evolution
Legacy
systems
older
systems
rely
languages
technology
no
longer
used
new
systems
development
Typically
maintained
long
period
structure
degraded
changes
made
Legacy
software
dependent
older
hardware
mainframe
computers
associated
legacy
processes
procedures
impossible
change
effective
business
processes
legacy
software
cannot
modified
support
new
processes
Legacy
systems
software
systems
broader
sociotechnical
systems
include
hardware
software
libraries
supporting
software
business
processes
Figure
shows
logical
parts
legacy
system
relationships
System
hardware
Legacy
systems
written
hardware
no
longer
available
expensive
maintain
compatible
current
organizational
purchasing
policies
Support
software
legacy
system
rely
range
support
software
operating
system
utilities
provided
hardware
manufacturer
compilers
used
system
development
obsolete
no
longer
supported
original
providers
Application
software
application
system
provides
business
services
usually
made
number
application
programs
developed
different
times
programs
part
application
software
systems
Application
data
data
processed
application
system
many
legacy
systems
immense
volume
data
accumulated
lifetime
system
data
inconsistent
duplicated
several
files
spread
number
different
databases
Business
processes
processes
used
business
achieve
business
objective
example
business
process
insurance
company
issuing
insurance
policy
manufacturing
company
business
process
accepting
order
products
setting
associated
manufacturing
process
Business
processes
designed
around
legacy
system
constrained
functionality
provides
Business
policies
rules
definitions
business
carried
constraints
business
Use
legacy
application
system
embedded
policies
rules
alternative
way
looking
components
legacy
system
series
layers
shown
Figure
layer
depends
layer
immediately
interfaces
layer
interfaces
maintained
able
make
changes
layer
without
affecting
adjacent
layers
practice
however
simple
encapsulation
oversimplification
changes
one
layer
system
@@@@@@@@@@
Legacy
systems
Embeds
Application
software
Business
policies
rules
Support
software
ConstrainsUsesUsesRuns
onRuns
knowledge
ofUses
Figure
elements
legacy
system
System
hardware
Business
processes
Application
data
require
consequent
changes
layers
changed
level
reasons
follows
Changing
one
layer
system
introduce
new
facilities
higher
layers
system
changed
take
advantage
facilities
example
new
database
introduced
support
software
layer
include
facilities
access
data
web
browser
business
processes
modified
take
advantage
facility
Changing
software
slow
system
new
hardware
needed
improve
system
performance
increase
performance
new
hardware
mean
software
changes
previously
impractical
possible
often
impossible
maintain
hardware
interfaces
especially
new
hardware
introduced
particular
problem
embedded
systems
tight
coupling
software
hardware
Major
changes
application
software
required
make
effective
use
new
hardware
difficult
know
exactly
much
legacy
code
still
use
indicator
industry
estimated
billion
lines
COBOL
code
current
business
systems
COBOL
programming
language
designed
writing
business
systems
main
business
development
language
s
s
particularly
finance
industry
Mitchell
programs
still
work
effectively
efficiently
companies
using
see
no
need
change
major
problem
face
however
shortage
COBOL
programmers
original
developers
system
retire
Universities
no
longer
teach
COBOL
younger
software
engineers
interested
programming
modern
languages
Skill
shortages
one
problems
maintaining
business
legacy
systems
issues
include
security
vulnerabilities
systems
developed
widespread
use
Internet
problems
interfacing
systems
written
modern
programming
languages
original
software
tool
supplier
business
no
longer
maintain
support
tools
used
@@@@@@@@@@
Chapter
Software
evolution
Socio
technical
system
Business
processes
Application
software
Platform
infrastructure
software
Hardware
Figure
Legacy
system
layers
develop
system
system
hardware
obsolete
increasingly
expensive
maintain
businesses
simply
replace
systems
modern
equivalents
simple
answer
question
expensive
risky
legacy
system
works
effectively
costs
replacement
exceed
savings
come
reduced
support
costs
new
system
Scrapping
legacy
systems
replacing
modern
software
open
possibility
things
going
wrong
new
system
failing
meet
needs
business
Managers
try
minimize
risks
therefore
want
face
uncertainties
new
software
systems
discovered
problems
legacy
system
replacement
involved
analyzing
legacy
system
replacement
project
large
organization
enterprise
used
legacy
systems
run
business
decided
replace
systems
single
centrally
maintained
ERP
system
number
business
technology
reasons
new
system
development
failure
deliver
improvements
promised
spending
million
part
new
system
operational
worked
less
effectively
systems
replaced
Users
continued
use
older
systems
integrate
part
new
system
implemented
additional
manual
processing
required
several
reasons
expensive
risky
replace
legacy
systems
new
systems
rarely
complete
specification
legacy
system
original
specification
lost
specification
exists
unlikely
updated
system
changes
made
Therefore
no
straightforward
way
specifying
new
system
functionally
identical
system
use
Business
processes
ways
legacy
systems
operate
often
inextricably
intertwined
processes
likely
evolved
take
advantage
software
s
services
work
around
software
s
shortcomings
system
replaced
processes
change
potentially
unpredictable
costs
consequences
@@@@@@@@@@
Legacy
systems
Important
business
rules
embedded
software
documented
elsewhere
business
rule
constraint
applies
business
function
breaking
constraint
unpredictable
consequences
business
example
insurance
company
embedded
rules
assessing
risk
policy
application
software
rules
maintained
company
accept
high
risk
policies
result
expensive
future
claims
New
software
development
inherently
risky
unexpected
problems
new
system
delivered
time
price
expected
Keeping
legacy
systems
use
avoids
risks
replacement
making
changes
existing
software
inevitably
becomes
expensive
systems
get
older
Legacy
software
systems
years
old
particularly
expensive
change
program
style
usage
conventions
inconsistent
different
people
responsible
system
changes
problem
adds
difficulty
understanding
system
code
Part
system
implemented
using
obsolete
programming
languages
difficult
find
people
knowledge
languages
Expensive
outsourcing
system
maintenance
therefore
required
System
documentation
often
inadequate
date
cases
documentation
system
source
code
Many
years
maintenance
usually
degrades
system
structure
making
increasingly
difficult
understand
New
programs
added
interfaced
parts
system
ad
hoc
way
system
optimized
space
utilization
execution
speed
runs
effectively
older
slower
hardware
normally
involves
using
specific
machine
language
optimizations
usually
lead
software
hard
understand
causes
problems
programmers
learned
modern
software
engineering
techniques
don
t
understand
programming
tricks
used
optimize
software
data
processed
system
maintained
different
files
incompatible
structures
data
duplication
data
date
inaccurate
incomplete
Several
databases
different
suppliers
used
stage
costs
managing
maintaining
legacy
system
high
replaced
new
system
next
section
discuss
systematic
decision
making
approach
making
replacement
decision
@@@@@@@@@@
Chapter
Software
evolution
Legacy
system
management
new
software
systems
developed
using
modern
software
engineering
processes
agile
development
software
product
lines
possible
plan
integrate
system
development
evolution
companies
understand
system
development
process
whole
life
cycle
process
Separating
software
development
software
evolution
unhelpful
leads
higher
costs
However
discussed
still
huge
number
legacy
systems
critical
business
systems
extended
adapted
changing
e
business
practices
organizations
limited
budget
maintaining
upgrading
portfolio
legacy
systems
decide
get
best
return
investment
involves
making
realistic
assessment
legacy
systems
deciding
appropriate
strategy
evolving
systems
four
strategic
options
Scrap
system
completely
option
chosen
system
making
effective
contribution
business
processes
usually
occurs
business
processes
changed
since
system
installed
no
longer
reliant
legacy
system
Leave
system
unchanged
continue
regular
maintenance
option
chosen
system
still
required
fairly
stable
system
users
make
relatively
change
requests
Reengineer
system
improve
maintainability
option
chosen
system
quality
degraded
change
new
change
system
still
proposed
process
include
developing
new
interface
components
original
system
work
newer
systems
Replace
part
system
new
system
option
chosen
factors
new
hardware
mean
old
system
cannot
continue
operation
off
shelf
systems
allow
new
system
developed
reasonable
cost
many
cases
evolutionary
replacement
strategy
adopted
major
system
components
replaced
off
shelf
systems
components
reused
possible
assessing
legacy
system
look
business
perspective
technical
perspective
Warren
business
perspective
decide
business
really
needs
system
technical
perspective
assess
quality
application
software
system
s
support
software
hardware
use
combination
business
value
system
quality
inform
decision
legacy
system
example
assume
organization
legacy
systems
assess
quality
business
value
systems
create
chart
showing
relative
business
value
system
quality
example
@@@@@@@@@@
Legacy
systems
System
quality
Business
value
Low
quality
High
business
valueHigh
qualityLow
business
value
Low
quality
Low
business
valueHigh
qualityHigh
business
value
Figure
example
legacy
system
assessment
shown
Figure
diagram
see
four
clusters
systems
Low
quality
low
business
value
Keeping
systems
operation
expensive
rate
return
business
fairly
small
systems
scrapped
Low
quality
high
business
value
systems
making
important
business
contribution
cannot
scrapped
However
low
quality
means
expensive
maintain
systems
reengineered
improve
quality
replaced
suitable
off
shelf
systems
available
High
quality
low
business
value
systems
don
t
contribute
much
business
expensive
maintain
worth
replacing
systems
normal
system
maintenance
continued
expensive
changes
required
system
hardware
remains
use
expensive
changes
necessary
software
scrapped
High
quality
high
business
value
systems
kept
operation
However
high
quality
means
don
t
invest
transformation
system
replacement
Normal
system
maintenance
continued
business
value
system
measure
much
time
effort
system
saves
compared
manual
processes
use
systems
assess
business
value
system
identify
system
stakeholders
end
users
system
managers
ask
series
questions
system
four
basic
issues
discuss
use
system
system
used
occasionally
small
number
people
mean
low
business
value
legacy
system
developed
meet
business
need
changed
now
met
@@@@@@@@@@
Chapter
Software
evolution
effectively
ways
careful
however
occasional
important
use
systems
example
university
system
student
registration
used
beginning
academic
year
used
infrequently
essential
system
high
business
value
business
processes
supported
system
introduced
business
processes
usually
introduced
exploit
system
s
capabilities
system
inflexible
changing
business
processes
impossible
However
environment
changes
original
business
processes
obsolete
Therefore
system
low
business
value
forces
use
inefficient
business
processes
System
dependability
System
dependability
technical
problem
business
problem
system
dependable
problems
directly
affect
business
customers
mean
people
business
diverted
tasks
solve
problems
system
low
business
value
system
outputs
key
issue
importance
system
outputs
successful
functioning
business
business
depends
outputs
system
high
business
value
Conversely
outputs
cheaply
generated
way
system
produces
outputs
rarely
used
system
low
business
value
example
assume
company
provides
travel
ordering
system
used
staff
responsible
arranging
travel
place
orders
approved
travel
agent
Tickets
delivered
company
invoiced
However
business
value
assessment
reveal
system
used
fairly
small
percentage
travel
orders
placed
People
making
travel
arrangements
find
cheaper
convenient
deal
directly
travel
suppliers
websites
system
still
used
no
real
point
keeping
functionality
available
external
systems
Conversely
say
company
developed
system
keeps
track
previous
customer
orders
automatically
generates
reminders
customers
reorder
goods
results
large
number
repeat
orders
keeps
customers
satisfied
feel
supplier
aware
needs
outputs
system
important
business
system
high
business
value
assess
software
system
technical
perspective
need
consider
application
system
environment
system
operates
environment
includes
hardware
associated
support
software
compilers
debuggers
development
environments
needed
maintain
system
environment
important
many
system
changes
upgrades
hardware
operating
system
result
changes
environment
Factors
consider
environment
assessment
shown
Figure
Notice
technical
characteristics
environment
consider
reliability
suppliers
hardware
support
software
suppliers
no
longer
business
systems
supported
replace
systems
@@@@@@@@@@
Legacy
systems
Factor
Questions
Supplier
stability
Failure
rate
Age
Performance
performance
system
adequate
performance
problems
significant
effect
system
users
Support
requirements
Maintenance
costs
Interoperability
Figure
Factors
used
environment
assessment
supplier
still
existence
supplier
financially
stable
likely
continue
existence
supplier
no
longer
business
someone
maintain
systems
hardware
high
rate
reported
failures
support
software
crash
force
system
restarts
old
hardware
software
older
hardware
support
software
obsolete
still
function
correctly
significant
economic
business
benefits
moving
modern
system
local
support
required
hardware
software
high
costs
associated
support
worth
considering
system
replacement
costs
hardware
maintenance
support
software
licences
Older
hardware
higher
maintenance
costs
modern
systems
Support
software
high
annual
licensing
costs
problems
interfacing
system
systems
compilers
example
used
current
versions
operating
system
process
environmental
assessment
possible
ideally
collect
data
system
system
changes
Examples
data
useful
include
costs
maintaining
system
hardware
support
software
number
hardware
faults
occur
time
period
frequency
patches
fixes
applied
system
support
software
assess
technical
quality
application
system
assess
factors
Figure
primarily
related
system
dependability
difficulties
maintaining
system
system
documentation
collect
data
help
judge
quality
system
number
system
change
requests
System
changes
usually
corrupt
system
structure
make
changes
difficult
higher
accumulated
value
lower
quality
system
number
user
interfaces
important
factor
forms
based
systems
form
considered
separate
user
interface
interfaces
likely
inconsistencies
redundancies
interfaces
volume
data
used
system
volume
data
number
files
size
database
etc
processed
system
increases
inconsistencies
errors
data
data
collected
long
period
time
errors
inconsistencies
inevitable
Cleaning
old
data
expensive
time
consuming
process
@@@@@@@@@@
Chapter
Software
evolution
Factor
Questions
Understandability
difficult
understand
source
code
current
system
complex
control
structures
used
variables
meaningful
names
reflect
function
explicit
data
model
system
extent
data
duplicated
across
files
data
used
system
date
consistent
modern
compilers
available
programming
language
used
develop
system
programming
language
still
used
new
system
development
versions
parts
system
managed
configuration
management
system
explicit
description
versions
components
used
current
system
test
data
system
exist
record
regression
tests
carried
new
features
added
system
people
available
skills
maintain
application
people
available
experience
system
Figure
Factors
used
application
assessment
Documentation
system
documentation
available
documentation
complete
consistent
current
Data
Performance
performance
application
adequate
performance
problems
significant
effect
system
users
Programming
language
Configuration
management
Test
data
Personnel
skills
Ideally
objective
assessment
used
inform
decisions
legacy
system
However
many
cases
decisions
really
objective
based
organizational
political
considerations
example
two
businesses
merge
politically
powerful
partner
usually
keep
systems
scrap
company
s
systems
senior
management
organization
decides
move
new
hardware
platform
require
applications
replaced
no
budget
available
system
transformation
particular
year
system
maintenance
continued
even
though
result
higher
long
term
costs
Software
maintenance
Software
maintenance
general
process
changing
system
delivered
term
usually
applied
custom
software
separate
development
groups
involved
delivery
changes
made
software
simple
changes
correct
coding
errors
extensive
changes
correct
design
errors
significant
enhancements
correct
specification
errors
accommodate
new
requirements
Changes
implemented
modifying
existing
system
components
necessary
adding
new
components
system
@@@@@@@@@@
Software
maintenance
Program
evolution
dynamics
Program
evolution
dynamics
study
evolving
software
systems
pioneered
Manny
Lehman
Les
Belady
s
led
called
Lehman
s
Laws
said
apply
large
scale
software
systems
important
laws
program
continually
change
remain
useful
evolving
program
changes
structure
degraded
program
s
lifetime
rate
change
roughly
constant
independent
resources
available
incremental
change
release
system
roughly
constant
New
functionality
added
systems
increase
user
satisfaction
http
software
engineering
book
com
web
program
evolution
dynamics
three
different
types
software
maintenance
Fault
repairs
fix
bugs
vulnerabilities
Coding
errors
usually
relatively
cheap
correct
design
errors
expensive
involve
rewriting
several
program
components
Requirements
errors
expensive
repair
extensive
system
redesign
necessary
Environmental
adaptation
adapt
software
new
platforms
environments
type
maintenance
required
aspect
system
s
environment
hardware
platform
operating
system
support
software
changes
Application
systems
modified
cope
environmental
changes
Functionality
addition
add
new
features
support
new
requirements
type
maintenance
necessary
system
requirements
change
response
organizational
business
change
scale
changes
required
software
often
much
greater
types
maintenance
practice
no
clear
cut
distinction
types
maintenance
adapt
system
new
environment
add
functionality
take
advantage
new
environmental
features
Software
faults
often
exposed
users
use
system
unanticipated
ways
Changing
system
accommodate
way
working
best
way
fix
faults
types
maintenance
generally
recognized
different
people
sometimes
give
different
names
Corrective
maintenance
universally
used
refer
maintenance
fault
repair
However
adaptive
maintenance
sometimes
means
adapting
new
environment
sometimes
means
adapting
software
new
requirements
Perfective
maintenance
sometimes
means
perfecting
software
implementing
new
requirements
cases
means
maintaining
functionality
system
improving
structure
performance
naming
uncertainty
avoided
use
terms
book
@@@@@@@@@@
Chapter
Software
evolution
Figure
Maintenance
effort
distribution
Functionality
addition
modification
Fault
repair
Environmental
adaptation
Figure
shows
approximate
distribution
maintenance
costs
based
data
recent
survey
available
Davidsen
Krogstie
study
compared
maintenance
cost
distribution
number
earlier
studies
authors
found
distribution
maintenance
costs
changed
little
years
don
t
recent
data
suggests
distribution
still
largely
correct
Repairing
system
faults
expensive
maintenance
activity
Evolving
system
cope
new
environments
new
changed
requirements
generally
consumes
maintenance
effort
Experience
shown
usually
expensive
add
new
features
system
maintenance
implement
features
initial
development
reasons
new
team
understand
program
maintained
system
delivered
normal
development
team
broken
people
work
new
projects
new
team
individuals
responsible
system
maintenance
understand
system
background
system
design
decisions
need
spend
time
understanding
existing
system
implement
changes
Separating
maintenance
development
means
no
incentive
development
team
write
maintainable
software
contract
maintain
system
usually
separate
system
development
contract
different
company
rather
original
software
developer
responsible
software
maintenance
circumstances
development
team
gets
no
benefit
investing
effort
make
software
maintainable
development
team
cut
corners
save
effort
development
worthwhile
even
means
software
difficult
change
future
Program
maintenance
work
unpopular
Maintenance
poor
image
among
software
engineers
seen
less
skilled
process
system
development
@@@@@@@@@@
Software
maintenance
Documentation
System
documentation
help
maintenance
process
providing
maintainers
information
structure
organization
system
features
offers
system
users
proponents
agile
approaches
suggest
code
principal
documentation
higher
level
design
models
information
dependencies
constraints
make
easier
understand
make
changes
code
http
software
engineering
book
com
web
documentation
web
chapter
often
allocated
least
experienced
staff
Furthermore
old
systems
written
obsolete
programming
languages
developers
working
maintenance
much
experience
languages
learn
languages
maintain
system
programs
age
structure
degrades
harder
change
changes
made
programs
structure
tends
degrade
Consequently
harder
understand
change
systems
developed
without
modern
software
engineering
techniques
never
well
structured
perhaps
optimized
efficiency
rather
understandability
System
documentation
lost
inconsistent
Old
systems
subject
stringent
configuration
management
developers
spend
time
finding
right
versions
system
components
change
first
three
problems
stem
fact
many
organizations
still
consider
software
development
maintenance
separate
activities
Maintenance
seen
second
class
activity
no
incentive
spend
money
development
reduce
costs
system
change
longterm
solution
problem
think
systems
evolving
throughout
lifetime
continual
development
process
Maintenance
high
status
new
software
development
fourth
issue
problem
degraded
system
structure
ways
easiest
problem
address
Software
reengineering
techniques
described
later
chapter
applied
improve
system
structure
understandability
Architectural
transformations
adapt
system
new
hardware
Refactoring
improve
quality
system
code
make
easier
change
principle
cost
effective
invest
effort
designing
implementing
system
reduce
costs
future
changes
Adding
new
functionality
delivery
expensive
spend
time
learning
system
analyzing
impact
proposed
changes
Work
done
development
structure
software
make
easier
understand
change
reduce
evolution
costs
Good
software
engineering
techniques
precise
specification
test
first
development
use
object
oriented
development
configuration
management
help
reduce
maintenance
cost
principled
arguments
lifetime
cost
savings
investing
making
systems
maintainable
unfortunately
impossible
substantiate
real
@@@@@@@@@@
Chapter
Software
evolution
data
Collecting
data
expensive
value
data
difficult
judge
therefore
vast
majority
companies
think
worthwhile
gather
analyze
software
engineering
data
reality
businesses
reluctant
spend
software
develop
ment
reduce
longer
term
maintenance
costs
two
main
reasons
reluctance
Companies
set
quarterly
annual
spending
plans
managers
incentivized
reduce
short
term
costs
Investing
maintainability
leads
short
term
cost
increases
measurable
However
long
term
gains
t
measured
time
companies
reluctant
spend
money
something
unknown
future
return
Developers
usually
responsible
maintaining
system
developed
Consequently
don
t
see
point
additional
work
reduce
maintenance
costs
get
benefit
way
around
problem
integrate
development
maintenance
original
development
team
remains
responsible
software
throughout
lifetime
possible
software
products
companies
Amazon
develop
maintain
software
O
Hanlon
However
custom
software
developed
software
company
client
unlikely
happen
Maintenance
prediction
Maintenance
prediction
concerned
trying
assess
changes
required
software
system
identifying
parts
system
likely
expensive
change
understand
design
software
components
likely
change
make
adaptable
invest
effort
improving
components
reduce
lifetime
maintenance
costs
predicting
changes
assess
overall
maintenance
costs
system
given
time
period
set
budget
maintaining
software
Figure
shows
possible
predictions
questions
predictions
answer
Predicting
number
change
requests
system
requires
understanding
relationship
system
external
environment
systems
complex
relationship
external
environment
changes
environment
inevitably
result
changes
system
evaluate
relationships
system
environment
look
number
complexity
system
interfaces
larger
number
interfaces
complex
interfaces
likely
interface
changes
required
new
requirements
proposed
@@@@@@@@@@
Software
maintenance
parts
system
expensive
Predicting
maintainability
Predicting
system
changes
Predicting
maintenance
costs
lifetime
maintenance
costs
system
costs
maintaining
system
next
year
maintain
many
change
requests
expected
parts
system
likely
affected
change
requests
Figure
number
inherently
volatile
system
requirements
discussed
Chapter
Maintenance
prediction
requirements
reflect
organizational
policies
procedures
likely
volatile
requirements
based
stable
domain
characteristics
business
processes
system
used
business
processes
evolve
generate
system
change
requests
system
integrated
business
processes
increased
demands
changes
early
work
software
maintenance
researchers
looked
relationships
program
complexity
maintainability
Banker
et
al
Coleman
et
al
Kozlov
et
al
studies
found
complex
system
component
expensive
maintain
Complexity
measurements
particularly
useful
identifying
program
components
likely
expensive
maintain
Therefore
reduce
maintenance
costs
try
replace
complex
system
components
simpler
alternatives
system
put
service
able
use
process
data
help
predict
maintainability
Examples
process
metrics
used
assess
ing
maintainability
Number
requests
corrective
maintenance
increase
number
bug
failure
reports
indicate
errors
introduced
program
repaired
maintenance
process
indicate
decline
maintainability
Average
time
required
impact
analysis
related
number
program
components
affected
change
request
time
required
impact
analysis
increases
implies
components
affected
maintainability
decreasing
@@@@@@@@@@
Chapter
Software
evolution
Average
time
taken
implement
change
request
time
impact
analysis
correlate
amount
time
need
modify
system
documentation
assessed
components
affected
increase
time
needed
implement
change
indicate
decline
maintainability
Number
outstanding
change
requests
increase
number
time
imply
decline
maintainability
use
predicted
information
change
requests
predictions
system
maintainability
predict
maintenance
costs
managers
combine
information
intuition
experience
estimate
costs
COCOMO
model
cost
estimation
discussed
Chapter
suggests
estimate
software
maintenance
effort
based
effort
understand
existing
code
effort
develop
new
code
Software
reengineering
Software
maintenance
involves
understanding
program
changed
implementing
required
changes
However
many
systems
especially
older
legacy
systems
difficult
understand
change
programs
optimized
performance
space
utilization
expense
understandability
time
initial
program
structure
corrupted
series
changes
make
legacy
software
systems
easier
maintain
reengineer
systems
improve
structure
understandability
Reengineering
involve
redocumenting
system
refactoring
system
architecture
translating
programs
modern
programming
language
modifying
updating
structure
values
system
s
data
functionality
software
changed
normally
try
avoid
making
major
changes
system
architecture
Reengineering
two
important
advantages
replacement
Reduced
risk
high
risk
redeveloping
business
critical
software
Errors
made
system
specification
development
problems
Delays
introducing
new
software
mean
business
lost
extra
costs
incurred
Reduced
cost
cost
reengineering
significantly
less
cost
developing
new
software
Ulrich
Ulrich
quotes
example
commercial
system
reimplementation
costs
estimated
million
system
successfully
reengineered
million
suspect
modern
software
technology
relative
cost
reimplementation
probably
less
Ulrich
s
figure
still
costs
reengineering
@@@@@@@@@@
Software
maintenance
Reverse
engineering
Program
documentation
Data
reengineering
Program
structure
improvement
Program
modularization
Restructured
program
Original
program
Source
code
translation
Reengineered
program
Original
data
Reengineered
data
Figure
Figure
general
model
reengineering
process
input
pro
reengineering
process
cess
legacy
program
output
improved
restructured
version
program
activities
reengineering
process
Source
code
translation
Using
translation
tool
convert
program
old
programming
language
modern
version
language
different
language
Reverse
engineering
program
analyzed
information
extracted
helps
document
organization
functionality
process
usually
completely
automated
Program
structure
improvement
control
structure
program
analyzed
modified
make
easier
read
understand
partially
automated
manual
intervention
usually
required
Program
modularization
Related
parts
program
grouped
together
appropriate
redundancy
removed
cases
stage
involve
architectural
refactoring
e
g
system
uses
several
different
data
stores
refactored
use
single
repository
manual
process
Data
reengineering
data
processed
program
changed
reflect
program
changes
mean
redefining
database
schemas
converting
existing
databases
new
structure
usually
clean
data
involves
finding
correcting
mistakes
removing
duplicate
records
expensive
prolonged
process
Program
reengineering
necessarily
require
steps
Figure
don
t
need
source
code
translation
still
use
application
s
programming
language
reengineering
automatically
recovering
documentation
reverse
engineering
unnecessary
Data
reengineering
required
data
structures
program
change
system
reengineering
@@@@@@@@@@
Chapter
Software
evolution
Automated
program
Program
data
restructuring
restructuring
Automated
source
Automated
restructuring
Restructuring
plus
code
conversion
manual
changes
architectural
changes
Figure
Reengineering
approaches
Increased
cost
make
reengineered
system
interoperate
new
software
develop
adaptor
services
discussed
Chapter
hide
original
interfaces
software
system
present
new
better
structured
interfaces
used
components
process
legacy
system
wrapping
important
technique
developing
large
scale
reusable
services
costs
reengineering
obviously
depend
extent
work
carried
spectrum
possible
approaches
reengineering
shown
Figure
Costs
increase
left
right
source
code
translation
cheapest
option
reengineering
part
architectural
migration
expensive
problem
software
reengineering
practical
limits
much
improve
system
reengineering
isn
t
possible
example
convert
system
written
using
functional
approach
object
oriented
system
Major
architectural
changes
radical
reorganizing
system
data
management
cannot
carried
automatically
expensive
reengineering
improve
maintainability
reengineered
system
probably
maintainable
new
system
developed
using
modern
software
engineering
methods
Refactoring
Refactoring
process
making
improvements
program
slow
degradation
change
means
modifying
program
improve
structure
reduce
complexity
make
easier
understand
Refactoring
sometimes
considered
limited
object
oriented
development
principles
fact
applied
development
approach
refactor
program
add
functionality
rather
concentrate
program
improvement
therefore
think
refactoring
preventative
maintenance
reduces
problems
future
change
Refactoring
inherent
part
agile
methods
methods
based
change
Program
quality
liable
degrade
quickly
agile
developers
frequently
refactor
programs
avoid
degradation
emphasis
regression
testing
agile
methods
lowers
risk
introducing
new
errors
refactoring
errors
introduced
detectable
previously
successful
tests
fail
However
refactoring
dependent
agile
activities
@@@@@@@@@@
Software
maintenance
reengineering
refactoring
intended
make
software
easier
understand
change
thing
Reengineering
takes
place
system
maintained
time
maintenance
costs
increasing
use
automated
tools
process
reengineer
legacy
system
create
new
system
maintainable
Refactoring
continuous
process
improvement
throughout
development
evolution
process
intended
avoid
structure
code
degradation
increases
costs
difficulties
maintaining
system
Fowler
et
al
Fowler
et
al
suggest
stereotypical
situations
Fowler
calls
bad
smells
code
program
improved
Examples
bad
smells
improved
refactoring
include
Duplicate
code
similar
code
included
different
places
program
removed
implemented
single
method
function
called
required
Long
methods
method
long
redesigned
number
shorter
methods
Switch
case
statements
often
involve
duplication
switch
depends
type
value
switch
statements
scattered
around
program
object
oriented
languages
often
use
polymorphism
achieve
thing
Data
clumping
Data
clumps
occur
group
data
items
fields
classes
parameters
methods
reoccurs
several
places
program
often
replaced
object
encapsulates
data
Speculative
generality
occurs
developers
include
generality
program
case
required
future
often
simply
removed
Fowler
book
website
suggests
primitive
refactoring
transformations
used
singly
together
deal
bad
smells
Examples
transformations
include
Extract
method
remove
duplication
create
new
method
Consolidate
conditional
expression
replace
sequence
tests
single
test
Pull
method
replace
similar
methods
subclasses
single
method
superclass
Interactive
development
environments
Eclipse
usually
include
refactoring
support
editors
makes
easier
find
dependent
parts
program
changed
implement
refactoring
Refactoring
carried
program
development
effective
way
reduce
long
term
maintenance
costs
program
However
take
program
maintenance
structure
significantly
degraded
practically
impossible
refactor
code
alone
think
design
refactoring
likely
expensive
difficult
problem
Design
refactoring
involves
identifying
relevant
design
patterns
discussed
Chapter
replacing
existing
code
code
implements
design
patterns
Kerievsky
@@@@@@@@@@
Chapter
Software
evolution
Key
Points
Software
development
evolution
thought
integrated
iterative
process
represented
using
spiral
model
custom
systems
costs
software
maintenance
usually
exceed
software
development
costs
process
software
evolution
driven
requests
changes
includes
change
impact
analysis
release
planning
change
implementation
Legacy
systems
older
software
systems
developed
using
obsolete
software
hardware
technologies
remain
useful
business
often
cheaper
less
risky
maintain
legacy
system
develop
replacement
system
using
modern
technology
business
value
legacy
system
quality
application
software
environment
assessed
determine
system
replaced
transformed
maintained
three
types
software
maintenance
namely
bug
fixing
modifying
software
work
new
environment
implementing
new
changed
requirements
Software
reengineering
concerned
restructuring
redocumenting
software
make
easier
understand
change
Refactoring
making
small
program
changes
preserve
functionality
thought
preventative
maintenance
rEading
Working
Effectively
Legacy
Code
Solid
practical
advice
problems
difficulties
dealing
legacy
systems
M
Feathers
John
Wiley
Sons
Economics
Software
Maintenance
st
Century
article
general
introduction
maintenance
comprehensive
discussion
maintenance
costs
Jones
discusses
factors
affect
maintenance
costs
suggests
software
workforce
involved
software
maintenance
activities
C
Jones
http
www
compaid
com
caiinternet
ezine
capersjones
maintenance
pdf
t
Agile
Maintenance
spite
title
blog
post
argues
agile
techniques
appropriate
maintenance
discusses
techniques
suggested
XP
effective
J
Bird
http
swreflections
blogspot
co
uk
cant
agile
maintenance
html
Software
Reengineering
Testing
Considerations
excellent
summary
white
paper
maintenance
issues
major
Indian
software
company
Y
Kumar
Dipti
http
www
infosys
com
engineering
services
white
papers
Documents
software
re
engineeringprocesses
pdf
@@@@@@@@@@
Chapter
References
WEbSitE
PowerPoint
slides
chapter
www
pearsonglobaleditions
com
Sommerville
Links
supporting
videos
http
software
engineering
book
com
videos
implementation
evolution
ExErCiSES
Explain
advances
technology
force
software
subsystem
undergo
change
run
risk
becoming
useless
Figure
see
impact
analysis
important
subprocess
software
evolution
process
Using
diagram
suggest
activities
involved
change
impact
analysis
Explain
legacy
systems
thought
sociotechnical
systems
rather
simply
software
systems
developed
using
old
technology
software
subsystems
seen
low
quality
high
business
value
Discuss
subsystems
re
engineered
minimal
impact
operations
organization
strategic
options
legacy
system
evolution
normally
replace
part
system
rather
continue
maintenance
software
Explain
problems
support
software
mean
organization
replace
legacy
systems
software
project
manager
company
specializes
development
software
offshore
oil
industry
given
task
discovering
factors
affect
maintainability
systems
developed
company
Suggest
set
program
analyze
maintenance
process
determine
appropriate
maintainability
metrics
company
Briefly
describe
three
main
types
software
maintenance
sometimes
difficult
distinguish
Explain
differences
software
reengineering
refactoring
software
engineers
professional
responsibility
develop
code
easily
maintained
even
employer
explicitly
request
rEFErEnCES
Banker
R
D
S
M
Datar
C
F
Kemerer
D
Zweig
Software
Complexity
Maintenance
Costs
Comm
ACM
doi
Coleman
D
D
Ash
B
Lowther
P
Oman
Using
Metrics
Evaluate
Software
System
Maintainability
IEEE
Computer
doi
@@@@@@@@@@
Chapter
Software
evolution
Davidsen
M
G
J
Krogstie
Longitudinal
Study
Development
Maintenance
Information
Software
Technology
doi
j
infsof
Erlikh
L
Leveraging
Legacy
System
Dollars
E
Business
Professional
June
doi
Fowler
M
K
Beck
J
Brant
W
Opdyke
D
Roberts
Refactoring
Improving
Design
Existing
Code
Boston
Addison
Wesley
Hopkins
R
K
Jenkins
Eating
Elephant
Moving
Greenfield
Development
Brownfield
Boston
IBM
Press
Jones
T
C
Economics
Software
Maintenance
st
Century
www
compaid
com
caiinternet
ezine
capersjones
maintenance
pdf
Kerievsky
J
Refactoring
Patterns
Boston
Addison
Wesley
Kozlov
D
J
Koskinen
M
Sakkinen
J
Markkula
Assessing
Maintainability
Change
Multiple
Software
Releases
J
Software
Maintenance
Evolution
doi
smr
Lientz
B
P
E
B
Swanson
Software
Maintenance
Management
Reading
MA
Addison
Wesley
Mitchell
R
M
COBOL
Mainframe
Future
Computerworld
US
http
features
techworld
com
applications
cobol
mainframe
future
O
Hanlon
C
Conversation
Werner
Vogels
ACM
Queue
doi
Rajlich
V
T
K
H
Bennett
Staged
Model
Software
Life
Cycle
IEEE
Computer
doi
Ulrich
W
M
Evolutionary
Growth
Software
Reengineering
Decade
Ahead
American
Programmer
Warren
ed
Renaissance
Legacy
Systems
London
Springer
@@@@@@@@@@
PART
Dependabilityand
Security
software
systems
now
part
aspects
lives
believe
significant
challenge
face
software
engineering
ensuring
trust
systems
trust
system
confidence
available
required
perform
expected
secure
computers
data
threatened
recover
quickly
event
failure
cyberattack
part
book
therefore
focuses
important
topics
software
system
dependability
security
Chapter
introduces
basic
concepts
dependability
security
namely
reliability
availability
safety
security
resilience
explain
building
secure
dependable
systems
simply
technical
problem
introduce
redundancy
diversity
fundamental
mechanisms
used
create
dependable
secure
systems
individual
dependability
attributes
covered
detail
following
chapters
Chapter
focuses
reliability
availability
explain
attributes
specified
probabilities
failure
downtime
discuss
number
architectural
patterns
fault
tolerant
system
architectures
development
techniques
used
reduce
number
faults
system
final
section
explain
reliability
system
tested
measured
@@@@@@@@@@
systems
safety
critical
systems
system
failure
endanger
people
Chapter
concerned
safety
engineering
techniques
used
develop
safety
critical
systems
explain
safety
broader
notion
reliability
discuss
methods
deriving
system
safety
requirements
explain
defined
documented
processes
safety
critical
systems
engineering
important
describe
software
safety
cases
structured
documents
used
justify
system
safe
Threats
security
systems
one
major
problems
faced
today
s
societies
devote
two
chapters
topic
Chapter
concerned
application
security
engineering
methods
used
achieve
security
individual
software
systems
explain
relationships
security
dependability
attributes
cover
security
requirements
engineering
secure
systems
design
security
testing
Chapter
new
chapter
addresses
broader
issue
resilience
resilient
system
continue
deliver
essential
services
even
individual
parts
system
fail
subject
cyberattack
explain
basics
cybersecurity
discuss
resilience
achieved
using
redundancy
diversity
empowering
people
well
technical
mechanisms
Finally
discuss
systems
software
design
issues
contribute
improving
resilience
system
@@@@@@@@@@
Dependable
systems
Objectives
objective
chapter
introduce
topic
software
dependability
involved
developing
dependable
software
systems
read
chapter
understand
dependability
security
important
attributes
software
systems
understand
five
important
dimensions
dependability
namely
availability
reliability
safety
security
resilience
understand
notion
sociotechnical
systems
consider
systems
whole
rather
software
systems
know
redundancy
diversity
fundamental
concepts
used
achieving
dependable
systems
processes
aware
potential
using
formal
methods
dependable
systems
engineering
Contents
Dependability
properties
Sociotechnical
systems
Redundancy
diversity
Dependable
processes
Formal
methods
dependability
@@@@@@@@@@
Chapter
Dependable
systems
computer
systems
deeply
embedded
business
personal
lives
problems
result
system
software
failure
increasing
failure
server
software
e
commerce
company
lead
major
loss
revenue
customers
company
software
error
embedded
control
system
car
lead
expensive
recalls
model
repair
worst
case
contributory
factor
accidents
infection
company
PCs
malware
requires
expensive
clean
operations
sort
problem
lead
loss
damage
sensitive
information
software
intensive
systems
important
governments
companies
individuals
able
trust
systems
software
available
needed
operate
correctly
without
undesirable
side
effects
unauthorized
information
disclosure
short
able
depend
software
systems
term
dependability
proposed
Jean
Claude
Laprie
cover
related
systems
attributes
availability
reliability
safety
security
ideas
revised
next
years
discussed
definitive
paper
published
Avizienis
et
al
discuss
Section
properties
inextricably
linked
single
term
cover
makes
sense
dependability
systems
usually
important
detailed
functionality
following
reasons
System
failures
affect
large
number
people
Many
systems
include
functionality
rarely
used
functionality
left
system
small
number
users
affected
System
failures
affect
availability
system
potentially
affect
users
system
Unavailable
systems
mean
normal
business
impossible
Users
often
reject
systems
unreliable
unsafe
insecure
users
find
system
unreliable
insecure
refuse
use
Furthermore
refuse
buy
use
products
company
produced
unreliable
system
want
repetition
bad
experience
undependable
system
System
failure
costs
enormous
applications
reactor
control
system
aircraft
navigation
system
cost
system
failure
orders
magnitude
greater
cost
control
system
Failures
systems
control
critical
infrastructure
power
network
widespread
economic
consequences
Undependable
systems
cause
information
loss
Data
expensive
collect
maintain
usually
worth
much
computer
system
processed
cost
recovering
lost
corrupt
data
usually
high
However
system
useful
without
dependable
don
t
think
word
processor
used
write
book
dependable
system
sometimes
freezes
restarted
Nevertheless
useful
@@@@@@@@@@
Chapter
Dependable
systems
Critical
systems
classes
system
critical
systems
system
failure
result
injury
people
damage
environment
extensive
economic
losses
Examples
critical
systems
include
embedded
systems
medical
devices
insulin
pump
safety
critical
spacecraft
navigation
systems
mission
critical
online
money
transfer
systems
business
critical
Critical
systems
expensive
develop
developed
failures
rare
include
recovery
mechanisms
used
failures
occur
http
software
engineering
book
com
web
critical
systems
prepared
tolerate
occasional
failure
However
reflect
lack
trust
system
save
work
frequently
keep
multiple
backup
copies
compensate
lack
system
dependability
actions
limit
damage
result
system
failure
Building
dependable
software
part
general
process
dependable
systems
engineering
discuss
Section
software
part
broader
system
executes
operational
environment
includes
hardware
software
executes
human
users
software
organizational
business
processes
software
used
designing
dependable
system
therefore
consider
Hardware
failure
System
hardware
fail
mistakes
design
components
fail
result
manufacturing
errors
environmental
factors
dampness
high
temperatures
components
reached
end
natural
life
Software
failure
System
software
fail
mistakes
specification
design
implementation
Operational
failure
Human
users
fail
use
operate
system
intended
designers
hardware
software
reliable
failures
operation
now
perhaps
largest
single
cause
system
failures
failures
often
interrelated
failed
hardware
component
mean
system
operators
cope
unexpected
situation
additional
workload
puts
stress
people
stress
often
make
mistakes
mistakes
cause
software
fail
means
work
operators
even
stress
result
particularly
important
designers
dependable
software
intensive
systems
take
holistic
sociotechnical
systems
perspective
rather
focus
single
aspect
system
software
hardware
hardware
software
operational
processes
designed
separately
without
taking
account
potential
weaknesses
parts
system
likely
errors
occur
interfaces
different
parts
system
@@@@@@@@@@
Chapter
Dependable
systems
Dependability
properties
us
familiar
problem
computer
system
failure
no
obvious
reason
computers
sometimes
crash
go
wrong
way
Programs
running
computers
operate
expected
occasionally
corrupt
data
managed
system
learned
live
failures
us
completely
trust
personal
computers
normally
use
dependability
computer
system
property
system
reflects
trustworthiness
Trustworthiness
essentially
means
degree
confidence
user
system
operate
expect
system
fail
normal
use
meaningful
express
dependability
numerically
Rather
relative
terms
dependable
dependable
ultradependable
reflect
degree
trust
system
five
principal
dimensions
dependability
shown
Figure
Availability
Informally
availability
system
probability
running
able
deliver
useful
services
users
given
time
Reliability
Informally
reliability
system
probability
given
period
time
system
correctly
deliver
services
expected
user
Safety
Informally
safety
system
judgment
likely
system
cause
damage
people
environment
Security
Informally
security
system
judgment
likely
system
resist
accidental
deliberate
intrusions
Resilience
Informally
resilience
system
judgment
well
system
maintain
continuity
critical
services
presence
disruptive
events
equipment
failure
cyberattacks
Resilience
recent
addition
set
dependability
properties
originally
suggested
Laprie
dependability
properties
shown
Figure
complex
properties
broken
several
simpler
properties
example
security
includes
integrity
ensuring
systems
program
data
damaged
confidentiality
ensuring
information
accessed
people
authorized
Reliability
includes
correctness
ensuring
system
services
specified
precision
ensuring
information
delivered
appropriate
level
detail
timeliness
ensuring
information
delivered
required
course
dependability
properties
critical
systems
insulin
pump
system
introduced
Chapter
important
properties
reliability
deliver
correct
dose
insulin
safety
never
deliver
dangerous
dose
insulin
Security
issue
pump
store
confidential
information
networked
cannot
maliciously
attacked
@@@@@@@@@@
Dependability
properties
Dependability
Availability
Reliability
SecuritySafety
Resilience
ability
system
protect
deliberate
accidental
intrusion
ability
system
resist
recover
damaging
events
ability
system
operate
without
catastrophic
failure
ability
system
deliver
services
specified
ability
system
deliver
services
requested
Figure
Principal
wilderness
weather
system
availability
reliability
important
dependability
properties
costs
repair
high
Mentcare
patient
properties
information
system
security
resilience
particularly
important
sensitive
private
data
maintained
need
system
available
patient
consultations
system
properties
closely
related
five
dependability
properties
influence
system
s
dependability
Repairability
System
failures
inevitable
disruption
caused
failure
minimized
system
repaired
quickly
possible
diagnose
problem
access
component
failed
make
changes
fix
component
Repairability
software
enhanced
organization
using
system
access
source
code
skills
make
changes
Open
source
software
makes
easier
reuse
components
make
difficult
Maintainability
systems
used
new
requirements
emerge
important
maintain
value
system
changing
include
new
requirements
Maintainable
software
software
adapted
economically
cope
new
requirements
low
probability
making
changes
introduce
new
errors
system
Error
tolerance
property
considered
part
usability
reflects
extent
system
designed
user
input
errors
avoided
tolerated
user
errors
occur
system
far
possible
detect
errors
fix
automatically
request
user
re
input
data
notion
system
dependability
encompassing
property
introduced
dependability
properties
availability
security
reliability
safety
resilience
closely
related
Safe
system
operation
usually
depends
system
available
operating
reliably
system
unreliable
intruder
corrupted
data
Denial
service
attacks
system
intended
@@@@@@@@@@
Chapter
Dependable
systems
compromise
system
s
availability
system
infected
virus
cannot
confident
reliability
safety
virus
change
behavior
develop
dependable
software
therefore
need
ensure
avoid
introduction
accidental
errors
system
software
specification
development
design
verification
validation
processes
effective
discovering
residual
errors
affect
dependability
system
design
system
fault
tolerant
continue
working
things
go
wrong
design
protection
mechanisms
guard
external
attacks
compromise
availability
security
system
configure
deployed
system
supporting
software
correctly
operating
environment
include
system
capabilities
recognize
external
cyberattacks
resist
attacks
design
systems
quickly
recover
system
failures
cyberattacks
without
loss
critical
data
need
fault
tolerance
means
dependable
systems
include
redundant
code
help
monitor
detect
erroneous
states
recover
faults
failures
occur
affects
performance
systems
additional
checking
required
time
system
executes
Therefore
designers
usually
trade
off
performance
dependability
need
leave
checks
system
slow
system
However
consequential
risk
system
fails
fault
detected
Building
dependable
systems
expensive
Increasing
dependability
system
means
incur
extra
costs
system
design
implementation
validation
Verification
validation
costs
particularly
high
systems
ultra
dependable
safety
critical
control
systems
well
validating
system
meets
requirements
validation
process
prove
external
regulator
system
safe
example
aircraft
systems
demonstrate
regulators
Federal
Aviation
Authority
probability
catastrophic
system
failure
affects
aircraft
safety
extremely
low
Figure
shows
relationship
costs
incremental
improvements
dependability
software
dependable
get
significant
improvements
fairly
cheaply
using
better
software
engineering
However
already
using
good
practice
costs
improvement
much
greater
benefits
improvement
less
problem
testing
software
demonstrate
dependable
Solving
problem
relies
running
many
tests
looking
number
failures
occur
software
becomes
dependable
see
fewer
@@@@@@@@@@
Sociotechnical
systems
Cost
Low
Medium
High
Ultra
Figure
Cost
high
high
dependability
curve
Dependability
fewer
failures
Consequently
tests
needed
try
assess
many
problems
remain
software
Testing
expensive
process
significantly
increase
cost
high
dependability
systems
Sociotechnical
systems
computer
system
software
hardware
interdependent
Without
hardware
software
system
abstraction
simply
representation
human
knowledge
ideas
Without
software
hardware
set
inert
electronic
devices
However
put
together
form
system
create
machine
carry
complex
computations
deliver
results
computations
environment
illustrates
one
fundamental
characteristics
system
sum
parts
Systems
properties
apparent
components
integrated
operate
together
Software
systems
isolated
systems
part
extensive
systems
human
social
organizational
purpose
Therefore
software
engineering
isolated
activity
intrinsic
part
systems
engineering
Chapter
example
wilderness
weather
system
software
controls
instruments
weather
station
communicates
software
systems
part
wider
national
international
weather
forecasting
systems
well
hardware
software
systems
include
processes
forecasting
weather
people
operate
system
analyze
outputs
system
includes
organizations
depend
system
help
provide
weather
forecasts
individuals
government
industry
@@@@@@@@@@
Chapter
Dependable
systems
Systems
Equipment
Operating
system
Communications
data
management
Application
system
Business
processes
Organization
Society
Software
engineering
engineering
Figure
sociotechnical
systems
stack
broader
systems
called
sociotechnical
systems
include
nontechnical
elements
people
processes
regulations
well
technical
components
computers
software
equipment
System
dependability
influenced
elements
sociotechnical
system
hardware
software
people
organizations
Sociotechnical
systems
complex
impossible
understand
whole
Rather
view
layers
shown
Figure
layers
make
sociotechnical
systems
stack
equipment
layer
composed
hardware
devices
computers
operating
system
layer
interacts
hardware
provides
set
common
facilities
higher
software
layers
system
communications
data
management
layer
extends
operating
system
facilities
provides
interface
allows
interaction
extensive
functionality
access
remote
systems
access
system
database
sometimes
called
middleware
application
operating
system
application
layer
delivers
application
specific
functionality
required
many
different
application
programs
layer
business
process
layer
includes
organizational
business
processes
make
use
software
system
organizational
layer
includes
higher
level
strategic
processes
well
business
rules
policies
norms
followed
using
system
social
layer
refers
laws
regulations
society
govern
operation
system
@@@@@@@@@@
Sociotechnical
systems
Notice
no
separate
software
layer
Software
one
kind
another
important
part
layers
sociotechnical
system
Equipment
controlled
embedded
software
operating
system
applications
software
Business
processes
organizations
society
rely
Internet
software
global
software
systems
principle
interactions
neighboring
layers
stack
layer
hiding
detail
layer
layer
practice
however
unexpected
interactions
layers
result
problems
system
whole
example
say
change
law
governing
access
personal
information
comes
social
layer
leads
new
organizational
procedures
changes
business
processes
application
system
able
provide
required
level
privacy
changes
implemented
communications
data
management
layer
Thinking
holistically
systems
rather
simply
considering
software
isolation
essential
considering
software
security
dependability
Software
intangible
even
damaged
easily
cheaply
restored
However
software
failures
ripple
parts
system
affect
software
s
physical
human
environment
consequences
failure
significant
Important
data
lost
corrupted
People
extra
work
contain
recover
failure
example
equipment
damaged
data
lost
corrupted
confidentiality
breached
unknown
consequences
therefore
take
system
level
view
designing
software
dependable
secure
take
account
consequences
software
failures
elements
system
need
understand
system
elements
cause
software
failure
help
protect
recover
software
failures
important
ensure
possible
software
failure
lead
overall
system
failure
therefore
examine
software
interacts
immediate
environment
ensure
Software
failures
far
possible
contained
enclosing
layer
system
stack
seriously
affect
operation
layers
system
understand
faults
failures
layers
systems
stack
affect
software
consider
checks
built
software
help
detect
failures
support
provided
recovering
failure
software
inherently
flexible
unexpected
system
problems
often
left
software
engineers
solve
Say
radar
installation
sited
ghosting
radar
image
occurs
impractical
move
radar
site
less
interference
systems
engineers
find
another
way
removing
@@@@@@@@@@
Chapter
Dependable
systems
ghosting
solution
enhance
image
processing
capabilities
software
remove
ghost
images
slow
software
performance
becomes
unacceptable
problem
characterized
software
failure
fact
failure
design
process
system
whole
sort
situation
software
engineers
left
problem
enhancing
software
capabilities
without
increasing
hardware
cost
common
Many
called
software
failures
consequence
inherent
software
problems
rather
result
trying
change
software
accommodate
modified
system
engineering
requirements
good
example
failure
Denver
airport
baggage
system
Swartz
controlling
software
expected
deal
limitations
equipment
used
Regulation
compliance
general
model
economic
organization
now
universal
world
privately
owned
companies
offer
goods
services
make
profit
competitive
environment
companies
compete
cost
quality
delivery
time
However
ensure
safety
citizens
governments
limit
freedom
privately
owned
companies
follow
certain
standards
ensure
products
safe
secure
company
therefore
cannot
offer
products
sale
cheaply
reduced
costs
reducing
safety
products
Governments
created
set
rules
regulations
different
areas
define
standards
safety
security
established
regulators
regulatory
bodies
job
ensure
companies
offering
products
area
comply
rules
Regulators
wide
powers
fine
companies
even
imprison
directors
regulations
breached
licensing
role
e
g
aviation
nuclear
industries
issue
license
new
system
used
Therefore
aircraft
manufacturers
certificate
airworthiness
regulator
country
aircraft
used
achieve
certification
companies
developing
safety
critical
systems
produce
extensive
safety
case
discussed
Chapter
shows
rules
regulations
followed
case
convince
regulator
system
operate
safely
Developing
safety
case
costly
expensive
develop
documentation
certification
develop
system
Regulation
compliance
following
rules
applies
sociotechnical
system
whole
simply
software
element
system
example
regulator
nuclear
industry
concerned
event
overheating
nuclear
reactor
release
radioactivity
environment
Arguments
convince
regulator
case
based
software
protection
systems
operational
process
used
monitor
reactor
core
integrity
structures
contain
release
radioactivity
@@@@@@@@@@
Redundancy
diversity
elements
safety
case
protection
system
safety
case
demonstrates
software
operate
correctly
shut
reactor
intended
overall
case
show
software
protection
system
fails
alternative
safety
mechanisms
rely
software
invoked
Redundancy
diversity
Component
failures
system
inevitable
People
make
mistakes
undiscovered
bugs
software
cause
undesirable
behavior
hardware
burns
use
range
strategies
reduce
number
human
failures
replacing
hardware
components
end
predicted
lifetime
checking
software
using
static
analysis
tools
However
cannot
sure
eliminate
component
failures
therefore
design
systems
individual
component
failures
lead
overall
system
failure
Strategies
achieve
enhance
dependability
rely
redundancy
diversity
Redundancy
means
spare
capacity
included
system
used
part
system
fails
Diversity
means
redundant
components
system
different
types
thus
increasing
chances
fail
exactly
way
use
redundancy
diversity
enhance
dependability
everyday
lives
Commonly
secure
homes
use
one
lock
redundancy
usually
locks
used
different
types
diversity
means
intruders
find
way
defeat
one
locks
find
different
way
defeating
locks
gain
entry
matter
routine
back
computers
maintain
redundant
copies
data
avoid
problems
disk
failure
backups
kept
separate
diverse
external
device
Software
systems
designed
dependability
include
redundant
components
provide
functionality
system
components
switched
system
primary
component
fails
redundant
components
diverse
components
common
fault
replicated
components
result
system
failure
Another
form
redundancy
inclusion
checking
code
strictly
necessary
system
function
code
detect
kinds
problems
data
corruption
cause
failures
invoke
recovery
mechanisms
correct
problems
ensure
system
continues
operate
systems
availability
critical
requirement
redundant
servers
normally
used
automatically
come
operation
designated
server
fails
Sometimes
ensure
attacks
system
cannot
exploit
common
vulnerability
servers
different
types
run
different
operating
systems
Using
different
operating
systems
example
software
diversity
@@@@@@@@@@
Chapter
Dependable
systems
Ariane
explosion
European
Space
Agency
s
Ariane
rocket
exploded
seconds
lift
off
maiden
flight
fault
caused
software
systems
failure
backup
system
diverse
software
backup
computer
failed
exactly
way
rocket
satellite
payload
destroyed
http
software
engineering
book
com
web
ariane
redundancy
similar
functionality
provided
different
ways
discuss
software
diversity
detail
Chapter
Diversity
redundancy
used
design
dependable
software
development
processes
Dependable
development
processes
avoid
introduction
faults
system
dependable
process
activities
software
validation
rely
single
tool
technique
improves
software
dependability
reduces
chances
process
failure
human
errors
made
software
development
process
lead
software
errors
example
validation
activities
include
program
testing
manual
program
inspections
static
analysis
fault
finding
techniques
one
techniques
find
faults
missed
methods
Furthermore
different
team
members
responsible
process
activity
e
g
program
inspection
People
tackle
tasks
different
ways
depending
personality
experience
education
kind
redundancy
provides
diverse
perspective
system
However
discuss
Chapter
using
software
redundancy
diversity
introduce
bugs
software
Diversity
redundancy
make
systems
complex
usually
harder
understand
code
write
check
additional
functionality
added
system
detect
component
failure
switch
control
alternative
components
additional
complexity
means
likely
programmers
make
errors
less
likely
people
checking
system
find
errors
engineers
therefore
think
software
cannot
wear
best
avoid
software
redundancy
diversity
view
best
approach
design
software
simple
possible
extremely
rigorous
software
verification
validation
procedures
Parnas
van
Schouwen
Shu
spent
verification
validation
savings
result
develop
redundant
software
components
approaches
used
commercial
safety
critical
software
systems
example
Airbus
flight
control
hardware
software
diverse
redundant
flight
control
software
Boeing
runs
redundant
hardware
computer
runs
software
extensively
validated
Boeing
flight
control
system
designers
focused
simplicity
rather
redundancy
aircraft
reliable
diverse
simple
approach
dependability
clearly
successful
@@@@@@@@@@
Dependable
processes
Dependable
operational
processes
chapter
discusses
dependable
development
processes
system
operational
processes
equally
important
contributors
system
dependability
designing
operational
processes
take
account
human
factors
bear
mind
people
liable
make
mistakes
using
system
dependable
process
designed
avoid
human
errors
mistakes
made
software
detect
mistakes
allow
corrected
http
software
engineering
book
com
web
human
error
Dependable
processes
Dependable
software
processes
software
processes
designed
produce
dependable
software
rationale
investing
dependable
processes
good
software
process
likely
lead
delivered
software
contains
fewer
errors
therefore
less
likely
fail
execution
company
using
dependable
process
sure
process
properly
enacted
documented
appropriate
development
techniques
used
critical
systems
development
Figure
shows
attributes
dependable
software
processes
evidence
dependable
process
used
often
important
convincing
regulator
effective
software
engineering
practice
applied
developing
software
System
developers
normally
present
model
process
regulator
along
evidence
process
followed
regulator
convinced
process
used
consistently
process
participants
used
different
development
projects
means
process
explicitly
defined
repeatable
explicitly
defined
process
one
defined
process
model
used
drive
software
production
process
Data
collected
process
proves
development
team
followed
process
defined
process
model
repeatable
process
one
rely
individual
interpretation
judgment
Rather
process
repeated
across
projects
different
team
members
irrespective
involved
development
particularly
important
critical
systems
often
long
development
cycle
often
significant
changes
development
team
Dependable
processes
make
use
redundancy
diversity
achieve
reliability
often
include
different
activities
aim
example
program
inspections
testing
aim
discover
errors
program
approaches
used
together
likely
find
errors
found
using
one
technique
@@@@@@@@@@
Chapter
Dependable
systems
Process
characteristic
Description
Auditable
process
understandable
people
apart
process
participants
check
process
standards
followed
make
suggestions
process
improvement
Figure
Attributes
dependable
processesDiverse
process
include
redundant
diverse
verification
andvalidation
activities
Documentable
process
defined
process
model
sets
activities
inthe
process
documentation
produced
activities
Robust
process
able
recover
failures
individual
process
activities
Standardized
comprehensive
set
software
development
standards
covering
software
production
documentation
available
activities
used
dependable
processes
obviously
depend
type
software
developed
general
however
activities
geared
toward
avoiding
introduction
errors
system
detecting
removing
errors
maintaining
information
process
Examples
activities
included
dependable
process
include
Requirements
reviews
check
requirements
far
possible
complete
consistent
Requirements
management
ensure
changes
requirements
controlled
impact
proposed
requirements
changes
understood
developers
affected
change
Formal
specification
mathematical
model
software
created
analyzed
discussed
benefits
formal
specification
Section
Perhaps
important
benefit
forces
detailed
analysis
system
requirements
analysis
likely
discover
requirements
problems
missed
requirements
reviews
System
modeling
software
design
explicitly
documented
set
graphical
models
links
requirements
models
explicitly
documented
model
driven
engineering
approach
used
see
Chapter
code
generated
automatically
models
Design
program
inspections
different
descriptions
system
inspected
checked
different
people
checklist
common
design
programming
errors
used
focus
inspection
process
Static
analysis
automated
checks
carried
source
code
program
look
anomalies
indicate
programming
errors
omissions
cover
static
analysis
Chapter
Test
planning
management
comprehensive
set
system
tests
designed
testing
process
carefully
managed
demonstrate
tests
provide
coverage
system
requirements
correctly
applied
testing
process
@@@@@@@@@@
Formal
methods
dependability
well
process
activities
focus
system
development
testing
well
defined
quality
management
change
management
processes
specific
activities
dependable
process
vary
one
company
another
need
effective
quality
change
management
universal
Quality
management
processes
covered
Chapter
establish
set
process
product
standards
include
activities
capture
process
information
demonstrate
standards
followed
example
standard
defined
carrying
program
inspections
inspection
team
leader
responsible
documenting
process
show
inspection
standard
followed
Change
management
discussed
Chapter
concerned
managing
changes
system
ensuring
accepted
changes
implemented
confirming
planned
releases
software
include
planned
changes
One
common
problem
software
wrong
components
included
system
build
lead
situation
executing
system
includes
components
checked
development
process
Configuration
management
procedures
defined
part
change
management
process
ensure
happen
agile
methods
increasingly
used
researchers
practitioners
thought
carefully
use
agile
approaches
dependable
software
development
Trimble
companies
develop
critical
software
systems
based
development
plan
based
processes
reluctant
make
radical
changes
development
process
However
recognize
value
agile
approaches
exploring
dependable
development
processes
agile
dependable
software
often
requires
certification
process
product
documentation
produced
front
requirements
analysis
essential
discover
possible
requirements
requirements
conflicts
compromise
safety
security
system
Formal
change
analysis
essential
assess
effect
changes
safety
integrity
system
requirements
conflict
general
approach
agile
development
co
development
requirements
system
minimizing
documentation
agile
development
uses
informal
undocumented
process
fundamental
requirement
agility
agile
process
defined
incorporates
techniques
iterative
development
test
first
development
user
involvement
development
team
long
team
follows
process
documents
actions
agile
techniques
used
support
notion
various
proposals
modified
agile
methods
made
incorporate
requirements
dependable
systems
engineering
Douglass
combine
appropriate
techniques
agile
plan
based
development
Formal
methods
dependability
years
researchers
advocated
use
formal
methods
software
development
Formal
methods
mathematical
approaches
software
development
define
formal
model
software
formally
analyze
model
search
errors
inconsistencies
prove
program
@@@@@@@@@@
Chapter
Dependable
systems
consistent
model
apply
series
correctness
preserving
transformations
model
generate
program
Abrial
Abrial
claims
use
formal
methods
lead
faultless
systems
careful
limit
means
claim
excellent
survey
Woodcock
et
al
Woodcock
et
al
discuss
industrial
applications
formal
methods
successfully
applied
include
train
control
systems
Badeau
Amelot
cash
card
systems
Hall
Chapman
flight
control
systems
Miller
et
al
Formal
methods
basis
tools
used
static
verification
driver
verification
system
used
Microsoft
Ball
et
al
Using
mathematically
formal
approach
software
development
proposed
early
stage
development
computer
science
idea
formal
specification
program
developed
independently
mathematical
proof
developed
show
program
specification
consistent
Initially
proofs
developed
manually
long
expensive
process
quickly
clear
manual
proofs
developed
small
systems
Program
proving
now
supported
large
scale
automated
theorem
proving
software
meant
larger
systems
proved
However
developing
proof
obligations
theorem
provers
difficult
specialized
task
formal
verification
widely
used
alternative
approach
avoids
separate
proof
activity
refinement
based
development
formal
specification
system
refined
series
correctness
preserving
transformations
generate
software
trusted
transformations
confident
generated
program
consistent
formal
specification
approach
used
software
development
Paris
Metro
system
Badeau
Amelot
used
language
called
B
Abrial
designed
support
specification
refinement
Formal
methods
based
model
checking
Jhala
Majumdar
used
number
systems
Bochot
et
al
Calinescu
Kwiatkowska
systems
rely
constructing
generating
formal
state
model
system
using
model
checker
check
properties
model
safety
properties
hold
model
checking
program
exhaustively
analyzes
specification
reports
system
property
satisfied
model
presents
example
shows
satisfied
model
automatically
systematically
generated
program
means
bugs
program
uncovered
cover
model
checking
safety
critical
systems
Chapter
Formal
methods
software
engineering
effective
discovering
avoiding
two
classes
error
software
representations
Specification
design
errors
omissions
process
developing
analyzing
formal
model
software
reveal
errors
omissions
software
requirements
model
generated
automatically
systematically
source
code
analysis
using
model
checking
discover
undesirable
states
occur
deadlock
concurrent
system
@@@@@@@@@@
Formal
methods
dependability
Formal
specification
techniques
Formal
system
specifications
expressed
using
two
fundamental
approaches
models
system
interfaces
algebraic
specifications
models
system
state
extra
web
chapter
topic
shows
examples
approaches
chapter
includes
formal
specification
part
insulin
pump
system
http
software
engineering
book
com
web
formal
methods
web
chapter
Inconsistencies
specification
program
refinement
method
used
mistakes
made
developers
make
software
inconsistent
specification
avoided
Program
proving
discovers
inconsistencies
program
specification
starting
point
formal
methods
mathematical
system
model
acts
system
specification
create
model
translate
system
s
user
requirements
expressed
natural
language
diagrams
tables
mathematical
language
formally
defined
semantics
formal
specification
unambiguous
description
system
Formal
specifications
precise
way
specifying
systems
reduce
scope
misunderstanding
Many
supporters
formal
methods
believe
creating
formal
specification
even
without
refinement
program
proof
worthwhile
Constructing
formal
specification
forces
detailed
analysis
requirements
effective
way
discovering
requirements
problems
natural
language
specification
errors
concealed
imprecision
language
case
system
formally
specified
advantages
developing
formal
specification
using
formal
development
process
develop
formal
specification
detail
develop
deep
detailed
understanding
system
requirements
Requirements
problems
discovered
early
usually
much
cheaper
correct
found
later
stages
development
process
specification
expressed
language
formally
defined
semantics
analyze
automatically
discover
inconsistencies
incompleteness
use
method
B
method
transform
formal
specification
program
sequence
correctness
preserving
transformations
resulting
program
therefore
guaranteed
meet
specification
Program
testing
costs
reduced
verified
program
specification
example
development
software
Paris
Metro
systems
use
refinement
meant
no
need
software
component
testing
system
testing
required
@@@@@@@@@@
Chapter
Dependable
systems
Woodcock
s
survey
Woodcock
et
al
found
users
formal
methods
reported
fewer
errors
delivered
software
costs
time
needed
software
development
higher
comparable
development
projects
significant
benefits
using
formal
approaches
safety
critical
systems
required
regulator
certification
documentation
produced
important
part
safety
case
see
Chapter
system
spite
advantages
formal
methods
limited
impact
practical
software
development
even
critical
systems
Woodcock
reports
projects
years
used
formal
methods
Even
allow
projects
used
techniques
report
use
tiny
fraction
total
number
critical
systems
developed
time
Industry
reluctant
adopt
formal
methods
number
reasons
Problem
owners
domain
experts
cannot
understand
formal
specification
cannot
check
accurately
represents
requirements
Software
engineers
understand
formal
specification
understand
application
domain
cannot
sure
formal
specification
accurate
reflection
system
requirements
fairly
easy
quantify
costs
creating
formal
specification
difficult
estimate
possible
cost
savings
result
use
result
managers
unwilling
take
risk
adopting
formal
methods
unconvinced
reports
success
large
came
atypical
projects
developers
keen
advocates
formal
approach
software
engineers
trained
use
formal
specification
languages
reluctant
propose
use
development
processes
difficult
scale
current
formal
methods
large
systems
formal
methods
used
mostly
specifying
critical
kernel
software
rather
complete
systems
Tool
support
formal
methods
limited
available
tools
often
open
source
difficult
use
market
small
commercial
tool
providers
Formal
methods
compatible
agile
development
programs
developed
incrementally
major
issue
however
critical
systems
still
developed
using
plan
based
approach
Parnas
early
advocate
formal
development
criticized
current
formal
methods
claims
started
fundamentally
wrong
premise
Parnas
believes
methods
gain
acceptance
radically
simplified
require
different
type
mathematics
basis
view
even
mean
formal
methods
routinely
adopted
critical
systems
engineering
unless
clearly
demonstrated
adoption
use
cost
effective
compared
software
engineering
methods
@@@@@@@@@@
Chapter
Website
Key
Points
System
dependability
important
failure
critical
computer
systems
lead
large
economic
losses
serious
information
loss
physical
damage
threats
human
life
dependability
computer
system
system
property
reflects
user
s
degree
trust
system
important
dimensions
dependability
availability
reliability
safety
security
resilience
Sociotechnical
systems
include
computer
hardware
software
people
situated
organization
designed
support
organizational
business
goals
objectives
use
dependable
repeatable
process
essential
faults
system
minimized
process
include
verification
validation
activities
stages
requirements
definition
system
implementation
use
redundancy
diversity
hardware
software
processes
software
systems
essential
development
dependable
systems
Formal
methods
formal
model
system
used
basis
development
help
reduce
number
specification
implementation
errors
system
However
formal
methods
limited
take
industry
concerns
cost
effectiveness
approach
ReaDing
Basic
Concepts
Taxonomy
Dependable
Secure
Computing
work
presents
thorough
discussion
dependability
concepts
written
pioneers
field
responsible
developing
ideas
Avizienis
J
C
Laprie
B
Randell
C
Landwehr
IEEE
Transactions
Dependable
Secure
Computing
http
dx
doi
org
TDSC
Formal
Methods
Practice
Experience
excellent
survey
use
formal
methods
industry
along
description
projects
used
formal
methods
authors
present
realistic
summary
barriers
use
methods
J
Woodcock
P
G
Larsen
J
Bicarregui
J
Fitzgerald
Computing
Surveys
January
http
dx
doi
org
LSCITS
Socio
technical
Systems
Handbook
handbook
introduces
sociotechnical
systems
accessible
way
provides
access
detailed
papers
sociotechnical
topics
http
archive
cs
st
andrews
ac
uk
STSE
Handbook
WebSite
PowerPoint
slides
chapter
www
pearsonglobaleditions
com
Sommerville
Links
supporting
videos
http
software
engineering
book
com
videos
critical
systems
@@@@@@@@@@
Chapter
Dependable
systems
exeRCiSeS
Suggest
six
reasons
software
dependability
important
sociotechnical
systems
Explain
example
resilience
cyber
attacks
important
characteristic
system
dependability
Using
example
explain
important
developing
dependable
systems
consider
sociotechnical
systems
simply
technical
software
hardware
systems
Give
two
examples
government
functions
supported
complex
sociotechnical
systems
explain
foreseeable
future
functions
cannot
completely
automated
Explain
difference
redundancy
diversity
Explain
reasonable
assume
use
dependable
processes
lead
creation
dependable
software
Give
two
examples
diverse
redundant
activities
incorporated
dependable
processes
Give
two
reasons
different
versions
system
based
software
diversity
fail
similar
way
engineer
charge
development
small
safety
critical
train
control
system
demonstrably
safe
secure
suggest
formal
methods
used
development
system
manager
skeptical
approach
Write
report
highlighting
benefits
formal
methods
presenting
case
use
project
suggested
need
regulation
inhibits
innovation
regulators
force
use
older
methods
systems
development
used
systems
Discuss
think
true
desirability
regulators
imposing
views
methods
used
ReFeRenCeS
Abrial
J
R
Faultless
Systems
IEEE
Computer
doi
MC
Modeling
Event
B
System
Software
Engineering
Cambridge
UK
Cambridge
University
Press
Avizienis
J
C
Laprie
B
Randell
C
Landwehr
Basic
Concepts
Taxonomy
Dependable
Secure
Computing
IEEE
Trans
Dependable
Secure
Computing
doi
TDSC
Badeau
F
Amelot
Using
B
High
Level
Programming
Language
Industrial
Project
Roissy
VAL
Proc
ZB
Formal
Specification
Development
Z
B
Guildford
UK
Springer
doi
@@@@@@@@@@
Chapter
References
Ball
T
E
Bounimova
B
Cook
V
Levin
J
Lichtenberg
C
McGarvey
B
Ondrusek
S
K
Rajamani
Ustuner
Thorough
Static
Analysis
Device
Drivers
Proc
EuroSys
Leuven
Belgium
doi
Bochot
T
P
Virelizier
H
Waeselynck
V
Wiels
Model
Checking
Flight
Control
Systems
Airbus
Experience
Proc
st
International
Conf
Software
Engineering
Companion
Volume
Leipzig
IEEE
Computer
Society
Press
doi
ICSE
COMPANION
Calinescu
R
C
M
Z
Kwiatkowska
Using
Quantitative
Analysis
Implement
Autonomic
Systems
Proc
st
International
Conf
Software
Engineering
Companion
Volume
Leipzig
IEEE
Computer
Society
Press
doi
ICSE
Douglass
B
Agile
Analysis
Practices
Safety
Critical
Software
Development
http
www
ibm
com
developerworks
rational
library
agile
analysis
practices
safety
critical
development
Hall
R
Chapman
Correctness
Construction
Developing
Commercially
Secure
System
IEEE
Software
doi
Jhala
R
R
Majumdar
Software
Model
Checking
Computing
Surveys
Article
doi
Miller
S
P
E
Anderson
L
G
Wagner
M
W
Whalen
M
P
E
Heimdahl
Formal
Verification
Flight
Critical
Software
Proc
AIAA
Guidance
Navigation
Control
Conference
San
Francisco
doi
Parnas
D
Really
Rethinking
Formal
Methods
IEEE
Computer
doi
MC
Parnas
D
J
van
Schouwen
P
K
Shu
Evaluation
Safety
Critical
Software
Comm
ACM
doi
Swartz
J
Airport
Automated
Baggage
System
ACM
Software
Engineering
Notes
doi
Trimble
J
Agile
Development
Methods
Space
Operations
SpaceOps
Stockholm
doi
Woodcock
J
P
G
Larsen
J
Bicarregui
J
Fitzgerald
Formal
Methods
Practice
Experience
Computing
Surveys
doi
@@@@@@@@@@
Reliability
engineering
Objectives
objective
chapter
explain
software
reliability
specified
implemented
measured
read
chapter
understand
distinction
software
reliability
software
availability
introduced
metrics
reliability
specification
used
specify
measurable
reliability
requirements
understand
different
architectural
styles
used
implement
reliable
fault
tolerant
systems
architectures
know
good
programming
practice
reliable
software
engineering
understand
reliability
software
system
measured
using
statistical
testing
Contents
Availability
reliability
Reliability
requirements
Fault
tolerant
architectures
Programming
reliability
Reliability
measurement
@@@@@@@@@@
Chapter
Reliability
engineering
dependence
software
systems
aspects
business
personal
lives
means
expect
software
available
need
early
morning
late
night
weekends
holidays
software
run
day
every
day
year
expect
software
operate
without
crashes
failures
preserve
data
personal
information
need
able
trust
software
use
means
software
reliable
use
software
engineering
techniques
better
programming
languages
effective
quality
management
led
significant
improvements
software
reliability
past
years
Nevertheless
system
failures
still
occur
affect
system
s
availability
lead
incorrect
results
produced
situations
software
particularly
critical
role
perhaps
aircraft
part
national
critical
infrastructure
special
reliability
engineering
techniques
used
achieve
high
levels
reliability
availability
required
Unfortunately
easy
get
confused
talking
system
reliability
different
people
meaning
different
things
talk
system
faults
failures
Brian
Randell
pioneer
researcher
software
reliability
defined
fault
error
failure
model
Randell
based
notion
human
errors
cause
faults
faults
lead
errors
errors
lead
system
failures
defined
terms
precisely
Human
error
mistake
Human
behavior
results
introduction
faults
system
example
wilderness
weather
system
programmer
decide
way
compute
time
next
transmission
add
hour
current
time
works
except
transmission
time
midnight
midnight
hour
clock
System
fault
characteristic
software
system
lead
system
error
fault
example
inclusion
code
add
variable
called
Transmission
time
without
check
see
value
Transmission
time
greater
equal
System
error
erroneous
system
state
execution
lead
system
behavior
unexpected
system
users
example
value
variable
Transmission
time
set
incorrectly
XX
rather
XX
faulty
code
executed
System
failure
event
occurs
point
time
system
deliver
service
expected
users
case
no
weather
data
transmitted
time
invalid
System
faults
necessarily
result
system
errors
system
errors
necessarily
result
system
failures
code
program
executed
code
includes
fault
e
g
failure
initialize
variable
never
executed
way
software
used
@@@@@@@@@@
Errors
transient
state
variable
incorrect
value
caused
execution
faulty
code
However
accessed
causes
system
failure
system
input
processed
resets
state
valid
value
wrong
value
no
practical
effect
system
include
fault
detection
protection
mechanisms
ensure
erroneous
behavior
discovered
corrected
system
services
affected
Another
reason
faults
system
lead
system
failures
users
adapt
behavior
avoid
using
inputs
know
cause
program
failures
Experienced
users
work
around
software
features
found
unreliable
example
avoid
features
automatic
numbering
word
processing
system
use
experience
often
goes
wrong
Repairing
faults
unused
features
makes
no
practical
difference
system
reliability
distinction
faults
errors
failures
leads
three
complementary
approaches
used
improve
reliability
system
Fault
avoidance
software
design
implementation
process
use
approaches
software
development
help
avoid
design
programming
errors
minimize
number
faults
introduced
system
Fewer
faults
means
less
chance
runtime
failures
Fault
avoidance
techniques
include
use
strongly
typed
programming
language
allow
extensive
compiler
checking
minimizing
use
error
prone
programming
language
constructs
pointers
Fault
detection
correction
Verification
validation
processes
designed
discover
remove
faults
program
deployed
operational
use
Critical
systems
require
extensive
verification
validation
discover
many
faults
possible
deployment
convince
system
stakeholders
regulators
system
dependable
Systematic
testing
debugging
static
analysis
examples
fault
detection
techniques
Fault
tolerance
system
designed
faults
unexpected
system
behavior
execution
detected
runtime
managed
way
system
failure
occur
Simple
approaches
fault
tolerance
based
built
runtime
checking
included
systems
specialized
fault
tolerance
techniques
use
fault
tolerant
system
architectures
discussed
Section
used
high
level
system
availability
reliability
required
Unfortunately
applying
fault
avoidance
fault
detection
fault
tolerance
techniques
cost
effective
cost
finding
removing
remaining
faults
software
system
rises
exponentially
program
faults
discovered
removed
Figure
software
becomes
reliable
need
spend
time
effort
find
fewer
fewer
faults
stage
even
critical
systems
costs
additional
effort
unjustifiable
@@@@@@@@@@
Cost
per
error
detectedCost
per
error
detected
Figure
increasing
costs
residual
fault
removal
Many
Number
residual
errors
result
software
companies
accept
software
contain
residual
faults
level
faults
depends
type
system
Software
products
relatively
high
level
faults
critical
systems
usually
much
lower
fault
density
rationale
accepting
faults
system
fails
cheaper
pay
consequences
failure
discover
remove
faults
system
delivery
However
decision
release
faulty
software
simply
economic
one
social
political
acceptability
system
failure
taken
account
Availability
reliability
Chapter
introduced
concepts
system
reliability
system
availability
think
systems
delivering
kind
service
deliver
cash
control
brakes
connect
phone
calls
example
availability
service
service
running
reliability
service
delivers
correct
results
Availability
reliability
expressed
probabilities
availability
means
time
period
system
available
time
average
inputs
every
result
failures
reliability
expressed
rate
occurrence
failure
precise
definitions
availability
reliability
Reliability
probability
failure
free
operation
specified
time
given
environment
specific
purpose
Availability
probability
system
point
time
operational
able
deliver
requested
services
@@@@@@@@@@
Inputs
causing
erroneous
outputs
oneous
outputs
Figure
system
input
output
mapping
Erroneous
outputs
System
reliability
absolute
value
depends
system
used
example
let
s
say
measure
reliability
application
office
environment
users
uninterested
operation
software
follow
instructions
use
try
experiment
system
measure
reliability
system
university
environment
reliability
quite
different
students
explore
boundaries
system
use
unexpected
ways
result
system
failures
occur
constrained
office
environment
Therefore
perceptions
system
s
reliability
environments
different
definition
reliability
based
idea
failure
free
operation
failures
external
events
affect
users
system
constitutes
failure
technical
definition
failure
behavior
conform
system
s
specification
However
two
problems
definition
Software
specifications
often
incomplete
incorrect
left
software
engineers
interpret
system
behave
domain
experts
implement
behavior
users
expect
software
behave
specified
users
still
failing
No
one
except
system
developers
reads
software
specification
documents
Users
therefore
anticipate
software
behave
one
way
specification
says
something
completely
different
Failure
therefore
something
objectively
defined
Rather
judgment
made
users
system
one
reason
users
impression
system
s
reliability
understand
reliability
different
different
environments
need
think
system
input
output
mapping
Figure
shows
software
system
IeInput
set
OeOutput
set
Program
@@@@@@@@@@
PossibleinputsUser
User
User
ErroneousinputsPossibleinputsUser
User
User
Erroneousinputs
Figure
Software
usage
patterns
links
set
inputs
set
outputs
Given
input
input
sequence
program
responds
producing
corresponding
output
example
given
input
URL
web
browser
produces
output
display
requested
web
page
inputs
lead
system
failure
However
inputs
input
combinations
shown
shaded
ellipse
Figure
cause
system
failures
e
erroneous
outputs
generated
program
s
reliability
depends
number
system
inputs
members
set
inputs
lead
erroneous
output
words
set
inputs
cause
faulty
code
executed
system
errors
occur
inputs
set
executed
frequently
used
parts
e
system
failures
frequent
However
inputs
executed
e
code
rarely
used
users
hardly
ever
see
failures
Faults
affect
reliability
system
one
user
never
show
someone
s
mode
working
Figure
set
erroneous
inputs
corresponds
ellipse
labeled
Figure
set
inputs
produced
e
User
intersects
erroneous
input
set
User
therefore
experience
system
failures
User
User
however
never
use
inputs
erroneous
set
software
appear
reliable
availability
system
depend
number
system
failures
time
needed
repair
faults
caused
failure
Therefore
system
fails
year
system
B
fails
month
apparently
reliable
B
However
assume
system
takes
hours
restart
failure
system
B
takes
minutes
restart
availability
system
B
year
minutes
time
much
better
system
minutes
downtime
Furthermore
disruption
caused
unavailable
systems
reflected
simple
availability
metric
specifies
percentage
time
system
available
time
system
fails
important
system
unavailable
hour
day
affect
many
users
However
system
unavailable
minutes
working
day
system
unavailability
much
greater
effect
users
Reliability
availability
closely
related
sometimes
one
important
users
expect
continuous
service
system
system
@@@@@@@@@@
high
availability
requirement
available
demand
made
However
system
recover
quickly
failures
without
loss
user
data
failures
significantly
affect
system
users
telephone
exchange
switch
routes
phone
calls
example
system
availability
important
reliability
Users
expect
able
make
call
pick
phone
activate
phone
app
system
high
availability
requirements
system
fault
occurs
connection
set
often
quickly
recoverable
Exchange
base
station
switches
reset
system
retry
connection
attempt
done
quickly
phone
users
even
notice
failure
occurred
Furthermore
even
call
interrupted
consequences
usually
serious
Users
simply
reconnect
happens
Reliability
requirements
September
plane
landed
Warsaw
Airport
Poland
thunderstorm
seconds
landing
brakes
computer
controlled
braking
system
work
braking
system
recognized
plane
landed
assumed
aircraft
still
airborne
safety
feature
aircraft
stopped
deployment
reverse
thrust
system
slows
aircraft
reverse
thrust
catastrophic
plane
air
plane
ran
off
end
runway
hit
earth
bank
caught
fire
inquiry
accident
showed
braking
system
software
operated
according
specification
no
errors
control
system
However
software
specification
incomplete
taken
account
rare
situation
arose
case
software
worked
system
failed
incident
shows
system
dependability
depend
good
engineering
requires
attention
detail
system
requirements
derived
specification
software
requirements
geared
ensuring
dependability
system
dependability
requirements
two
types
Functional
requirements
define
checking
recovery
facilities
included
system
features
provide
protection
system
failures
external
attacks
Non
functional
requirements
define
required
reliability
availability
system
discussed
Chapter
overall
reliability
system
depends
hardware
reliability
software
reliability
reliability
system
operators
system
software
take
requirement
account
well
including
requirements
compensate
software
failure
related
reliability
requirements
help
detect
recover
hardware
failures
operator
errors
@@@@@@@@@@
Availability
Explanation
Availability
Explanation
system
available
time
means
hour
period
minutes
system
unavailable
minutes
hour
period
system
unavailable
minutes
system
unavailable
seconds
hour
period
system
unavailable
seconds
hour
period
roughly
one
minute
per
week
Figure
Availability
specification
Reliability
metrics
Reliability
specified
probability
system
failure
occur
system
use
specified
operating
environment
willing
accept
example
transactions
fail
specify
failure
probability
doesn
t
mean
exactly
failure
every
transactions
means
observe
N
thousand
transactions
number
failures
observe
N
Three
metrics
used
specify
reliability
availability
Probability
failure
demand
POFOD
use
metric
define
probability
demand
service
system
result
system
failure
POFOD
means
chance
failure
occur
demand
made
Rate
occurrence
failures
ROCOF
metric
sets
probable
number
system
failures
likely
observed
relative
certain
time
period
e
g
hour
number
system
executions
example
ROCOF
reciprocal
ROCOF
mean
time
failure
MTTF
sometimes
used
reliability
metric
MTTF
average
number
time
units
observed
system
failures
ROCOF
two
failures
per
hour
implies
mean
time
failure
minutes
Availability
AVAIL
AVAIL
probability
system
operational
demand
made
service
Therefore
availability
means
average
system
available
operating
time
Figure
shows
different
levels
availability
mean
practice
POFOD
used
situations
failure
demand
lead
serious
system
failure
applies
irrespective
frequency
demands
example
protection
system
monitors
chemical
reactor
shuts
reaction
overheating
reliability
specified
using
POFOD
Generally
demands
protection
system
infrequent
system
last
line
defense
recovery
strategies
failed
Therefore
POFOD
failure
demands
@@@@@@@@@@
seem
risky
However
two
three
demands
system
entire
lifetime
system
unlikely
ever
fail
ROCOF
used
demands
systems
made
regularly
rather
intermittently
example
system
handles
large
number
transactions
specify
ROCOF
failures
per
day
means
willing
accept
average
transactions
per
day
complete
successfully
canceled
resubmitted
Alternatively
specify
ROCOF
number
failures
per
transactions
absolute
time
failures
important
specify
reliability
mean
time
failures
MTTF
example
specifying
required
reliability
system
long
transactions
computer
aided
design
system
use
metric
MTTF
much
longer
average
time
user
works
models
without
saving
user
s
results
means
users
unlikely
lose
work
system
failure
one
session
Non
functional
reliability
requirements
Non
functional
reliability
requirements
specifications
required
reliability
availability
system
using
one
reliability
metrics
POFOD
ROCOF
AVAIL
described
previous
section
Quantitative
reliability
availability
specification
used
many
years
safety
critical
systems
uncommon
business
critical
systems
However
companies
demand
service
systems
makes
sense
precise
reliability
availability
expectations
Quantitative
reliability
specification
useful
number
ways
process
deciding
required
level
reliability
helps
clarify
stakeholders
really
need
helps
stakeholders
understand
different
types
system
failure
makes
clear
high
levels
reliability
expensive
achieve
provides
basis
assessing
stop
testing
system
stop
system
reached
required
reliability
level
means
assessing
different
design
strategies
intended
improve
reliability
system
make
judgment
strategy
lead
required
levels
reliability
regulator
approve
system
goes
service
e
g
systems
critical
flight
safety
aircraft
regulated
evidence
required
reliability
target
met
important
system
certification
avoid
incurring
excessive
unnecessary
costs
important
specify
reliability
really
need
rather
simply
choose
high
level
reliability
whole
system
different
requirements
different
@@@@@@@@@@
Overspecification
reliability
Overspecification
reliability
means
defining
level
required
reliability
higher
really
necessary
practical
operation
software
Overspecification
reliability
increases
development
costs
disproportionately
reason
costs
reducing
faults
verifying
reliability
increase
exponentially
reliability
increases
http
software
engineering
book
com
web
specifying
reliability
parts
system
parts
critical
others
follow
three
guidelines
specifying
reliability
requirements
Specify
availability
reliability
requirements
different
types
failure
lower
probability
high
cost
failures
failures
don
t
serious
consequences
Specify
availability
reliability
requirements
different
types
system
service
Critical
system
services
highest
reliability
willing
tolerate
failures
less
critical
services
decide
cost
effective
use
quantitative
reliability
specification
critical
system
services
Think
high
reliability
really
required
example
use
error
detection
mechanisms
check
outputs
system
error
correction
processes
place
correct
errors
no
need
high
level
reliability
system
generates
outputs
errors
detected
corrected
illustrate
guidelines
think
reliability
availability
requirements
bank
ATM
system
dispenses
cash
provides
services
customers
Banks
two
concerns
systems
ensure
carry
customer
services
requested
properly
record
customer
transactions
account
database
ensure
systems
available
use
required
Banks
many
years
experience
identifying
correcting
incorrect
account
transactions
use
accounting
methods
detect
things
gone
wrong
transactions
fail
simply
canceled
resulting
no
loss
bank
minor
customer
inconvenience
Banks
run
ATM
networks
therefore
accept
ATM
failures
mean
small
number
transactions
incorrect
think
cost
effective
fix
errors
later
rather
incur
high
costs
avoiding
faulty
transactions
Therefore
absolute
reliability
required
ATM
relatively
low
Several
failures
per
day
acceptable
@@@@@@@@@@
bank
bank
s
customers
availability
ATM
network
important
individual
ATM
transactions
fail
Lack
availability
means
increased
demand
counter
services
customer
dissatisfaction
engineering
costs
repair
network
Therefore
transaction
based
systems
banking
e
commerce
systems
focus
reliability
specification
usually
specifying
availability
system
specify
availability
ATM
network
identify
system
services
specify
required
availability
services
notably
customer
account
database
service
individual
services
provided
ATM
withdraw
cash
provide
account
information
database
service
critical
failure
service
means
ATMs
network
action
Therefore
specify
service
high
level
availability
case
acceptable
figure
database
availability
ignoring
issues
scheduled
maintenance
upgrades
probably
around
pm
means
downtime
less
minute
per
week
individual
ATM
overall
availability
depends
mechanical
reliability
fact
run
cash
Software
issues
probably
less
significant
factors
Therefore
lower
level
software
availability
ATM
software
acceptable
overall
availability
ATM
software
therefore
specified
means
machine
unavailable
minutes
day
allows
ATM
software
restarted
event
problem
reliability
control
systems
usually
specified
terms
probability
system
fail
demand
made
POFOD
Consider
reliability
requirements
control
software
insulin
pump
introduced
Chapter
system
delivers
insulin
number
times
per
day
monitors
user
s
blood
glucose
several
times
per
hour
two
possible
types
failure
insulin
pump
Transient
software
failures
repaired
user
actions
resetting
recalibrating
machine
types
failure
relatively
low
value
POFOD
say
acceptable
means
one
failure
occur
every
demands
made
machine
approximately
every
days
blood
sugar
checked
times
per
hour
Permanent
software
failures
require
software
reinstalled
manufacturer
probability
type
failure
much
lower
Roughly
year
minimum
figure
POFOD
no
@@@@@@@@@@
RR
predefined
range
operator
inputs
shall
defined
system
shall
check
operator
inputs
fall
predefined
range
Checking
RR
Copies
patient
database
shall
maintained
two
separate
servers
housed
building
Recovery
redundancy
RR
N
version
programming
shall
used
implement
braking
control
system
Redundancy
Figure
Examples
functional
reliability
requirements
RR
system
implemented
safe
subset
Ada
checked
using
static
analysis
Process
Failure
deliver
insulin
immediate
safety
implications
commercial
factors
rather
safety
factors
govern
level
reliability
required
Service
costs
high
users
need
fast
repair
replacement
manufacturer
s
interest
limit
number
permanent
failures
require
repair
Functional
reliability
specification
achieve
high
level
reliability
availability
software
intensive
system
use
combination
fault
avoidance
fault
detection
fault
tolerance
techniques
means
functional
reliability
requirements
generated
specify
system
provide
fault
avoidance
detection
tolerance
functional
reliability
requirements
specify
faults
detected
actions
taken
ensure
faults
lead
system
failures
Functional
reliability
specification
therefore
involves
analyzing
non
functional
requirements
specified
assessing
risks
reliability
specifying
system
functionality
address
risks
four
types
functional
reliability
requirements
Checking
requirements
requirements
identify
checks
inputs
system
ensure
incorrect
range
inputs
detected
processed
system
Recovery
requirements
requirements
geared
helping
system
recover
failure
occurred
requirements
usually
concerned
maintaining
copies
system
data
specifying
restore
system
services
failure
Redundancy
requirements
specify
redundant
features
system
ensure
single
component
failure
lead
complete
loss
service
discuss
detail
next
chapter
Process
requirements
fault
avoidance
requirements
ensure
good
practice
used
development
process
practices
specified
reduce
number
faults
system
examples
types
reliability
requirement
shown
Figure
@@@@@@@@@@
no
simple
rules
deriving
functional
reliability
requirements
Organizations
develop
critical
systems
usually
organizational
knowledge
possible
reliability
requirements
requirements
reflect
actual
reliability
system
organizations
specialize
specific
types
systems
railway
control
systems
reliability
requirements
reused
across
range
systems
Fault
tolerant
architectures
Fault
tolerance
runtime
approach
dependability
systems
include
mechanisms
continue
operation
even
software
hardware
fault
occurred
system
state
erroneous
Fault
tolerance
mechanisms
detect
correct
erroneous
state
occurrence
fault
lead
system
failure
Fault
tolerance
required
systems
safety
security
critical
system
cannot
move
safe
state
error
detected
provide
fault
tolerance
system
architecture
designed
include
redundant
diverse
hardware
software
Examples
systems
need
fault
tolerant
architectures
aircraft
systems
available
throughout
duration
flight
telecommunication
systems
critical
command
control
systems
simplest
realization
dependable
architecture
replicated
servers
two
servers
carry
task
Requests
processing
channeled
server
management
component
routes
request
particular
server
component
keeps
track
server
responses
event
server
failure
detected
lack
response
faulty
server
switched
system
Unprocessed
requests
resubmitted
servers
processing
replicated
server
approach
widely
used
transaction
processing
systems
easy
maintain
copies
transactions
processed
Transaction
processing
systems
designed
data
updated
transaction
finished
correctly
Delays
processing
affect
integrity
system
efficient
way
using
hardware
backup
server
one
normally
used
low
priority
tasks
problem
occurs
primary
server
unprocessed
transactions
transferred
backup
server
gives
work
highest
priority
Replicated
servers
provide
redundancy
usually
diversity
server
hardware
usually
identical
servers
run
version
software
Therefore
cope
hardware
failures
software
failures
localized
single
machine
cannot
cope
software
design
problems
cause
versions
software
fail
time
handle
software
design
failures
system
use
diverse
software
hardware
Torres
Pomales
surveys
range
software
fault
tolerance
techniques
Torres
Pomales
Pullum
Pullum
describes
different
types
fault
tolerant
architecture
following
sections
describe
three
architectural
patterns
used
fault
tolerant
systems
@@@@@@@@@@
Protection
sensors
System
environment
Actuators
Controlled
equipment
Control
system
Protection
system
Sensors
Protection
sensors
System
environment
Actuators
Controlled
equipment
Control
system
Protection
system
Sensors
Figure
Protection
system
architecture
Protection
systems
protection
system
specialized
system
associated
system
usually
control
system
process
chemical
manufacturing
process
equipment
control
system
system
driverless
train
example
protection
system
system
train
detects
train
gone
red
signal
no
indication
train
control
system
slowing
train
protection
system
automatically
applies
train
brakes
bring
halt
Protection
systems
independently
monitor
environment
sensors
indicate
problem
controlled
system
dealing
protection
system
activated
shut
process
equipment
Figure
illustrates
relationship
protection
system
controlled
system
protection
system
monitors
controlled
equipment
environment
problem
detected
issues
commands
actuators
shut
system
invoke
protection
mechanisms
opening
pressure
release
valve
Notice
two
sets
sensors
One
set
used
normal
system
monitoring
specifically
protection
system
event
sensor
failure
backups
place
allow
protection
system
continue
operation
system
redundant
actuators
protection
system
includes
critical
functionality
required
move
system
potentially
unsafe
state
safe
state
system
shutdown
instance
general
fault
tolerant
architecture
principal
system
supported
smaller
simpler
backup
system
includes
essential
functionality
example
control
software
U
S
Space
Shuttle
backup
system
get
home
functionality
backup
system
land
vehicle
principal
control
system
failed
no
control
functions
@@@@@@@@@@
Splitter
Channel
Channel
ComparatorInput
value
Output
value
Status
Figure
Self
monitoring
architecture
Splitter
Channel
Channel
ComparatorInput
value
Output
value
Status
Figure
Self
monitoring
architecture
advantage
architectural
style
protection
system
software
much
simpler
software
controlling
protected
process
function
protection
system
monitor
operation
ensure
system
brought
safe
state
event
emergency
Therefore
possible
invest
effort
fault
avoidance
fault
detection
check
software
specification
correct
consistent
software
correct
respect
specification
aim
ensure
reliability
protection
system
low
probability
failure
demand
say
Given
demands
protection
system
rare
probability
failure
demand
means
protection
system
failures
rare
Self
monitoring
architectures
self
monitoring
architecture
Figure
system
architecture
system
designed
monitor
operation
take
action
problem
detected
Computations
carried
separate
channels
outputs
computations
compared
outputs
identical
available
time
system
judged
operating
correctly
outputs
different
failure
assumed
occurs
system
raises
failure
exception
status
output
line
signals
control
transferred
system
effective
detecting
hardware
software
faults
self
monitoring
systems
designed
hardware
used
channel
diverse
practice
mean
channel
uses
different
processor
type
carry
required
computations
chipset
making
system
sourced
different
manufacturers
reduces
probability
common
processor
design
faults
affecting
computation
software
used
channel
diverse
Otherwise
software
error
arise
time
channel
architecture
used
situations
important
computations
correct
availability
essential
answers
@@@@@@@@@@
Primary
flight
control
system
Splitter
Channel
Channel
Comparator
Output
Status
Primary
flight
control
system
Primary
flight
control
system
Splitter
Channel
Channel
Comparator
Output
Status
Secondary
flight
control
system
Secondary
flight
control
system
Input
Filter
Filter
Filter
Filter
Filter
Status
Status
Status
Output
Output
Output
Output
Figure
Airbus
flight
control
system
architecture
channel
differ
system
shuts
many
medical
treatment
diagnostic
systems
reliability
important
availability
incorrect
system
response
lead
patient
receiving
incorrect
treatment
However
system
shuts
event
error
inconvenience
patient
usually
harmed
situations
require
high
availability
use
several
self
checking
systems
parallel
need
switching
unit
detects
faults
selects
result
one
systems
channels
producing
consistent
response
approach
used
flight
control
system
Airbus
series
aircraft
uses
five
self
checking
computers
Figure
simplified
diagram
Airbus
flight
control
system
shows
organization
self
monitoring
systems
Airbus
flight
control
system
flight
control
computers
carries
computations
parallel
using
inputs
outputs
connected
hardware
filters
detect
status
indicates
fault
output
computer
switched
off
output
taken
alternative
system
Therefore
possible
four
computers
fail
aircraft
operation
continue
years
operation
no
reports
situations
control
aircraft
lost
due
total
flight
control
system
failure
@@@@@@@@@@
OutputselectorInputFigure
Triple
modular
redundancy
OutputselectorInputFigure
Triple
modular
redundancy
designers
Airbus
system
tried
achieve
diversity
number
different
ways
primary
flight
control
computers
use
different
processor
secondary
flight
control
systems
chipset
used
channel
primary
secondary
systems
supplied
different
manufacturer
software
secondary
flight
control
systems
provides
critical
functionality
less
complex
primary
software
software
channel
primary
secondary
systems
developed
using
different
programming
languages
different
teams
Different
programming
languages
used
secondary
primary
systems
discuss
Section
guarantee
diversity
reduce
probability
common
failures
different
channels
N
version
programming
Self
monitoring
architectures
examples
systems
multiversion
programming
used
provide
software
redundancy
diversity
notion
multiversion
programming
derived
hardware
systems
notion
triple
modular
redundancy
TMR
used
many
years
build
systems
tolerant
hardware
failures
Figure
TMR
system
hardware
unit
replicated
three
sometimes
times
output
unit
passed
output
comparator
usually
implemented
voting
system
system
compares
inputs
two
value
output
one
units
fails
produce
output
units
output
ignored
fault
manager
try
repair
faulty
unit
automatically
impossible
system
automatically
reconfigured
take
unit
service
system
continues
function
two
working
units
approach
fault
tolerance
relies
hardware
failures
result
component
failure
rather
design
faults
components
therefore
likely
@@@@@@@@@@
Version
Version
Version
Output
selector
N
software
versions
Agreed
result
Fault
manager
Input
Figure
N
version
programming
Version
Version
Version
Output
selector
N
software
versions
Agreed
result
Fault
manager
Input
Figure
N
version
programming
fail
independently
assumes
fully
operational
hardware
units
perform
specification
therefore
low
probability
simultaneous
component
failure
hardware
units
course
components
common
design
fault
thus
produce
wrong
answer
Using
hardware
units
common
specification
designed
built
different
manufacturers
reduces
chances
common
mode
failure
assumed
probability
different
teams
making
design
manufacturing
error
small
similar
approach
used
fault
tolerant
software
N
diverse
versions
software
system
execute
parallel
Avizienis
approach
software
fault
tolerance
illustrated
Figure
used
railway
signaling
systems
aircraft
systems
reactor
protection
systems
Using
common
specification
software
system
implemented
number
teams
versions
executed
separate
computers
outputs
compared
using
voting
system
inconsistent
outputs
outputs
produced
time
rejected
least
three
versions
system
available
two
versions
consistent
event
single
failure
N
version
programming
less
expensive
self
checking
architectures
systems
high
level
availability
required
However
still
requires
several
different
teams
develop
different
versions
software
leads
high
software
development
costs
result
approach
used
systems
impractical
provide
protection
system
guard
safety
critical
failures
Software
diversity
fault
tolerant
architectures
rely
software
diversity
achieve
fault
tolerance
based
assumption
diverse
implementations
specification
part
specification
protection
systems
independent
include
common
errors
fail
way
time
software
therefore
written
different
teams
communicate
development
process
requirement
reduces
chances
common
misunderstandings
misinterpretations
specification
@@@@@@@@@@
company
procuring
system
include
explicit
diversity
policies
intended
maximize
differences
system
versions
example
including
requirements
different
design
methods
used
example
one
team
required
produce
object
oriented
design
another
team
produce
function
oriented
design
stipulating
programs
implemented
using
different
programming
languages
example
three
version
system
Ada
C
Java
used
write
software
versions
requiring
use
different
tools
development
environments
system
requiring
different
algorithms
used
parts
implementation
However
limits
freedom
design
team
difficult
reconcile
system
performance
requirements
Ideally
diverse
versions
system
no
dependencies
fail
completely
different
ways
case
overall
reliability
diverse
system
obtained
multiplying
reliabilities
channel
channel
probability
failure
demand
overall
POFOD
three
channel
system
channels
independent
million
times
greater
reliability
single
channel
system
practice
however
achieving
complete
channel
independence
impossible
shown
experimentally
independent
software
design
teams
often
make
mistakes
misunderstand
parts
specification
Brilliant
Knight
Leveson
Leveson
several
reasons
misunderstanding
Members
different
teams
often
cultural
background
educated
using
approach
textbooks
means
find
things
difficult
understand
common
difficulties
communicating
domain
experts
quite
possible
independently
make
mistakes
design
algorithms
solve
problem
requirements
incorrect
based
misunderstandings
environment
system
mistakes
reflected
implementation
system
critical
system
detailed
system
specification
derived
system
s
requirements
provide
unambiguous
definition
system
s
behavior
However
specification
ambiguous
different
teams
misinterpret
specification
way
One
way
reduce
possibility
common
specification
errors
develop
detailed
specifications
system
independently
define
specifications
different
languages
One
development
team
work
formal
specification
@@@@@@@@@@
another
state
based
system
model
third
natural
language
specification
approach
helps
avoid
errors
specification
interpretation
get
around
problem
requirements
errors
introduces
possibility
errors
translation
requirements
leading
inconsistent
specifications
analysis
experiments
Hatton
Hatton
concluded
three
channel
system
somewhere
times
reliable
single
channel
system
concluded
improvements
reliability
obtained
devoting
resources
single
version
match
N
version
approaches
likely
lead
reliable
systems
single
version
approaches
unclear
however
improvements
reliability
multiversion
system
worth
extra
development
costs
many
systems
extra
costs
justifiable
well
engineered
single
version
system
good
enough
safety
mission
critical
systems
costs
failure
high
multiversion
software
required
Even
situations
e
g
spacecraft
system
enough
provide
simple
backup
limited
functionality
principal
system
repaired
restarted
Programming
reliability
deliberately
focused
book
programming
language
independent
aspects
software
engineering
impossible
discuss
programming
without
getting
details
specific
programming
language
However
considering
reliability
engineering
set
accepted
good
programming
practices
fairly
universal
help
reduce
faults
delivered
systems
list
eight
good
practice
guidelines
shown
Figure
applied
regardless
particular
programming
language
used
systems
development
way
used
depends
specific
languages
notations
used
system
development
Following
guidelines
reduces
chances
introducing
security
related
vulnerabilities
programs
Guideline
Control
visibility
information
program
security
principle
adopted
military
organizations
need
know
principle
individuals
need
know
particular
piece
information
order
carry
duties
given
information
Information
directly
relevant
work
withheld
programming
adopt
analogous
principle
control
access
variables
data
structures
use
Program
components
allowed
access
data
need
implementation
program
data
inaccessible
hidden
hide
information
cannot
corrupted
program
components
supposed
use
interface
remains
data
representation
changed
without
affecting
components
system
@@@@@@@@@@
Figure
Good
practice
guidelines
dependable
programming
Dependable
programming
guidelines
Limit
visibility
information
program
Check
inputs
validity
Provide
handler
exceptions
Minimize
use
error
prone
constructs
Provide
restart
capabilities
Check
array
bounds
Include
timeouts
calling
external
components
Name
constants
represent
real
world
values
achieve
implementing
data
structures
program
abstract
data
types
abstract
data
type
one
internal
structure
representation
variable
type
hidden
structure
attributes
type
externally
visible
access
data
operations
example
abstract
data
type
represents
queue
requests
service
Operations
include
get
put
add
remove
items
queue
operation
returns
number
items
queue
initially
implement
queue
array
subsequently
decide
change
implementation
linked
list
achieved
without
changes
code
using
queue
queue
representation
never
directly
accessed
object
oriented
languages
implement
abstract
data
types
using
interface
definitions
declare
interface
object
without
reference
implementation
example
define
interface
Queue
supports
methods
place
objects
onto
queue
remove
queue
query
size
queue
object
class
implements
interface
attributes
methods
private
class
Guideline
Check
inputs
validity
programs
take
inputs
environment
process
specification
makes
assumptions
inputs
reflect
real
world
use
example
assumed
bank
account
number
eight
digit
positive
integer
many
cases
however
system
specification
define
actions
taken
input
incorrect
Inevitably
users
make
mistakes
sometimes
enter
wrong
data
discuss
Chapter
malicious
attacks
system
rely
deliberately
entering
invalid
information
Even
inputs
come
sensors
systems
systems
go
wrong
provide
incorrect
values
therefore
check
validity
inputs
soon
read
program
s
operating
environment
checks
involved
obviously
depend
inputs
possible
checks
used
Range
checks
expect
inputs
particular
range
example
input
represents
probability
range
input
represents
temperature
liquid
water
degrees
Celsius
degrees
Celsius
@@@@@@@@@@
Size
checks
expect
inputs
given
number
characters
example
characters
represent
bank
account
cases
size
fixed
realistic
upper
limit
example
unlikely
person
s
name
characters
Representation
checks
expect
input
particular
type
represented
standard
way
example
people
s
names
include
numeric
characters
email
addresses
made
two
parts
separated
@
sign
Reasonableness
checks
input
one
series
know
something
relationships
members
series
check
input
value
reasonable
example
input
value
represents
readings
household
electricity
meter
expect
amount
electricity
used
approximately
corresponding
period
previous
year
course
variations
order
magnitude
differences
suggest
something
gone
wrong
actions
take
input
validation
check
fails
depend
type
system
implemented
cases
report
problem
user
request
value
re
input
value
comes
sensor
use
recent
valid
value
embedded
real
time
systems
estimate
value
based
previous
data
system
continue
operation
Guideline
Provide
handler
exceptions
program
execution
errors
unexpected
events
inevitably
occur
arise
program
fault
result
unpredictable
external
circumstances
error
unexpected
event
occurs
execution
program
called
exception
Examples
exceptions
system
power
failure
attempt
access
nonexistent
data
numeric
overflow
underflow
Exceptions
caused
hardware
software
conditions
exception
occurs
managed
system
done
program
involve
transferring
control
system
exception
handling
mechanism
Typically
system
s
exception
management
mechanism
reports
error
shuts
execution
Therefore
ensure
program
exceptions
cause
system
failure
define
exception
handler
possible
exceptions
arise
make
sure
exceptions
detected
explicitly
handled
Languages
Java
C
Python
built
exception
handling
constructs
exceptional
situation
occurs
exception
signaled
language
runtime
system
transfers
control
exception
handler
code
section
states
exception
names
appropriate
actions
handle
exception
Figure
exception
handler
outside
normal
flow
control
normal
control
flow
resume
exception
handled
@@@@@@@@@@
Code
section
Figure
Exception
handling
Exception
handling
code
Exception
processing
exception
handler
usually
one
three
things
Signals
higher
level
component
exception
occurred
provides
information
component
type
exception
use
approach
one
component
calls
another
calling
component
needs
know
called
component
executed
successfully
calling
component
take
action
recover
problem
Carries
alternative
processing
originally
intended
Therefore
exception
handler
takes
actions
recover
problem
Processing
continue
normal
Alternatively
exception
handler
indicate
exception
occurred
calling
component
aware
deal
exception
Passes
control
programming
language
runtime
support
system
handles
exception
often
default
faults
occur
program
example
numeric
value
overflows
usual
action
runtime
system
halt
processing
use
approach
possible
move
system
safe
quiescent
state
handing
control
runtime
system
Handling
exceptions
program
makes
possible
detect
recover
input
errors
unexpected
external
events
provides
degree
fault
tolerance
program
detects
faults
take
action
recover
input
errors
unexpected
external
events
usually
transient
often
possible
continue
normal
operation
exception
processed
Guideline
Minimize
use
error
prone
constructs
Normal
flow
control
Exception
detected
Normal
exit
Faults
programs
therefore
many
program
failures
usually
consequence
human
error
Programmers
make
mistakes
lose
track
numerous
relationships
state
variables
write
program
statements
result
unexpected
behavior
system
state
changes
People
make
@@@@@@@@@@
Error
prone
constructs
programming
language
features
likely
others
lead
introduction
program
bugs
Program
reliability
likely
improved
avoid
using
constructs
possible
minimize
use
go
statements
floating
point
numbers
pointers
dynamic
memory
allocation
parallelism
recursion
interrupts
aliasing
unbounded
arrays
default
input
processing
http
software
engineering
book
com
web
error
prone
constructs
mistakes
late
s
clear
approaches
programming
likely
introduce
errors
program
others
example
try
avoid
using
floating
point
numbers
precision
floating
point
numbers
limited
hardware
representation
Comparisons
large
small
numbers
unreliable
Another
construct
potentially
error
prone
dynamic
storage
allocation
explicitly
manage
storage
program
easy
forget
release
storage
s
no
longer
needed
lead
hard
detect
runtime
errors
standards
safety
critical
systems
development
completely
prohibit
use
error
prone
constructs
However
extreme
position
normally
practical
constructs
techniques
useful
though
used
care
possible
potentially
dangerous
effects
controlled
using
abstract
data
types
objects
act
natural
firewalls
limiting
damage
caused
errors
occur
Guideline
Provide
restart
capabilities
Many
organizational
information
systems
based
short
transactions
processing
user
inputs
takes
relatively
short
time
systems
designed
changes
system
s
database
finalized
processing
successfully
completed
something
goes
wrong
processing
database
updated
inconsistent
Virtually
e
commerce
systems
commit
purchase
final
screen
work
way
User
interactions
e
commerce
systems
usually
last
minutes
involve
minimal
processing
Database
transactions
short
usually
completed
less
second
However
types
system
CAD
systems
word
processing
systems
involve
long
transactions
long
transaction
system
time
starting
use
system
finishing
work
several
minutes
hours
system
fails
long
transaction
work
lost
Similarly
computationally
intensive
systems
e
science
systems
minutes
hours
processing
required
complete
computation
time
lost
event
system
failure
types
systems
provide
restart
capability
based
keeping
copies
data
collected
generated
processing
restart
facility
allow
system
restart
using
copies
rather
@@@@@@@@@@
start
beginning
copies
sometimes
called
checkpoints
example
e
commerce
system
keep
copies
forms
filled
user
allow
access
submit
forms
without
fill
long
transaction
computationally
intensive
system
automatically
save
data
every
minutes
event
system
failure
restart
recently
saved
data
allow
user
error
provide
way
users
go
back
recent
checkpoint
start
exception
occurs
impossible
continue
normal
operation
handle
exception
using
backward
error
recovery
means
reset
state
system
saved
state
checkpoint
restart
operation
point
Guideline
Check
array
bounds
programming
languages
allow
specification
arrays
sequential
data
structures
accessed
using
numeric
index
arrays
usually
laid
contiguous
areas
working
memory
program
Arrays
specified
particular
size
reflects
used
example
wish
represent
ages
people
declare
array
locations
hold
age
data
programming
languages
Java
check
value
entered
array
index
array
array
indexed
attempt
enter
values
elements
lead
exception
raised
However
programming
languages
C
C
automatically
include
array
bound
checks
simply
calculate
offset
beginning
array
Therefore
access
word
locations
beginning
array
irrespective
part
array
languages
include
automatic
array
bound
checking
introduces
overhead
every
time
array
accessed
increases
program
execution
time
However
lack
bound
checking
leads
security
vulnerabilities
buffer
overflow
discuss
Chapter
generally
introduces
system
vulnerability
lead
system
failure
using
language
C
C
include
array
bound
checking
include
checks
array
index
bounds
Guideline
Include
timeouts
calling
external
components
distributed
systems
components
system
execute
different
computers
calls
made
across
network
component
component
receive
service
component
call
component
B
waits
B
respond
continuing
execution
However
component
B
fails
respond
reason
component
cannot
continue
simply
waits
indefinitely
response
person
@@@@@@@@@@
waiting
response
system
sees
silent
system
failure
no
response
system
no
alternative
kill
waiting
process
restart
system
avoid
prospect
include
timeouts
calling
external
components
timeout
automatic
assumption
called
component
failed
produce
response
define
time
period
expect
receive
response
called
component
received
response
time
assume
failure
take
back
control
called
component
attempt
recover
failure
tell
system
users
happened
allow
decide
Guideline
Name
constants
represent
real
world
values
nontrivial
programs
include
number
constant
values
represent
values
real
world
entities
values
modified
program
executes
Sometimes
absolute
constants
never
change
e
g
speed
light
often
values
change
relatively
slowly
time
example
program
calculate
personal
tax
include
constants
current
tax
rates
change
year
year
program
updated
new
constant
values
include
section
program
name
real
world
constant
values
used
using
constants
refer
name
rather
value
two
advantages
far
dependability
concerned
less
likely
make
mistakes
use
wrong
value
easy
mistype
number
system
often
unable
detect
mistake
example
say
tax
rate
simple
transposition
error
lead
mistyped
However
mistype
name
Standard
tax
rate
error
detected
compiler
undeclared
variable
value
changes
look
whole
program
discover
used
value
need
change
value
associated
constant
declaration
new
value
automatically
included
everywhere
needed
Reliability
measurement
assess
reliability
system
collect
data
operation
data
required
include
number
system
failures
given
number
requests
system
services
used
measure
POFOD
applies
irrespective
time
demands
made
@@@@@@@@@@
Compute
observed
reliability
Apply
tests
system
Prepare
test
dataset
Identify
operational
profiles
Figure
Statistical
testing
reliability
measurement
Compute
observed
reliability
Apply
tests
system
Prepare
test
dataset
Identify
operational
profiles
Figure
Statistical
testing
reliability
measurement
time
number
transactions
system
failures
plus
total
elapsed
time
total
number
transactions
used
measure
ROCOF
MTTF
repair
restart
time
system
failure
leads
loss
service
used
measurement
availability
Availability
depend
time
failures
time
required
get
system
back
operation
time
units
used
metrics
calendar
time
discrete
unit
number
transactions
use
calendar
time
systems
continuous
operation
Monitoring
systems
process
control
systems
fall
category
Therefore
ROCOF
number
failures
per
day
Systems
process
transactions
bank
ATMs
airline
reservation
systems
variable
loads
placed
depending
time
day
cases
unit
time
used
number
transactions
ROCOF
number
failed
transactions
per
N
thousand
transactions
Reliability
testing
statistical
testing
process
aims
measure
reliability
system
Reliability
metrics
POFOD
probability
failure
demand
ROCOF
rate
occurrence
failure
used
quantitatively
specify
required
software
reliability
check
reliability
testing
process
system
achieved
required
reliability
level
process
measuring
reliability
system
sometimes
called
statistical
testing
Figure
statistical
testing
process
explicitly
geared
reliability
measurement
rather
fault
finding
Prowell
et
al
Prowell
et
al
give
good
description
statistical
testing
book
Cleanroom
software
engineering
four
stages
statistical
testing
process
start
studying
existing
systems
type
understand
used
practice
important
trying
measure
reliability
experienced
system
users
aim
define
operational
profile
operational
profile
identifies
classes
system
inputs
probability
inputs
occur
normal
use
construct
set
test
data
reflect
operational
profile
means
create
test
data
probability
distribution
test
data
systems
studied
Normally
use
test
data
generator
support
process
test
system
using
data
count
number
type
failures
occur
times
failures
logged
discussed
Chapter
time
units
chosen
appropriate
reliability
metric
used
@@@@@@@@@@
observed
statistically
significant
number
failures
compute
software
reliability
work
appropriate
reliability
metric
value
conceptually
attractive
approach
reliability
measurement
easy
apply
practice
principal
difficulties
arise
due
Operational
profile
uncertainty
operational
profiles
based
experience
systems
accurate
reflection
real
use
system
High
costs
test
data
generation
expensive
generate
large
volume
data
required
operational
profile
unless
process
totally
automated
Statistical
uncertainty
high
reliability
specified
generate
statistically
significant
number
failures
allow
accurate
reliability
measurements
software
already
reliable
relatively
failures
occur
difficult
generate
new
failures
Recognizing
failure
obvious
system
failure
occurred
formal
specification
able
identify
deviations
specification
specification
natural
language
ambiguities
mean
observers
disagree
system
failed
far
best
way
generate
large
dataset
required
reliability
measurement
use
test
data
generator
set
automatically
generate
inputs
matching
operational
profile
However
usually
possible
automate
production
test
data
interactive
systems
inputs
often
response
system
outputs
Datasets
systems
generated
manually
correspondingly
higher
costs
Even
complete
automation
possible
writing
commands
test
data
generator
take
significant
amount
time
Statistical
testing
used
conjunction
fault
injection
gather
data
effective
process
defect
testing
Fault
injection
Voas
McGraw
deliberate
injection
errors
program
program
executed
lead
program
faults
associated
failures
analyze
failure
discover
root
cause
one
errors
added
program
find
X
injected
faults
lead
failures
proponents
fault
injection
argue
suggests
defect
testing
process
discovered
X
actual
faults
program
approach
assumes
distribution
type
injected
faults
reflect
actual
faults
system
reasonable
think
true
faults
due
programming
errors
less
likely
true
faults
resulting
requirements
design
problems
Fault
injection
ineffective
predicting
number
faults
stem
anything
programming
errors
@@@@@@@@@@
Reliability
growth
modeling
reliability
growth
model
model
system
reliability
changes
time
testing
process
system
failures
discovered
underlying
faults
causing
failures
repaired
reliability
system
improve
system
testing
debugging
predict
reliability
conceptual
reliability
growth
model
translated
mathematical
model
http
software
engineering
book
com
web
reliability
growth
modeling
Operational
profiles
operational
profile
software
system
reflects
used
practice
consists
specification
classes
input
probability
occurrence
new
software
system
replaces
existing
automated
system
reasonably
easy
assess
probable
pattern
usage
new
software
correspond
existing
usage
allowance
made
new
functionality
presumably
included
new
software
example
operational
profile
specified
telephone
switching
systems
telecommunication
companies
know
call
patterns
systems
handle
Typically
operational
profile
inputs
highest
probability
generated
fall
small
number
classes
shown
left
Figure
many
classes
inputs
highly
improbable
impossible
shown
right
Figure
ellipsis
means
many
uncommon
inputs
shown
Musa
Musa
discusses
development
operational
profiles
telecommunication
systems
long
history
collecting
usage
data
domain
process
operational
profile
development
relatively
straightforward
simply
reflects
historical
usage
data
system
required
person
years
development
effort
operational
profile
developed
person
month
cases
operational
profile
generation
took
longer
person
years
cost
spread
number
system
releases
software
system
new
innovative
however
difficult
anticipate
used
Consequently
practically
impossible
create
accurate
operational
profile
Many
different
users
different
expectations
backgrounds
experience
use
new
system
no
historical
usage
database
users
make
use
systems
ways
system
developers
anticipate
Developing
accurate
operational
profile
certainly
possible
types
system
telecommunication
systems
standardized
pattern
use
However
types
system
developing
accurate
operational
profile
difficult
impossible
system
many
different
users
ways
using
system
explained
earlier
chapter
different
users
@@@@@@@@@@
Chapter
Key
points
Figure
Distribution
inputs
operational
profile
Number
inputs
Input
classes
different
impressions
reliability
use
system
different
ways
difficult
match
patterns
use
single
operational
profile
Users
change
ways
use
system
time
users
learn
new
system
confident
start
use
sophisticated
ways
Therefore
operational
profile
matches
initial
usage
pattern
system
valid
users
familiar
system
reasons
often
impossible
develop
trustworthy
operational
profile
use
date
incorrect
operational
profile
cannot
confident
accuracy
reliability
measurements
make
Key
Points
Software
reliability
achieved
avoiding
introduction
faults
detecting
removing
faults
system
deployment
including
fault
tolerance
facilities
allow
system
remain
operational
fault
caused
system
failure
Reliability
requirements
defined
quantitatively
system
requirements
specification
Reliability
metrics
include
probability
failure
demand
POFOD
rate
occurrence
failure
ROCOF
availability
AVAIL
Functional
reliability
requirements
requirements
system
functionality
checking
redundancy
requirements
help
system
meet
non
functional
reliability
requirements
@@@@@@@@@@
Chapter
Reliability
engineering
Dependable
system
architectures
system
architectures
designed
fault
tolerance
number
architectural
styles
support
fault
tolerance
including
protection
systems
self
monitoring
architectures
N
version
programming
Software
diversity
difficult
achieve
practically
impossible
ensure
version
software
truly
independent
Dependable
programming
relies
including
redundancy
program
checks
validity
inputs
values
program
variables
Statistical
testing
used
estimate
software
reliability
relies
testing
system
test
data
matches
operational
profile
reflects
distribution
inputs
software
use
ReAding
Software
Fault
Tolerance
Techniques
Implementation
comprehensive
discussion
techniques
achieve
software
fault
tolerance
fault
tolerant
architectures
book
covers
general
issues
software
dependability
Reliability
engineering
mature
area
techniques
discussed
still
current
L
L
Pullum
Artech
House
Software
Reliability
Engineering
Roadmap
survey
paper
leading
researcher
software
reliability
summarizes
state
art
software
reliability
engineering
discusses
research
challenges
area
M
R
Lyu
Proc
Future
Software
Engineering
IEEE
Computer
Society
http
dx
doi
org
FOSE
Mars
Code
paper
discusses
approach
reliability
engineering
used
development
software
Mars
Curiosity
Rover
relied
use
good
programming
practice
redundancy
model
checking
covered
Chapter
G
J
Holzmann
Comm
ACM
http
dx
doi
org
Website
PowerPoint
slides
chapter
www
pearsonglobaleditions
com
Sommerville
Links
supporting
videos
http
software
engineering
book
com
videos
reliability
safety
information
Airbus
flight
control
system
http
software
engineering
book
com
case
studies
airbus
@@@@@@@@@@
Chapter
Exercises
ExErcisEs
Explain
practically
impossible
validate
reliability
specifications
expressed
terms
small
number
failures
total
lifetime
system
Suggest
appropriate
reliability
metrics
classes
software
system
Give
reasons
choice
metric
Predict
usage
systems
suggest
appropriate
values
reliability
metrics
system
monitors
patients
hospital
intensive
care
unit
word
processor
automated
vending
machine
control
system
system
control
braking
car
system
control
refrigeration
unit
management
report
generator
Imagine
network
operations
center
monitors
controls
national
telecommunications
network
country
includes
controlling
monitoring
operational
status
switching
transmission
equipment
keeping
track
nationwide
equipment
inventories
center
needs
redundant
systems
Explain
three
reliability
metrics
use
specify
needs
systems
common
characteristic
architectural
styles
geared
supporting
software
fault
tolerance
Suggest
circumstances
appropriate
use
fault
tolerant
architecture
implementing
software
based
control
system
explain
approach
required
responsible
design
communications
switch
provide
availability
safety
critical
Giving
reasons
answer
suggest
architectural
style
used
system
suggested
control
software
radiation
therapy
machine
used
treat
patients
cancer
implemented
using
N
version
programming
Comment
think
good
suggestion
Explain
versions
system
designed
around
software
diversity
fail
similar
way
Explain
programming
language
support
exception
handling
contribute
reliability
software
systems
Software
failures
cause
considerable
inconvenience
users
software
ethical
companies
release
software
know
includes
faults
lead
software
failures
liable
compensating
users
losses
caused
failure
software
required
law
offer
soft
ware
warranties
way
consumer
goods
manufacturers
guarantee
products
@@@@@@@@@@
Chapter
Reliability
engineering
ReFeRenCes
Avizienis
Methodology
N
Version
Programming
Software
Fault
Tolerance
edited
M
R
Lyu
Chichester
UK
John
Wiley
Sons
Brilliant
S
S
J
C
Knight
N
G
Leveson
Analysis
Faults
N
Version
Software
Experiment
IEEE
Trans
Software
Engineering
doi
Hatton
L
N
Version
Design
Versus
One
Good
Version
IEEE
Software
doi
Leveson
N
G
Safeware
System
Safety
Computers
Reading
MA
Addison
Wesley
Musa
J
D
Software
Reliability
Engineering
Reliable
Software
Faster
Development
Testing
New
York
McGraw
Hill
Prowell
S
J
C
J
Trammell
R
C
Linger
J
H
Poore
Cleanroom
Software
Engineering
Technology
Process
Reading
MA
Addison
Wesley
Pullum
L
Software
Fault
Tolerance
Techniques
Implementation
Norwood
MA
Artech
House
Randell
B
Facing
Faults
Computer
J
doi
comjnl
Torres
Pomales
W
Software
Fault
Tolerance
Tutorial
NASA
http
ntrs
nasa
gov
archive
nasa
casi
pdf
Voas
J
G
McGraw
Software
Fault
Injection
Innoculating
Programs
Errors
New
York
John
Wiley
Sons
@@@@@@@@@@
Safety
engineering
Objectives
objective
chapter
explain
techniques
used
ensure
safety
developing
critical
systems
read
chapter
understand
meant
safety
critical
system
safety
considered
separately
reliability
critical
systems
engineering
understand
analysis
hazards
used
derive
safety
requirements
know
processes
tools
used
software
safety
assurance
understand
notion
safety
case
used
justify
safety
system
regulators
formal
arguments
used
safety
cases
Contents
Safety
critical
systems
Safety
requirements
Safety
engineering
processes
Safety
cases
@@@@@@@@@@
Chapter
Safety
engineering
Section
briefly
described
air
accident
Warsaw
Airport
Airbus
crashed
landing
Two
people
killed
injured
subsequent
inquiry
showed
major
contributory
cause
accident
failure
control
software
reduced
efficiency
aircraft
s
braking
system
one
thankfully
rare
examples
behavior
software
system
led
death
injury
illustrates
software
now
central
component
many
systems
critical
preserving
maintaining
life
safety
critical
software
systems
range
specialized
methods
techniques
developed
safety
critical
software
engineering
discussed
Chapter
safety
one
principal
dependability
properties
system
considered
safe
operates
without
catastrophic
failure
failure
causes
cause
death
injury
people
Systems
failure
lead
environmental
damage
safety
critical
environmental
damage
chemical
leak
lead
subsequent
human
injury
death
Software
safety
critical
systems
dual
role
play
achieving
safety
system
software
controlled
decisions
made
software
subsequent
actions
safety
critical
Therefore
software
behavior
directly
related
overall
safety
system
Software
extensively
used
checking
monitoring
safety
critical
components
system
example
aircraft
engine
components
monitored
software
looking
early
indications
component
failure
software
safety
critical
fails
components
fail
cause
accident
Safety
software
systems
achieved
developing
understanding
situations
lead
safety
related
failures
software
engineered
failures
occur
therefore
think
safety
critical
system
reliable
behaves
specified
therefore
safe
Unfortunately
isn
t
quite
simple
System
reliability
necessary
safety
achievement
isn
t
enough
Reliable
systems
unsafe
vice
versa
Warsaw
Airport
accident
example
situation
ll
discuss
detail
Section
Software
systems
reliable
safe
four
reasons
never
certain
software
system
fault
free
fault
tolerant
Undetected
faults
dormant
long
time
software
failures
occur
many
years
reliable
operation
specification
incomplete
describe
required
behavior
system
critical
situations
high
percentage
system
malfunctions
result
specification
rather
design
errors
study
errors
embedded
systems
Lutz
Lutz
concludes
difficulties
requirements
key
root
cause
safety
related
software
errors
persisted
integration
system
testing
Lutz
R
R
Analysing
Software
Requirements
Errors
Safety
Critical
Embedded
Systems
RE
San
Diego
CA
IEEE
doi
ISRE
@@@@@@@@@@
Safety
critical
systems
recent
work
Veras
et
al
Veras
et
al
space
systems
confirms
requirements
errors
still
major
problem
embedded
systems
Hardware
malfunctions
cause
sensors
actuators
behave
unpredictable
way
components
close
physical
failure
behave
erratically
generate
signals
outside
ranges
handled
software
software
fail
wrongly
interpret
signals
system
operators
generate
inputs
individually
incorrect
situations
lead
system
malfunction
anecdotal
example
occurred
aircraft
undercarriage
collapsed
aircraft
ground
Apparently
technician
pressed
button
instructed
utility
management
software
raise
undercarriage
software
carried
mechanic
s
instruction
perfectly
However
system
disallowed
command
unless
plane
air
Therefore
safety
considered
well
reliability
developing
safety
critical
systems
reliability
engineering
techniques
introduced
Chapter
obviously
applicable
safety
critical
systems
engineering
therefore
discuss
system
architectures
dependable
programming
instead
focus
techniques
improving
assuring
system
safety
Safety
critical
systems
Safety
critical
systems
systems
essential
system
operation
safe
system
never
damage
people
system
s
environment
irrespective
system
conforms
specification
Examples
safety
critical
systems
include
control
monitoring
systems
aircraft
process
control
systems
chemical
pharmaceutical
plants
automobile
control
systems
Safety
critical
software
falls
two
classes
Primary
safety
critical
software
software
embedded
controller
system
Malfunctioning
software
cause
hardware
malfunction
results
human
injury
environmental
damage
insulin
pump
software
introduced
Chapter
example
primary
safety
critical
system
System
failure
lead
user
injury
insulin
pump
system
simple
system
software
control
used
complex
safety
critical
systems
Software
rather
hardware
control
essential
need
manage
large
numbers
sensors
actuators
complex
control
laws
example
advanced
aerodynamically
unstable
military
aircraft
require
continual
software
controlled
adjustment
flight
surfaces
ensure
crash
Secondary
safety
critical
software
software
indirectly
result
injury
example
software
computer
aided
engineering
design
system
@@@@@@@@@@
Chapter
Safety
engineering
malfunctioning
result
design
fault
object
designed
fault
cause
injury
people
designed
system
malfunctions
Another
example
secondary
safety
critical
system
Mentcare
system
mental
health
patient
management
Failure
system
whereby
unstable
patient
treated
properly
lead
patient
injuring
others
control
systems
controlling
critical
national
infrastructure
electricity
supply
telecommunications
sewage
treatment
etc
secondary
safety
critical
systems
Failure
systems
unlikely
immediate
human
consequences
However
prolonged
outage
controlled
systems
lead
injury
death
example
failure
sewage
treatment
system
lead
higher
level
infectious
disease
raw
sewage
released
environment
explained
Chapter
software
system
availability
reliability
achieved
fault
avoidance
fault
detection
removal
fault
tolerance
Safety
critical
systems
development
uses
approaches
augments
hazard
driven
techniques
consider
potential
system
accidents
occur
Hazard
avoidance
system
designed
hazards
avoided
example
paper
cutting
system
requires
operator
use
two
hands
press
separate
buttons
simultaneously
avoids
hazard
operator
s
hands
blade
s
pathway
Hazard
detection
removal
system
designed
hazards
detected
removed
result
accident
example
chemical
plant
system
detect
excessive
pressure
open
relief
valve
reduce
pressure
explosion
occurs
Damage
limitation
system
include
protection
features
minimize
damage
result
accident
example
aircraft
engine
normally
includes
automatic
fire
extinguishers
engine
fire
often
controlled
poses
threat
aircraft
hazard
system
state
lead
accident
Using
example
paper
cutting
system
hazard
arises
operator
s
hand
position
cutting
blade
injure
Hazards
accidents
often
get
hazardous
situations
get
without
problems
However
accidents
preceded
hazards
reducing
hazards
reduces
accidents
hazard
one
example
specialized
vocabulary
used
safety
critical
systems
engineering
explain
terminology
used
safety
critical
systems
Figure
now
pretty
good
building
systems
cope
one
thing
going
wrong
design
mechanisms
system
detect
recover
single
problems
However
several
things
go
wrong
time
accidents
likely
systems
complex
don
t
understand
relationships
different
parts
system
Consequently
cannot
predict
consequences
combination
unexpected
system
events
failures
analysis
serious
accidents
Perrow
Perrow
suggested
accidents
due
combination
failures
different
parts
system
@@@@@@@@@@
Safety
critical
systems
Term
Definition
Accident
mishap
unplanned
event
sequence
events
results
human
death
injury
damage
property
environment
overdose
insulin
example
accident
measure
loss
resulting
mishap
Damage
range
many
people
killed
result
accident
minor
injury
property
damage
Damage
resulting
overdose
insulin
lead
serious
injury
death
user
insulin
pump
condition
potential
causing
contributing
accident
failure
sensor
measures
blood
glucose
example
hazard
probability
events
occurring
create
hazard
Probability
values
tend
arbitrary
range
probable
say
chance
hazard
occurring
implausible
no
conceivable
situations
likely
hazard
occur
probability
sensor
failure
insulin
pump
overestimates
user
s
blood
sugar
level
low
assessment
worst
possible
damage
result
particular
hazard
Hazard
severity
range
catastrophic
many
people
killed
minor
minor
damage
results
individual
death
possibility
reasonable
assessment
hazard
severity
high
measure
probability
system
cause
accident
risk
assessed
considering
hazard
probability
hazard
severity
probability
hazard
lead
accident
risk
insulin
overdose
medium
low
Damage
Hazard
Hazard
probability
Hazard
severity
Risk
Figure
Safety
Unanticipated
combinations
subsystem
failures
led
interactions
resulted
terminology
overall
system
failure
example
failure
air
conditioning
system
lead
overheating
hardware
gets
hot
behavior
becomes
unpredictable
overheating
lead
system
hardware
generating
incorrect
signals
wrong
signals
cause
software
react
incorrectly
Perrow
made
point
complex
systems
impossible
anticipate
possible
combinations
failures
therefore
coined
phrase
normal
accidents
implication
accidents
considered
inevitable
build
complex
safety
critical
systems
reduce
complexity
use
simple
hardware
controllers
rather
software
control
However
software
controlled
systems
monitor
wider
range
conditions
simpler
electromechanical
systems
adapted
relatively
easily
use
computer
hardware
high
inherent
reliability
physically
small
lightweight
Software
controlled
systems
provide
sophisticated
safety
interlocks
support
control
strategies
reduce
amount
time
people
need
spend
hazardous
environments
software
control
introduce
ways
system
go
wrong
allows
better
monitoring
protection
Therefore
software
control
contribute
improvements
system
safety
important
maintain
sense
proportion
safety
critical
systems
Critical
software
systems
operate
without
problems
time
Relatively
people
worldwide
killed
injured
faulty
software
Perrow
right
say
@@@@@@@@@@
Chapter
Safety
engineering
Risk
based
requirements
specification
Risk
based
specification
approach
widely
used
safety
security
critical
systems
developers
focuses
events
cause
damage
likely
occur
frequently
Events
minor
consequences
extremely
rare
ignored
risk
based
specification
process
involves
understanding
risks
faced
system
discovering
root
causes
generating
requirements
manage
risks
http
software
engineering
book
com
web
risk
based
specification
ing
accidents
possibility
impossible
make
system
safe
society
decide
consequences
occasional
accident
worth
benefits
come
use
advanced
technologies
Safety
requirements
introduction
chapter
described
air
accident
Warsaw
Airport
braking
system
Airbus
failed
inquiry
accident
showed
braking
system
software
operated
according
specification
no
errors
program
However
software
specification
incomplete
taken
account
rare
situation
arose
case
software
worked
system
failed
episode
illustrates
system
safety
depend
good
engineering
requires
attention
detail
system
requirements
derived
inclusion
special
software
requirements
geared
ensuring
safety
system
Safety
requirements
functional
requirements
define
checking
recovery
facilities
included
system
features
provide
protection
system
failures
external
attacks
starting
point
generating
functional
safety
requirements
usually
domain
knowledge
safety
standards
regulations
lead
high
level
requirements
perhaps
best
described
shall
requirements
contrast
normal
functional
requirements
define
system
shall
shall
requirements
define
system
behavior
unacceptable
Examples
shall
requirements
system
shall
allow
reverse
thrust
mode
selected
aircraft
flight
system
shall
allow
simultaneous
activation
three
alarm
signals
navigation
system
shall
allow
users
set
required
destination
car
moving
shall
requirements
cannot
implemented
directly
decomposed
specific
software
functional
requirements
Alternatively
implemented
system
design
decisions
decision
use
particular
types
equipment
system
@@@@@@@@@@
Safety
requirements
Hazard
probability
acceptability
Safety
requirements
Root
cause
analysesHazard
register
Hazard
identification
Hazard
assessment
Hazard
analysis
Risk
reduction
Figure
Hazard
driven
requirements
specification
Safety
requirements
primarily
protection
requirements
concerned
normal
system
operation
specify
system
shut
safety
maintained
deriving
safety
requirements
therefore
need
find
acceptable
balance
safety
functionality
avoid
overprotection
no
point
building
safe
system
operate
cost
effective
way
Risk
based
requirements
specification
general
approach
used
critical
systems
engineering
risks
faced
system
identified
requirements
avoid
mitigate
risks
identified
used
types
dependability
requirements
safety
critical
systems
translates
process
driven
identified
hazards
discussed
previous
section
hazard
something
need
result
death
injury
person
four
activities
hazard
driven
safety
specification
process
Hazard
identification
hazard
identification
process
identifies
hazards
threaten
system
hazards
recorded
hazard
register
formal
document
records
safety
analyses
assessments
submitted
regulator
part
safety
case
Hazard
assessment
hazard
assessment
process
decides
hazards
dangerous
likely
occur
prioritized
deriving
safety
requirements
Hazard
analysis
process
root
cause
analysis
identifies
events
lead
occurrence
hazard
Risk
reduction
process
based
outcome
hazard
analysis
leads
identification
safety
requirements
requirements
concerned
ensuring
hazard
arise
lead
accident
accident
occur
associated
damage
minimized
Figure
illustrates
hazard
driven
safety
requirements
specification
process
Hazard
identification
safety
critical
systems
hazard
identification
starts
identifying
different
classes
hazards
physical
electrical
biological
radiation
service
failure
hazards
classes
analyzed
discover
specific
hazards
occur
Possible
combinations
hazards
potentially
dangerous
identified
@@@@@@@@@@
Chapter
Safety
engineering
Experienced
engineers
working
domain
experts
professional
safety
advisers
identify
hazards
previous
experience
analysis
application
domain
Group
working
techniques
brainstorming
used
group
meets
exchange
ideas
insulin
pump
system
people
involved
include
doctors
medical
physicists
engineers
software
designers
insulin
pump
system
introduced
Chapter
safety
critical
system
failure
cause
injury
even
death
system
user
Accidents
occur
using
machine
include
user
suffering
long
term
consequences
poor
blood
sugar
control
eye
heart
kidney
problems
cognitive
dysfunction
result
low
blood
sugar
levels
occurrence
medical
conditions
allergic
reaction
hazards
arise
insulin
pump
system
insulin
overdose
computation
service
failure
insulin
underdose
computation
service
failure
failure
hardware
monitoring
system
service
failure
power
failure
due
exhausted
battery
electrical
electrical
interference
medical
equipment
heart
pacemaker
electrical
poor
sensor
actuator
contact
caused
incorrect
fitting
physical
parts
machine
breaking
off
patient
s
body
physical
infection
caused
introduction
machine
biological
allergic
reaction
materials
insulin
used
machine
biological
Software
related
hazards
normally
concerned
failure
deliver
system
service
failure
monitoring
protection
systems
Monitoring
protection
systems
included
device
detect
conditions
low
battery
level
lead
device
failure
hazard
register
used
record
identified
hazards
explanation
hazard
included
hazard
register
important
legal
document
records
safety
related
decisions
hazard
used
show
requirements
engineers
paid
due
care
attention
considering
foreseeable
hazards
hazards
analyzed
event
accident
hazard
register
used
subsequent
inquiry
legal
proceedings
show
system
developers
negligent
system
safety
analysis
Hazard
assessment
hazard
assessment
process
focuses
understanding
factors
lead
occurrence
hazard
consequences
accident
incident
associated
hazard
occur
need
carry
analysis
understand
@@@@@@@@@@
Safety
requirements
Unacceptable
region
Risk
cannot
tolerated
Risk
tolerated
ALARP
risk
reduction
impractical
region
excessively
expensive
Acceptable
region
Figure
risk
triangle
Negligible
risk
hazard
serious
threat
system
environment
analysis
provides
basis
deciding
manage
risk
associated
hazard
hazard
outcome
analysis
classification
process
statement
acceptability
expressed
terms
risk
risk
takes
account
likelihood
accident
consequences
three
risk
categories
used
hazard
assessment
Intolerable
risks
safety
critical
systems
threaten
human
life
system
designed
hazards
cannot
arise
features
system
ensure
detected
cause
accident
case
insulin
pump
intolerable
risk
overdose
insulin
delivered
low
reasonably
practical
ALARP
risks
less
serious
consequences
serious
low
probability
occurrence
system
designed
probability
accident
arising
hazard
minimized
subject
considerations
cost
delivery
ALARP
risk
insulin
pump
failure
hardware
monitoring
system
consequences
failure
worst
short
term
insulin
underdose
situation
lead
serious
accident
Acceptable
risks
associated
accidents
normally
result
minor
damage
System
designers
take
possible
steps
reduce
acceptable
risks
long
measures
significantly
increase
costs
delivery
time
non
functional
system
attributes
acceptable
risk
case
insulin
pump
risk
allergic
reaction
arising
user
reaction
usually
causes
minor
skin
irritation
worth
using
special
expensive
materials
device
reduce
risk
Figure
shows
three
regions
width
triangle
reflects
costs
ensuring
risks
result
incidents
accidents
highest
@@@@@@@@@@
Chapter
Safety
engineering
Identified
hazard
Hazard
probability
Accident
severity
Estimated
risk
Acceptability
Insulin
overdose
computation
Medium
High
High
Intolerable
Insulin
underdose
computation
Medium
Low
Low
Acceptable
Failure
hardware
monitoring
system
Medium
Medium
Low
ALARP
Power
failure
High
Low
Low
Acceptable
Machine
incorrectly
fitted
High
High
High
Intolerable
Machine
breaks
patient
Low
High
Medium
ALARP
Machine
causes
infection
Medium
Medium
Medium
ALARP
Electrical
interference
Low
High
Medium
ALARP
Allergic
reaction
Low
Low
Low
Acceptable
Figure
Risk
classification
insulin
pump
costs
incurred
risks
top
diagram
lowest
costs
risks
apex
triangle
boundaries
regions
Figure
fixed
depend
acceptable
risks
societies
system
deployed
varies
country
country
societies
risk
averse
litigious
others
time
however
societies
risk
averse
boundaries
moved
downward
rare
events
financial
costs
accepting
risks
paying
resulting
accidents
less
costs
accident
prevention
However
public
opinion
demand
money
spent
reduce
likelihood
system
accident
irrespective
cost
example
cheaper
company
clean
pollution
rare
occasion
occurs
rather
install
systems
pollution
prevention
However
public
media
tolerate
accidents
clearing
damage
rather
preventing
accident
no
longer
acceptable
Events
systems
lead
reclassification
risk
example
risks
thought
improbable
ALARP
region
reclassified
intolerable
external
events
terrorist
attacks
natural
phenomena
tsunamis
Figure
shows
risk
classification
hazards
identified
previous
section
insulin
delivery
system
separated
hazards
relate
incorrect
computation
insulin
insulin
overdose
insulin
underdose
insulin
overdose
potentially
serious
insulin
underdose
short
term
Insulin
overdose
result
cognitive
dysfunction
coma
ultimately
death
Insulin
underdoses
lead
high
levels
blood
sugar
short
term
high
levels
cause
tiredness
serious
longer
term
however
lead
serious
heart
kidney
eye
problems
Hazards
Figure
software
related
software
nevertheless
role
play
hazard
detection
hardware
monitoring
software
monitor
system
state
warn
potential
problems
warning
often
allow
hazard
@@@@@@@@@@
Safety
requirements
detected
causes
accident
Examples
hazards
detected
power
failure
detected
monitoring
battery
incorrect
fitting
machine
detected
monitoring
signals
blood
sugar
sensor
monitoring
software
system
course
safety
related
Failure
detect
hazard
result
accident
monitoring
system
fails
hardware
working
correctly
serious
failure
However
monitoring
system
fails
hardware
failure
cannot
detected
serious
consequences
Hazard
assessment
involves
estimating
hazard
probability
risk
severity
difficult
hazards
accidents
uncommon
Consequently
engineers
involved
direct
experience
previous
incidents
accidents
estimating
probabilities
accident
severity
makes
sense
use
relative
terms
probable
unlikely
rare
high
medium
low
Quantifying
terms
practically
impossible
enough
statistical
data
available
types
accident
Hazard
analysis
Hazard
analysis
process
discovering
root
causes
hazards
safety
critical
system
aim
find
events
combination
events
cause
system
failure
results
hazard
use
top
bottom
approach
Deductive
top
techniques
easier
use
start
hazard
work
possible
system
failure
Inductive
bottom
techniques
start
proposed
system
failure
identify
hazards
result
failure
Various
techniques
proposed
possible
approaches
hazard
decomposition
analysis
Storey
One
commonly
used
techniques
fault
tree
analysis
top
technique
developed
analysis
hardware
software
hazards
Leveson
Cha
Shimeall
technique
fairly
easy
understand
without
specialist
domain
knowledge
fault
tree
analysis
start
hazards
identified
hazard
work
backwards
discover
possible
causes
hazard
put
hazard
root
tree
identify
system
states
lead
hazard
states
identify
system
states
lead
continue
decomposition
reach
root
cause
s
risk
Hazards
arise
combination
root
causes
usually
less
likely
lead
accident
hazards
single
root
cause
Figure
fault
tree
software
related
hazards
insulin
delivery
system
lead
incorrect
dose
insulin
delivered
case
merged
insulin
underdose
insulin
overdose
single
hazard
namely
incorrect
insulin
dose
administered
reduces
number
fault
trees
required
course
specify
software
react
hazard
distinguish
insulin
underdose
insulin
overdose
said
equally
serious
short
term
overdose
serious
hazard
Figure
see
Three
conditions
lead
administration
incorrect
dose
insulin
level
blood
sugar
incorrectly
measured
insulin
requirement
computed
incorrect
input
delivery
system
@@@@@@@@@@
Chapter
Safety
engineering
Incorrect
sugar
level
measured
Incorrect
insulin
dose
administered
Correct
dose
delivered
wrong
time
Sensor
failure
Sugar
computation
error
Timer
failure
Pump
signals
incorrect
Insulin
computation
incorrect
Delivery
system
failure
Arithmetic
error
Algorithm
error
Arithmetic
error
Algorithm
error
Figure
example
fault
tree
respond
correctly
commands
specifying
amount
insulin
injected
Alternatively
dose
correctly
computed
delivered
early
late
left
branch
fault
tree
concerned
incorrect
measurement
blood
sugar
level
identifies
happen
occur
sensor
provides
input
calculate
sugar
level
failed
calculation
blood
sugar
level
carried
incorrectly
sugar
level
calculated
measured
parameter
conductivity
skin
Incorrect
computation
result
incorrect
algorithm
arithmetic
error
results
use
floating
point
numbers
central
branch
tree
concerned
timing
problems
concludes
result
system
timer
failure
@@@@@@@@@@
Safety
requirements
right
branch
tree
concerned
delivery
system
failure
examines
possible
causes
failure
result
incorrect
computation
insulin
requirement
failure
send
correct
signals
pump
delivers
insulin
incorrect
computation
result
algorithm
failure
arithmetic
errors
Fault
trees
used
identify
potential
hardware
problems
Hardware
fault
trees
provide
insights
requirements
software
detect
perhaps
correct
problems
example
insulin
doses
administered
frequently
no
five
six
times
per
hour
sometimes
less
often
Therefore
processor
capacity
available
run
diagnostic
self
checking
programs
Hardware
errors
sensor
pump
timer
errors
discovered
warnings
issued
serious
effect
patient
Risk
reduction
potential
risks
root
causes
identified
able
derive
safety
requirements
manage
risks
ensure
incidents
accidents
occur
use
three
possible
strategies
Hazard
avoidance
system
designed
hazard
cannot
occur
Hazard
detection
removal
system
designed
hazards
detected
neutralized
result
accident
Damage
limitation
system
designed
consequences
accident
minimized
Normally
designers
critical
systems
use
combination
approaches
safety
critical
system
intolerable
hazards
handled
minimizing
probability
adding
protection
system
see
Chapter
provides
safety
backup
example
chemical
plant
control
system
system
attempt
detect
avoid
excess
pressure
reactor
However
independent
protection
system
monitors
pressure
opens
relief
valve
high
pressure
detected
insulin
delivery
system
safe
state
shutdown
state
no
insulin
injected
short
period
threat
diabetic
s
health
software
failures
lead
incorrect
dose
insulin
following
solutions
developed
Arithmetic
error
error
occur
arithmetic
computation
causes
representation
failure
specification
identify
possible
arithmetic
errors
occur
state
exception
handler
included
possible
error
specification
set
action
taken
errors
default
safe
action
shut
delivery
system
activate
warning
alarm
Algorithmic
error
difficult
situation
no
clear
program
exception
handled
type
error
detected
comparing
@@@@@@@@@@
Chapter
Safety
engineering
Figure
Examples
safety
requirements
SR
system
shall
deliver
single
dose
insulin
greater
specified
maximum
dose
system
user
SR
system
shall
deliver
daily
cumulative
dose
insulin
greater
specified
maximum
daily
dose
system
user
SR
system
shall
include
hardware
diagnostic
facility
shall
executed
least
four
times
per
hour
SR
system
shall
include
exception
handler
exceptions
identified
Table
SR
audible
alarm
shall
sounded
hardware
software
anomaly
discovered
diagnostic
message
defined
Table
shall
displayed
SR
event
alarm
insulin
delivery
shall
suspended
user
reset
system
cleared
alarm
Note
Tables
relate
tables
included
requirements
document
shown
required
insulin
dose
computed
previously
delivered
dose
much
higher
mean
amount
computed
incorrectly
system
keep
track
dose
sequence
number
average
doses
delivered
warning
issued
dosage
limited
resulting
safety
requirements
insulin
pump
software
shown
Figure
requirements
Figure
user
requirements
Naturally
expressed
detail
detailed
system
requirements
specification
Safety
engineering
processes
software
processes
used
develop
safety
critical
software
based
processes
used
software
reliability
engineering
general
great
deal
care
taken
developing
complete
often
detailed
system
specification
design
implementation
system
usual
follow
plan
based
waterfall
model
reviews
checks
stage
process
Fault
avoidance
fault
detection
drivers
process
types
system
aircraft
systems
fault
tolerant
architectures
discussed
Chapter
used
Reliability
prerequisite
safety
critical
systems
high
costs
potentially
tragic
consequences
system
failure
additional
verification
activities
used
safety
critical
systems
development
activities
include
developing
formal
models
system
analyzing
discover
errors
inconsistencies
using
static
analysis
software
tools
parse
software
source
code
discover
potential
faults
Safe
systems
reliable
discussed
reliability
enough
Requirements
verification
errors
omissions
mean
reliable
systems
unsafe
Therefore
safety
critical
systems
development
processes
include
@@@@@@@@@@
Safety
engineering
processes
safety
reviews
engineers
system
stakeholders
examine
work
done
explicitly
look
potential
issues
affect
safety
system
types
safety
critical
systems
regulated
explained
Chapter
National
international
regulators
require
detailed
evidence
system
safe
evidence
include
specification
system
developed
records
checks
made
specification
Evidence
verification
validation
processes
carried
results
system
verification
validation
Evidence
organizations
developing
system
defined
dependable
software
processes
include
safety
assurance
reviews
records
showing
processes
properly
enacted
safety
critical
systems
regulated
example
no
regulator
automobiles
cars
now
many
embedded
computer
systems
safety
car
based
systems
responsibility
car
manufacturer
However
possibility
legal
action
event
accident
developers
unregulated
systems
maintain
detailed
safety
information
case
brought
able
show
negligent
development
car
s
software
need
extensive
process
product
documentation
another
reason
agile
processes
cannot
used
without
significant
change
safety
critical
systems
development
Agile
processes
focus
software
rightly
argue
great
deal
process
documentation
never
used
produced
However
keep
records
legal
regulatory
reasons
maintain
documentation
processes
used
system
Safety
critical
systems
like
types
system
high
dependability
requirements
need
based
dependable
processes
see
Chapter
dependable
process
normally
include
activities
requirements
management
change
management
configuration
control
system
modeling
reviews
inspections
test
planning
test
coverage
analysis
system
safety
critical
additional
safety
assurance
verification
analyses
processes
Safety
assurance
processes
Safety
assurance
set
activities
check
system
operate
safely
Specific
safety
assurance
activities
included
stages
software
development
process
activities
record
safety
analyses
carried
person
persons
responsible
analyses
Safety
assurance
activities
thoroughly
documented
documentation
part
evidence
used
convince
regulator
system
owner
system
operate
safely
@@@@@@@@@@
Chapter
Safety
engineering
Examples
safety
assurance
activities
Hazard
analysis
monitoring
hazards
traced
preliminary
hazard
analysis
testing
system
validation
Safety
reviews
used
throughout
development
process
Safety
certification
safety
critical
components
formally
certified
involves
group
external
system
development
team
examining
available
evidence
deciding
system
component
considered
safe
made
available
use
support
safety
assurance
processes
project
safety
engineers
appointed
explicit
responsibility
safety
aspects
system
individuals
accountable
safety
related
system
failure
occurs
able
demonstrate
safety
assurance
activities
properly
carried
Safety
engineers
work
quality
managers
ensure
detailed
configuration
management
system
used
track
safety
related
documentation
keep
step
associated
technical
documentation
little
point
stringent
validation
procedures
failure
configuration
management
means
wrong
system
delivered
customer
Quality
configuration
management
covered
Chapters
Hazard
analysis
essential
part
safety
critical
systems
development
involves
identifying
hazards
probability
occurrence
probability
hazard
leading
accident
program
code
checks
handles
hazard
argue
hazards
result
accidents
external
certification
required
system
used
e
g
aircraft
usually
condition
certification
traceability
demonstrated
central
safety
document
produced
hazard
register
document
provides
evidence
identified
hazards
taken
account
software
development
hazard
register
used
stage
software
development
process
document
development
stage
taken
hazards
account
simplified
example
hazard
register
entry
insulin
delivery
system
shown
Figure
register
documents
process
hazard
analysis
shows
design
requirements
generated
process
design
requirements
intended
ensure
control
system
never
deliver
insulin
overdose
user
insulin
pump
Individuals
safety
responsibilities
explicitly
identified
hazard
register
Personal
identification
important
two
reasons
people
identified
held
accountable
actions
likely
take
care
problems
traced
back
work
event
accident
legal
proceedings
inquiry
important
able
identify
responsible
safety
assurance
defend
actions
part
legal
process
@@@@@@@@@@
Safety
engineering
processes
Hazard
Register
Page
Printed
Figure
simplified
hazard
register
entry
System
Insulin
Pump
System
File
InsulinPump
Safety
HazardLog
Safety
Engineer
James
Brown
Log
version
Identified
Hazard
Insulin
overdose
delivered
patient
Identified
Jane
Williams
Criticality
class
Identified
risk
High
Fault
tree
identified
Date
Location
Hazard
register
Page
Fault
tree
creators
Jane
Williams
Bill
Smith
Fault
tree
checked
Date
Checker
James
Brown
System
safety
design
requirements
system
shall
include
self
testing
software
test
sensor
system
clock
insulin
delivery
system
self
checking
software
shall
executed
per
minute
event
self
checking
software
discovering
fault
system
components
audible
warning
shall
issued
pump
display
shall
indicate
name
component
fault
discovered
delivery
insulin
shall
suspended
system
shall
incorporate
override
system
allows
system
user
modify
computed
dose
insulin
delivered
system
amount
override
shall
no
greater
pre
set
value
maxOverride
set
system
configured
medical
staff
Safety
reviews
reviews
software
specification
design
source
code
aim
discover
potentially
hazardous
conditions
automated
processes
involve
people
carefully
checking
errors
made
assumptions
omissions
affect
safety
system
example
aircraft
accident
introduced
earlier
safety
review
questioned
assumption
aircraft
ground
weight
wheels
wheels
rotating
Safety
reviews
driven
hazard
register
identified
hazards
review
team
examines
system
judges
cope
hazard
safe
way
doubts
raised
flagged
review
team
s
report
addressed
system
development
team
discuss
reviews
different
types
detail
Chapter
covers
software
quality
assurance
Software
safety
certification
used
external
components
incorporated
safety
critical
system
parts
system
locally
developed
complete
information
development
processes
used
maintained
However
cost
effective
develop
components
readily
available
vendors
problem
safety
critical
systems
development
external
components
developed
different
standards
locally
developed
components
safety
unknown
Consequently
requirement
external
components
certified
integrated
system
safety
certification
team
separate
development
team
carries
extensive
verification
validation
@@@@@@@@@@
Chapter
Safety
engineering
Licensing
software
engineers
areas
engineering
safety
engineers
licensed
engineers
Inexperienced
poorly
qualified
engineers
allowed
take
responsibility
safety
states
United
States
form
licensing
software
engineers
involved
safety
related
systems
development
states
require
engineering
involved
safety
critical
software
development
licensed
engineers
defined
minimum
level
qualifications
experience
controversial
issue
licensing
required
many
countries
http
software
engineering
book
com
safety
licensing
components
appropriate
liaise
component
developers
check
developers
used
dependable
processes
create
components
examine
component
source
code
safety
certification
team
satisfied
component
meets
specification
hidden
functionality
issue
certificate
allowing
component
used
safety
critical
systems
Formal
verification
Formal
methods
software
development
discussed
Chapter
rely
formal
model
system
serves
system
specification
formal
methods
mainly
concerned
mathematically
analyzing
specification
transforming
specification
detailed
semantically
equivalent
representation
formally
verifying
one
representation
system
semantically
equivalent
another
representation
need
assurance
safety
critical
systems
one
principal
drivers
development
formal
methods
Comprehensive
system
testing
extremely
expensive
cannot
guaranteed
uncover
faults
system
particularly
true
systems
distributed
system
components
running
concurrently
Several
safety
critical
railway
systems
developed
using
formal
methods
s
Dehbonei
Mejia
Behm
et
al
Companies
Airbus
routinely
use
formal
methods
software
development
critical
systems
Souyris
et
al
Formal
methods
used
different
stages
V
V
process
formal
specification
system
developed
mathematically
analyzed
inconsistency
technique
effective
discovering
specification
errors
omissions
Model
checking
discussed
next
section
particularly
effective
approach
specification
analysis
formally
verify
using
mathematical
arguments
code
software
system
consistent
specification
requires
formal
specification
effective
discovering
programming
design
errors
wide
semantic
gap
formal
system
specification
program
code
difficult
expensive
prove
separately
developed
program
@@@@@@@@@@
Safety
engineering
processes
consistent
specification
Work
program
verification
now
mostly
based
transformational
development
transformational
development
process
formal
specification
systematically
transformed
series
representations
program
code
Software
tools
support
development
transformations
help
verify
corresponding
representations
system
consistent
B
method
probably
widely
used
formal
transformational
method
Abrial
used
development
train
control
systems
avionics
software
Advocates
formal
methods
claim
use
methods
leads
reliable
safer
systems
Formal
verification
demonstrates
developed
program
meets
specification
implementation
errors
compromise
dependability
system
develop
formal
model
concurrent
systems
using
specification
written
language
CSP
Schneider
discover
conditions
result
deadlock
final
program
able
address
problems
difficult
testing
alone
However
formal
specification
proof
guarantee
software
safe
practical
use
specification
reflect
real
requirements
users
system
stakeholders
discussed
Chapter
system
system
stakeholders
rarely
understand
formal
notations
cannot
directly
read
formal
specification
find
errors
omissions
means
likely
formal
specification
accurate
representation
system
requirements
proof
contain
errors
Program
proofs
large
complex
like
large
complex
programs
usually
contain
errors
proof
make
incorrect
assumptions
way
system
used
system
used
anticipated
system
s
behavior
lies
outside
scope
proof
Verifying
nontrivial
software
system
takes
great
deal
time
requires
mathematical
expertise
specialized
software
tools
theorem
provers
expensive
process
system
size
increases
costs
formal
verification
increase
disproportionately
Many
software
engineers
therefore
think
formal
verification
cost
effective
believe
level
confidence
system
achieved
cheaply
using
validation
techniques
inspections
system
testing
However
companies
Airbus
make
use
formal
verification
claim
unit
testing
components
required
leads
significant
cost
savings
Moy
et
al
convinced
formal
methods
formal
verification
important
role
play
development
critical
software
systems
Formal
specifications
effective
discovering
types
specification
problems
lead
system
failure
formal
verification
remains
impractical
large
systems
used
verify
critical
safety
security
critical
core
components
@@@@@@@@@@
Chapter
Safety
engineering
Model
buildingRequirements
design
program
Property
specification
Extended
finite
state
model
system
Desired
system
properties
Model
checker
Confirmation
counter
examplesFigure
Model
checking
Model
checking
Formally
verifying
programs
using
deductive
approach
difficult
expensive
alternative
approaches
formal
analysis
developed
based
restricted
notion
correctness
successful
approaches
called
model
checking
Jhala
Majumdar
Model
checking
involves
creating
formal
state
model
system
checking
correctness
model
using
specialized
software
tools
stages
involved
model
checking
shown
Figure
Model
checking
widely
used
check
hardware
systems
designs
increasingly
used
critical
software
systems
control
software
NASA
s
Mars
exploration
vehicles
Regan
Hamilton
Holzmann
Airbus
avionics
software
development
Bochot
et
al
Many
different
model
checking
tools
developed
SPIN
early
example
software
model
checker
Holzmann
recent
systems
include
SLAM
Microsoft
Ball
Levin
Rajamani
PRISM
Kwiatkowska
Norman
Parker
models
used
model
checking
systems
extended
finite
state
models
software
Models
expressed
language
whatever
model
checking
system
used
example
SPIN
model
checker
uses
language
called
Promela
set
desirable
system
properties
identified
written
formal
notation
usually
based
temporal
logic
example
wilderness
weather
system
property
checked
system
reach
transmitting
state
recording
state
model
checker
explores
paths
model
e
possible
state
transitions
checking
property
holds
path
model
checker
confirms
model
correct
respect
property
hold
particular
path
model
checker
outputs
counterexample
illustrating
property
true
Model
checking
particularly
useful
validation
concurrent
systems
notoriously
difficult
test
sensitivity
time
checker
explore
interleaved
concurrent
transitions
discover
potential
problems
key
issue
model
checking
creation
system
model
model
created
manually
requirements
design
document
expensive
process
model
creation
takes
great
deal
time
addition
possibility
model
created
accurate
model
requirements
design
therefore
@@@@@@@@@@
Safety
engineering
processes
best
model
created
automatically
program
source
code
Model
checkers
available
work
directly
programs
Java
C
C
Ada
Model
checking
computationally
expensive
uses
exhaustive
approach
check
paths
system
model
size
system
increases
number
states
consequent
increase
number
paths
checked
large
systems
therefore
model
checking
impractical
due
computer
time
required
run
checks
However
better
algorithms
development
identify
parts
state
explored
checking
particular
property
algorithms
incorporated
model
checkers
increasingly
possible
use
model
checking
routinely
large
scale
critical
systems
development
Static
program
analysis
Automated
static
analyzers
software
tools
scan
source
text
program
detect
possible
faults
anomalies
parse
program
text
thus
recognize
different
types
statements
program
detect
statements
well
formed
make
inferences
control
flow
program
many
cases
compute
set
possible
values
program
data
complement
error
detection
facilities
provided
language
compiler
used
part
inspection
process
separate
V
V
process
activity
Automated
static
analysis
faster
cheaper
detailed
code
reviews
effective
discovering
types
program
faults
However
cannot
discover
classes
errors
identified
program
inspection
meetings
Static
analysis
tools
Lopes
Vicente
Silva
work
source
code
system
types
analysis
least
no
inputs
required
means
programmers
need
learn
specialized
notations
write
program
specifications
benefits
analysis
immediately
clear
makes
automated
static
analysis
easier
introduce
development
process
formal
verification
model
checking
intention
automatic
static
analysis
draw
code
reader
s
attention
anomalies
program
variables
used
without
initialization
variables
unused
data
values
go
range
Examples
problems
detected
static
analysis
shown
Figure
course
specific
checks
made
static
analyzer
programming
languagespecific
depend
isn
t
allowed
language
Anomalies
often
result
programming
errors
omissions
highlight
things
go
wrong
program
executed
However
anomalies
necessarily
program
faults
deliberate
constructs
introduced
programmer
anomaly
no
adverse
consequences
Three
levels
checking
implemented
static
analyzers
Characteristic
error
checking
level
static
analyzer
knows
common
errors
made
programmers
languages
Java
C
tool
analyzes
code
looking
patterns
characteristic
problem
@@@@@@@@@@
Chapter
Safety
engineering
Fault
class
Static
analysis
check
Data
faults
Variables
used
initialization
Variables
declared
never
used
Variables
assigned
twice
never
used
assignments
Possible
array
bound
violations
Undeclared
variables
Figure
Automated
static
highlights
programmer
Though
relatively
simple
analysis
based
analysis
checks
common
errors
cost
effective
Zheng
collaborators
Zheng
et
al
analyzed
large
code
base
C
C
discovered
errors
programs
resulted
types
characteristic
error
Control
faults
Unreachable
code
Unconditional
branches
loops
Input
output
faults
Variables
output
twice
no
intervening
assignment
Interface
faults
Parameter
type
mismatches
Parameter
number
mismatches
Nonusage
results
functions
Uncalled
functions
procedures
Storage
management
faults
Unassigned
pointers
Pointer
arithmetic
Memory
leaks
User
defined
error
checking
approach
users
static
analyzer
define
error
patterns
detected
relate
application
domain
based
knowledge
specific
system
developed
example
error
pattern
maintain
ordering
example
method
called
method
B
time
organization
collect
information
common
bugs
occur
programs
extend
static
analysis
tools
error
patterns
highlight
errors
Assertion
checking
general
powerful
approach
static
analysis
Developers
include
formal
assertions
often
written
stylized
comments
program
state
relationships
hold
point
program
example
program
include
assertion
stating
value
variable
lie
range
x
y
analyzer
symbolically
executes
code
highlights
statements
assertion
hold
Static
analysis
effective
finding
errors
programs
commonly
generates
large
number
false
positives
code
sections
no
errors
static
analyzer
s
rules
detected
potential
error
number
false
positives
reduced
adding
information
program
form
assertions
requires
additional
work
developer
code
Work
done
screening
false
positives
code
checked
errors
Many
organizations
now
routinely
use
static
analysis
software
development
processes
Microsoft
introduced
static
analysis
development
device
@@@@@@@@@@
Safety
cases
drivers
program
failures
serious
effect
extended
approach
across
much
wider
range
software
look
security
problems
well
errors
affect
program
reliability
Ball
Levin
Rajamani
Checking
well
known
problems
buffer
overflow
effective
improving
security
attackers
often
base
attacks
common
vulnerabilities
Attacks
target
little
used
code
sections
thoroughly
tested
Static
analysis
cost
effective
way
finding
types
vulnerability
Safety
cases
discussed
many
safety
critical
software
intensive
systems
regulated
external
authority
significant
influence
development
deployment
Regulators
government
bodies
job
ensure
commercial
companies
deploy
systems
pose
threats
public
environmental
safety
national
economy
owners
safety
critical
systems
convince
regulators
made
best
possible
efforts
ensure
systems
safe
regulator
assesses
safety
case
system
presents
evidence
arguments
normal
operation
system
cause
harm
user
evidence
collected
systems
development
process
include
information
hazard
analysis
mitigation
test
results
static
analyses
information
development
processes
used
records
review
meetings
assembled
organized
safety
case
detailed
presentation
system
owners
developers
believe
system
safe
safety
case
set
documents
includes
description
system
certified
information
processes
used
develop
system
critically
logical
arguments
demonstrate
system
likely
safe
succinctly
Bishop
Bloomfield
Bishop
Bloomfield
define
safety
case
documented
body
evidence
provides
convincing
valid
argument
system
adequately
safe
given
application
given
environment
organization
contents
safety
case
depend
type
system
certified
context
operation
Figure
shows
one
possible
structure
safety
case
no
universal
industrial
standards
area
Safety
case
structures
vary
depending
industry
maturity
domain
example
nuclear
safety
cases
required
many
years
comprehensive
presented
way
familiar
nuclear
engineers
However
safety
cases
medical
devices
introduced
recently
case
structure
flexible
cases
less
detailed
nuclear
cases
safety
case
refers
system
whole
part
case
subsidiary
software
safety
case
constructing
software
safety
case
relate
software
failures
wider
system
failures
demonstrate
Bishop
P
R
E
Bloomfield
Methodology
Safety
Case
Development
Proc
Safety
Critical
Systems
Symposium
Birmingham
UK
Springer
http
www
adelard
com
papers
sss
web
pdf
@@@@@@@@@@
Chapter
Safety
engineering
Chapter
Description
System
description
overview
system
description
critical
components
Safety
requirements
safety
requirements
taken
system
requirements
specification
Details
relevant
system
requirements
included
Hazard
risk
analysis
Documents
describing
hazards
risks
identified
measures
taken
reduce
risk
Hazard
analyses
hazard
logs
Design
analysis
set
structured
arguments
see
Section
justify
design
safe
Verification
validation
description
V
V
procedures
used
appropriate
test
plans
system
Summaries
test
results
showing
defects
detected
corrected
formal
methods
used
formal
system
specification
analyses
specification
Records
static
analyses
source
code
Review
reports
Records
design
safety
reviews
Team
competences
Evidence
competence
team
involved
safety
related
systems
development
validation
Process
QA
Records
quality
assurance
processes
see
Chapter
carried
system
development
Change
management
processes
Records
changes
proposed
actions
taken
appropriate
justification
safety
changes
Information
configuration
management
procedures
configuration
management
logs
Associated
safety
cases
References
safety
cases
impact
safety
case
Figure
Possible
contents
software
software
failures
occur
propagated
safety
case
way
dangerous
system
failures
occur
Safety
cases
large
complex
documents
expensive
produce
maintain
high
costs
safety
critical
system
developers
take
requirements
safety
case
account
development
process
Graydon
et
al
Graydon
Knight
Strunk
argue
development
safety
case
tightly
integrated
system
design
implementation
means
system
design
decisions
influenced
requirements
safety
case
Design
choices
add
significantly
difficulties
costs
case
development
avoided
Regulators
views
acceptable
unacceptable
safety
case
therefore
makes
sense
development
team
work
early
development
establish
regulator
expects
system
safety
case
development
safety
cases
expensive
costs
record
keeping
required
well
costs
comprehensive
system
validation
safety
assurance
processes
System
changes
rework
add
costs
safety
@@@@@@@@@@
Safety
cases
EVIDENCE
EVIDENCE
EVIDENCE
ARGUMENT
CLAIM
Supports
Supports
Supports
Justifies
Figure
Structured
arguments
case
software
hardware
changes
made
system
large
part
safety
case
rewritten
demonstrate
system
safety
affected
change
Structured
arguments
decision
system
operationally
safe
based
logical
arguments
arguments
demonstrate
evidence
presented
supports
claims
system
s
security
dependability
claims
absolute
event
X
happen
probabilistic
probability
occurrence
event
Y
n
argument
links
evidence
claim
shown
Figure
argument
relationship
thought
case
claim
body
evidence
collected
argument
essentially
explains
claim
assertion
system
security
dependability
inferred
available
evidence
Arguments
safety
case
usually
presented
claim
based
arguments
claim
system
safety
made
basis
available
evidence
argument
presented
claim
holds
example
following
argument
used
justify
claim
computations
carried
control
software
insulin
pump
lead
overdose
insulin
delivered
course
simplified
presentation
argument
real
safety
case
detailed
references
evidence
presented
Claim
maximum
single
dose
computed
insulin
pump
exceed
maxDose
maxDose
assessed
safe
single
dose
particular
patient
Evidence
Safety
argument
insulin
pump
software
control
program
covered
later
section
Evidence
Test
datasets
insulin
pump
tests
provided
complete
code
coverage
value
dose
insulin
delivered
currentDose
never
exceeded
maxDose
@@@@@@@@@@
Chapter
Safety
engineering
maximum
single
dose
computed
pump
software
exceed
maxDose
maxDose
set
correctly
pump
configured
maxDose
safe
dose
user
insulin
pump
insulin
pump
deliver
single
dose
insulin
unsafe
normal
operation
maximum
dose
computed
exceed
maxDose
software
fails
maximum
dose
computed
exceed
maxDose
Figure
safety
claim
hierarchy
insulin
pump
Evidence
static
analysis
report
insulin
pump
control
program
static
analysis
control
software
revealed
no
anomalies
affected
value
currentDose
program
variable
holds
dose
insulin
delivered
Argument
evidence
presented
demonstrates
maximum
dose
insulin
computed
equal
maxDose
therefore
reasonable
assume
high
level
confidence
evidence
justifies
claim
insulin
pump
compute
dose
insulin
delivered
exceeds
maximum
single
safe
dose
evidence
presented
redundant
diverse
software
checked
using
several
different
mechanisms
significant
overlap
discussed
Chapter
using
redundant
diverse
processes
increases
confidence
omissions
mistakes
detected
one
validation
process
good
chance
found
one
processes
normally
many
claims
safety
system
validity
one
claim
often
depending
claims
valid
Therefore
claims
organized
hierarchy
Figure
shows
part
claim
hierarchy
insulin
pump
demonstrate
high
level
claim
valid
first
work
arguments
lower
level
claims
show
lower
level
claims
justified
able
infer
higher
level
claims
justified
Software
safety
arguments
general
assumption
underlies
work
system
safety
number
system
faults
lead
safety
hazards
significantly
less
total
number
faults
exist
system
Safety
assurance
therefore
concentrate
@@@@@@@@@@
Safety
cases
faults
hazard
potential
demonstrated
faults
cannot
occur
occur
associated
hazard
result
accident
system
safe
basis
software
safety
arguments
Software
safety
arguments
type
structured
argument
demonstrates
program
meets
safety
obligations
safety
argument
necessary
prove
program
works
intended
necessary
show
program
execution
cannot
result
reaching
potentially
unsafe
state
Safety
arguments
therefore
cheaper
make
correctness
arguments
don
t
consider
program
states
simply
concentrate
states
lead
hazard
Safety
arguments
demonstrate
assuming
normal
execution
conditions
program
safe
usually
based
contradiction
assume
system
unsafe
show
impossible
reach
unsafe
state
steps
involved
creating
safety
argument
start
assuming
unsafe
state
identified
system
hazard
analysis
reached
executing
program
write
predicate
logical
expression
defines
unsafe
state
systematically
analyze
system
model
program
show
program
paths
leading
state
terminating
condition
paths
defined
predicate
contradicts
unsafe
state
predicate
case
claim
initial
assumption
unsafe
state
incorrect
repeated
analysis
identified
hazards
strong
evidence
system
safe
Safety
arguments
applied
different
levels
requirements
design
models
code
requirements
level
trying
demonstrate
no
missing
safety
requirements
requirements
make
invalid
assumptions
system
design
level
analyze
state
model
system
find
unsafe
states
code
level
consider
paths
safety
critical
code
show
execution
paths
leads
contradiction
example
consider
code
outlined
Figure
simplified
description
part
implementation
insulin
delivery
system
code
computes
dose
insulin
delivered
applies
safety
checks
overdose
patient
Developing
safety
argument
code
involves
demonstrating
dose
insulin
administered
never
greater
maximum
safe
level
single
dose
dose
established
individual
diabetic
user
discussions
medical
advisors
demonstrate
safety
prove
system
delivers
correct
dose
merely
never
delivers
overdose
patient
work
assumption
maxDose
safe
level
system
user
construct
safety
argument
identify
predicate
defines
unsafe
state
currentDose
maxDose
demonstrate
program
paths
lead
contradiction
unsafe
assertion
case
unsafe
condition
cannot
true
prove
contradiction
confident
@@@@@@@@@@
Chapter
Safety
engineering
insulin
dose
delivered
function
blood
sugar
level
previous
dose
delivered
time
delivery
previous
dose
currentDose
computeInsulin
Safety
check
adjust
currentDose
necessary
statement
previousDose
currentDose
maxDose
currentDose
maxDose
currentDose
previousDose
currentDose
previousDose
statement
currentDose
minimumDose
currentDose
currentDose
maxDose
currentDose
maxDose
dose
computation
administerInsulin
currentDose
safety
checks
Figure
Insulin
program
compute
unsafe
dose
insulin
structure
present
safety
arguments
graphically
shown
Figure
safety
argument
shown
Figure
presents
three
possible
program
paths
lead
call
administerInsulin
method
show
amount
insulin
delivered
never
exceeds
maxDose
possible
program
paths
administerInsulin
considered
branch
statement
executed
happen
current
Dose
outside
range
minimumDose
maxDose
postcondition
predicate
therefore
currentDose
minimumDose
currentDose
maxDose
branch
statement
executed
case
assignment
setting
currentDose
zero
executed
Therefore
postcondition
predicate
currentDose
branch
statement
executed
case
assignment
setting
currentDose
maxDose
executed
Therefore
statement
executed
know
postcondition
currentDose
maxDose
three
cases
postcondition
predicates
contradict
unsafe
precondition
currentDose
maxDose
cannot
true
claim
initial
assumption
incorrect
computation
safe
construct
structured
argument
program
make
unsafe
computation
first
identify
possible
paths
code
lead
potentially
@@@@@@@@@@
Safety
cases
Figure
Informal
safety
argument
based
demonstrating
contradictions
currentDose
currentDose
statement
branch
executed
statement
executed
currentDose
maxDose
currentDose
maxDose
administerInsulin
ContradictionOverdose
administered
currentDose
minimumDose
Contradictionassign
Precondition
unsafe
state
Contradiction
currentDose
maxDose
assign
currentDose
maxDose
statement
branch
executed
unsafe
assignment
work
backwards
unsafe
state
consider
last
assignment
state
variables
path
leading
unsafe
state
show
none
values
variables
unsafe
shown
initial
assumption
computation
unsafe
incorrect
Working
backwards
important
means
ignore
intermediate
states
apart
final
states
lead
exit
condition
code
previous
values
don
t
matter
safety
system
example
need
concerned
set
possible
values
currentDose
immediately
administerInsulin
method
executed
ignore
computations
statement
Figure
safety
argument
results
overwritten
later
program
statements
@@@@@@@@@@
Chapter
Safety
engineering
Key
Points
Safety
critical
systems
systems
failure
lead
human
injury
death
hazard
driven
approach
used
understand
safety
requirements
safety
critical
systems
identify
potential
hazards
decompose
using
methods
fault
tree
analysis
discover
root
causes
specify
requirements
avoid
recover
problems
important
well
defined
certified
process
safety
critical
systems
development
process
include
identification
monitoring
potential
hazards
Static
analysis
approach
V
V
examines
source
code
representation
system
looking
errors
anomalies
allows
parts
program
checked
parts
exercised
system
tests
Model
checking
formal
approach
static
analysis
exhaustively
checks
states
system
potential
errors
Safety
dependability
cases
collect
evidence
demonstrates
system
safe
dependable
Safety
cases
required
external
regulator
certify
system
used
reading
Safeware
System
Safety
Computers
now
years
old
book
still
offers
best
thorough
coverage
safety
critical
systems
particularly
strong
description
hazard
analysis
derivation
requirements
N
Leveson
Addison
Wesley
Safety
Critical
Software
special
edition
IEEE
Software
magazine
focuses
safety
critical
systems
includes
papers
model
based
development
safety
critical
systems
model
checking
formal
methods
IEEE
Software
June
Constructing
Safety
Assurance
Cases
Medical
Devices
short
paper
gives
practical
example
safety
case
created
analgesic
pump
Ray
R
Cleaveland
Proc
Workshop
Assurance
Cases
Software
Intensive
Systems
San
Francisco
http
dx
doi
org
ASSURE
WebSite
PowerPoint
slides
chapter
www
pearsonglobaleditions
com
Sommerville
Links
supporting
videos
http
software
engineering
book
com
videos
reliability
safety
@@@@@@@@@@
Chapter
Exercises
exerCiSeS
Identify
six
consumer
products
likely
controlled
safety
critical
software
systems
software
system
deployed
company
extremely
high
safety
standards
allows
no
risks
even
minor
injuries
affect
look
risk
triangle
Figure
insulin
pump
system
user
change
needle
insulin
supply
regular
intervals
change
maximum
single
dose
maximum
daily
dose
administered
Suggest
three
user
errors
occur
propose
safety
requirements
avoid
errors
resulting
accident
safety
critical
software
system
managing
roller
coasters
controls
two
main
components
lock
release
roller
coaster
harness
supposed
keep
riders
place
coaster
performs
sharp
sudden
moves
roller
coaster
move
unlocked
harnesses
minimum
maximum
speeds
roller
coaster
moves
along
various
segments
ride
prevent
derailing
given
number
people
riding
roller
coaster
Identify
three
hazards
arise
system
hazard
suggest
defensive
requirement
reduce
probability
hazards
result
accident
Explain
suggested
defense
likely
reduce
risk
associated
hazard
train
protection
system
automatically
applies
brakes
train
speed
limit
segment
track
exceeded
train
enters
track
segment
currently
signaled
red
light
e
segment
entered
two
critical
safety
requirements
train
protection
system
train
shall
enter
segment
track
signaled
red
light
train
shall
exceed
specified
speed
limit
section
track
Assuming
signal
status
speed
limit
track
segment
transmitted
board
software
train
enters
track
segment
propose
five
possible
functional
system
requirements
onboard
software
generated
system
safety
requirements
Explain
cost
effective
use
formal
specification
verification
development
safety
critical
software
systems
think
critical
systems
engineers
use
formal
methods
Explain
using
model
checking
sometimes
cost
effective
approach
verification
verifying
program
s
correctness
formal
specification
List
four
types
systems
require
software
safety
cases
explaining
safety
cases
required
door
lock
control
mechanism
nuclear
waste
storage
facility
designed
safe
operation
ensures
entry
storeroom
permitted
radiation
shields
@@@@@@@@@@
Chapter
Safety
engineering
entryCode
lock
getEntryCode
entryCode
lock
authorizedCode
shieldStatus
Shield
getStatus
radiationLevel
RadSensor
get
radiationLevel
dangerLevel
state
safe
state
unsafe
shieldStatus
Shield
inPlace
state
safe
state
safe
Door
locked
false
Door
unlock
Door
lock
Door
locked
true
Figure
Door
entry
code
place
radiation
level
room
falls
given
value
dangerLevel
remotely
controlled
radiation
shields
place
room
authorized
operator
open
door
ii
radiation
level
room
specified
value
authorized
operator
open
door
iii
authorized
operator
identified
input
authorized
door
entry
code
code
shown
Figure
controls
door
locking
mechanism
Note
safe
state
entry
permitted
Using
approach
discussed
chapter
develop
safety
argument
code
Use
line
numbers
refer
specific
statements
find
code
unsafe
suggest
modified
make
safe
software
engineers
working
specification
development
safety
related
systems
professionally
certified
licensed
way
Explain
reasoning
reFerenCeS
Abrial
J
R
Modeling
Event
B
System
Software
Engineering
Cambridge
UK
Cambridge
University
Press
Ball
T
V
Levin
S
K
Rajamani
Decade
Software
Model
Checking
SLAM
Communications
ACM
July
doi
@@@@@@@@@@
Chapter
References
Behm
P
P
Benoit
Faivre
J
M
Meynadier
Meteor
Successful
Application
B
Large
Project
Formal
Methods
Berlin
Springer
Verlag
doi
Bishop
P
R
E
Bloomfield
Methodology
Safety
Case
Development
Proc
Safety
Critical
Systems
Symposium
Birmingham
UK
Springer
http
www
adelard
com
papers
sss
web
pdf
Bochot
T
P
Virelizier
H
Waeselynck
V
Wiels
Model
Checking
Flight
Control
Systems
Airbus
Experience
Proc
st
International
Conf
Software
Engineering
Companion
Volume
Leipzig
IEEE
Computer
Society
Press
doi
ICSE
COMPANION
Dehbonei
B
F
Mejia
Formal
Development
Safety
Critical
Software
Systems
Railway
Signalling
Applications
Formal
Methods
edited
M
Hinchey
J
P
Bowen
London
Prentice
Hall
Graydon
P
J
J
C
Knight
E
Strunk
Assurance
Based
Development
Critical
Systems
Proc
th
Annual
IEEE
Conf
Dependable
Systems
Networks
Edinburgh
Scotland
doi
DSN
Holzmann
G
J
Mars
Code
Comm
ACM
doi
Jhala
R
R
Majumdar
Software
Model
Checking
Computing
Surveys
doi
Kwiatkowska
M
G
Norman
D
Parker
PRISM
Verification
Probabilistic
Real
Time
Systems
Proc
rd
Int
Conf
Computer
Aided
Verification
Snowbird
UT
Springer
Verlag
doi
Leveson
N
G
S
S
Cha
T
J
Shimeall
Safety
Verification
Ada
Programs
Using
Software
Fault
Trees
IEEE
Software
doi
Lopes
R
D
Vicente
N
Silva
Static
Analysis
Tools
Practical
Approach
Safety
Critical
Software
Verification
Proceedings
DASIA
Data
Systems
Aerospace
Noordwijk
Netherlands
European
Space
Agency
Lutz
R
R
Analysing
Software
Requirements
Errors
Safety
Critical
Embedded
Systems
RE
San
Diego
CA
IEEE
doi
ISRE
Moy
Y
E
Ledinot
H
Delseny
V
Wiels
B
Monate
Testing
Formal
Verification
C
Alternatives
Industrial
Experience
IEEE
Software
doi
MS
Perrow
C
Normal
Accidents
Living
High
Risk
Technology
New
York
Basic
Books
Regan
P
S
Hamilton
NASA
s
Mission
Reliable
IEEE
Computer
doi
MC
Schneider
S
Concurrent
Real
Time
Systems
CSP
Approach
Chichester
UK
John
Wiley
Sons
@@@@@@@@@@
Chapter
Safety
engineering
Souyris
J
V
Weils
D
Delmas
H
Delseny
Formal
Verification
Avionics
Software
Products
Formal
Methods
Proceedings
nd
World
Congress
Formal
Methods
Springer
Verlag
doi
Storey
N
Safety
Critical
Computer
Systems
Harlow
UK
Addison
Wesley
Veras
P
C
E
Villani
M
Ambrosio
N
Silva
M
Vieira
H
Madeira
Errors
Space
Software
Requirements
Field
Study
Application
Scenarios
st
Int
Symp
Software
Reliability
Engineering
San
Jose
CA
doi
ISSRE
Zheng
J
L
Williams
N
Nagappan
W
Snipes
J
P
Hudepohl
M
Vouk
Value
Static
Analysis
Fault
Detection
Software
IEEE
Trans
Software
Eng
doi
TSE
@@@@@@@@@@
Security
engineering
Objectives
objective
chapter
introduce
security
issues
consider
developing
application
systems
read
chapter
understand
importance
security
engineering
difference
application
security
infrastructure
security
know
risk
based
approach
used
derive
security
requirements
analyze
system
designs
know
software
architectural
patterns
design
guidelines
secure
systems
engineering
understand
security
testing
assurance
difficult
expensive
Contents
Security
dependability
Security
organizations
Security
requirements
Secure
systems
design
Security
testing
assurance
@@@@@@@@@@
Chapter
Security
engineering
widespread
adoption
Internet
s
introduced
new
challenge
software
engineers
designing
implementing
systems
secure
systems
connected
Internet
variety
different
external
attacks
devised
threaten
systems
problems
producing
dependable
systems
hugely
increased
Systems
engineers
consider
threats
malicious
technically
skilled
attackers
well
problems
resulting
accidental
mistakes
development
process
now
essential
design
systems
withstand
external
attacks
recover
attacks
Without
security
precautions
attackers
inevitably
compromise
networked
system
misuse
system
hardware
steal
confidential
data
disrupt
services
offered
system
take
three
security
dimensions
account
secure
systems
engineering
Confidentiality
Information
system
disclosed
made
accessible
people
programs
authorized
access
information
example
theft
credit
card
data
e
commerce
system
confidentiality
problem
Integrity
Information
system
damaged
corrupted
making
unusual
unreliable
example
worm
deletes
data
system
integrity
problem
Availability
Access
system
data
normally
available
possible
denial
service
attack
overloads
server
example
situation
system
availability
compromised
dimensions
closely
related
attack
makes
system
unavailable
able
update
information
changes
time
means
integrity
system
compromised
attack
succeeds
integrity
system
compromised
taken
repair
problem
Therefore
availability
system
reduced
organizational
perspective
security
considered
three
levels
Infrastructure
security
concerned
maintaining
security
systems
networks
provide
infrastructure
set
shared
services
organization
Application
security
concerned
security
individual
application
systems
related
groups
systems
Operational
security
concerned
secure
operation
use
organization
s
systems
Figure
diagram
application
system
stack
shows
application
system
relies
infrastructure
systems
operation
lower
levels
infrastructure
hardware
software
infrastructure
application
systems
include
@@@@@@@@@@
Chapter
Security
engineering
Application
Reusable
components
libraries
Middleware
Database
management
Generic
shared
applications
browsers
email
etc
Figure
System
layers
security
compromised
Operating
System
Network
Computer
hardware
operating
system
platform
Linux
Windows
generic
applications
run
system
web
browsers
email
clients
database
management
system
middleware
supports
distributed
computing
database
access
libraries
reusable
components
used
application
software
Network
systems
software
controlled
networks
subject
security
threats
attacker
intercepts
reads
changes
network
packets
However
requires
specialized
equipment
majority
security
attacks
software
infrastructure
systems
Attackers
focus
software
infrastructures
infrastructure
components
web
browsers
universally
available
Attackers
probe
systems
weaknesses
share
information
vulnerabilities
discovered
many
people
use
software
attacks
wide
applicability
Infrastructure
security
primarily
system
management
problem
system
managers
configure
infrastructure
resist
attacks
System
security
management
includes
range
activities
user
permission
management
system
software
deployment
maintenance
attack
monitoring
detection
recovery
User
permission
management
involves
adding
removing
users
system
ensuring
appropriate
user
authentication
mechanisms
place
setting
permissions
system
users
access
resources
need
System
software
deployment
maintenance
involves
installing
system
software
middleware
configuring
properly
security
vulnerabilities
avoided
involves
updating
software
regularly
new
versions
patches
repair
security
problems
discovered
@@@@@@@@@@
Chapter
Security
engineering
Attack
monitoring
detection
recovery
involves
monitoring
system
unauthorized
access
detecting
putting
place
strategies
resisting
attacks
organizing
backups
programs
data
normal
operation
resumed
external
attack
Operational
security
primarily
human
social
issue
focuses
ensuring
people
using
system
behave
way
system
security
compromised
example
users
leave
logged
system
unattended
attacker
easily
get
access
system
Users
often
behave
insecure
way
help
jobs
effectively
good
reason
behave
insecure
way
challenge
operational
security
raise
awareness
security
issues
find
right
balance
security
system
effectiveness
term
cybersecurity
now
commonly
used
discussions
system
security
Cybersecurity
wide
ranging
term
covers
aspects
protection
citizens
businesses
critical
infrastructures
threats
arise
use
computers
Internet
scope
includes
system
levels
hardware
networks
application
systems
mobile
devices
used
access
systems
discuss
general
cybersecurity
issues
including
infrastructure
security
Chapter
covers
resilience
engineering
chapter
focus
issues
application
security
engineering
security
requirements
design
security
security
testing
don
t
cover
general
security
techniques
used
encryption
access
control
mechanisms
attack
vectors
viruses
worms
General
textbooks
computer
security
Pfleeger
Pfleeger
Anderson
Stallings
Brown
discuss
techniques
detail
Security
dependability
Security
system
attribute
reflects
ability
system
protect
malicious
internal
external
attacks
external
attacks
possible
computers
mobile
devices
networked
therefore
accessible
outsiders
Examples
attacks
installation
viruses
Trojan
horses
unauthorized
use
system
services
unauthorized
modification
system
data
really
want
system
secure
possible
best
connect
Internet
security
problems
limited
ensuring
authorized
users
abuse
system
controlling
use
devices
USB
drives
practice
however
networked
access
provides
huge
benefits
systems
disconnecting
Internet
viable
security
option
systems
security
important
system
dependability
attribute
Military
systems
systems
electronic
commerce
systems
involve
processing
interchange
confidential
information
designed
@@@@@@@@@@
Security
dependability
Term
Definition
Asset
Something
value
protected
asset
software
system
data
used
system
Attack
exploitation
system
s
vulnerability
attacker
goal
causing
damage
system
asset
assets
Attacks
outside
system
external
attacks
authorized
insiders
insider
attacks
Control
protective
measure
reduces
system
s
vulnerability
Encryption
example
control
reduces
vulnerability
weak
access
control
system
Exposure
Possible
loss
harm
computing
system
loss
damage
data
loss
time
effort
recovery
necessary
security
breach
Threat
Circumstances
potential
cause
loss
harm
think
threat
system
vulnerability
subjected
attack
Vulnerability
weakness
computer
based
system
exploited
cause
loss
harm
Figure
Security
terminology
Unauthorized
access
Mentcare
system
Clinic
staff
log
Mentcare
system
using
username
password
system
requires
passwords
least
eight
letters
long
allows
password
set
without
checking
criminal
finds
well
paid
sports
star
receiving
treatment
mental
health
problems
like
gain
illegal
access
information
system
blackmail
star
posing
concerned
relative
talking
nurses
mental
health
clinic
discovers
access
system
personal
information
nurses
families
checking
name
badges
discovers
names
people
allowed
access
attempts
log
system
using
names
systematically
guessing
possible
passwords
names
nurses
children
Figure
security
story
Mentcare
system
achieve
high
level
security
airline
reservation
system
unavailable
example
causes
inconvenience
delays
issuing
tickets
However
system
insecure
attacker
delete
bookings
practically
impossible
normal
airline
operations
continue
aspects
dependability
specialized
terminology
associated
security
Pfleeger
Pfleeger
terminology
explained
Figure
Figure
security
story
Mentcare
system
use
illustrate
terms
Figure
takes
security
concepts
defined
Figure
shows
apply
security
story
System
vulnerabilities
arise
requirements
design
implementation
problems
stem
human
social
organizational
failings
People
choose
easy
guess
passwords
write
passwords
places
found
System
administrators
make
errors
setting
access
control
configuration
files
users
don
t
install
use
protection
software
However
cannot
simply
class
problems
human
errors
User
mistakes
omissions
often
reflect
poor
systems
design
decisions
require
example
frequent
password
changes
users
write
passwords
complex
configuration
mechanisms
@@@@@@@@@@
Chapter
Security
engineering
Term
Example
Asset
record
patient
receiving
received
treatment
Figure
Examples
security
terminologyAttack
impersonation
authorized
user
Control
password
checking
system
disallows
user
passwords
proper
names
words
normally
included
dictionary
Exposure
Potential
financial
loss
future
patients
seek
treatment
trust
clinic
maintain
data
Financial
loss
legal
action
sports
star
Loss
reputation
Threat
unauthorized
user
gain
access
system
guessing
credentials
login
name
password
authorized
user
Vulnerability
Authentication
based
password
system
require
strong
passwords
Users
set
easily
guessable
passwords
Four
types
security
threats
arise
Interception
threats
allow
attacker
gain
access
asset
possible
threat
Mentcare
system
situation
attacker
gains
access
records
individual
patient
Interruption
threats
allow
attacker
make
part
system
unavailable
Therefore
possible
threat
denial
service
attack
system
database
server
Modification
threats
allow
attacker
tamper
system
asset
Mentcare
system
modification
threat
attacker
alters
destroys
patient
record
Fabrication
threats
allow
attacker
insert
false
information
system
perhaps
credible
threat
Mentcare
system
certainly
threat
banking
system
false
transactions
added
system
transfers
money
perpetrator
s
bank
account
controls
put
place
enhance
system
security
based
fundamental
notions
avoidance
detection
recovery
Vulnerability
avoidance
Controls
intended
ensure
attacks
unsuccessful
strategy
design
system
security
problems
avoided
example
sensitive
military
systems
connected
Internet
external
access
difficult
think
encryption
control
based
avoidance
unauthorized
access
encrypted
data
means
attacker
cannot
read
encrypted
data
expensive
time
consuming
crack
strong
encryption
Attack
detection
neutralization
Controls
intended
detect
repel
attacks
controls
involve
including
functionality
system
monitors
operation
checks
unusual
patterns
activity
@@@@@@@@@@
Security
dependability
attacks
detected
action
taken
shutting
parts
system
restricting
access
certain
users
Exposure
limitation
recovery
Controls
support
recovery
problems
range
automated
backup
strategies
information
mirroring
insurance
policies
cover
costs
associated
successful
attack
system
Security
closely
related
dependability
attributes
reliability
availability
safety
resilience
Security
reliability
system
attacked
system
data
corrupted
consequence
attack
induce
system
failures
compromise
reliability
system
Errors
development
system
lead
security
loopholes
system
reject
unexpected
inputs
array
bounds
checked
attackers
exploit
weaknesses
gain
access
system
example
failure
check
validity
input
mean
attacker
inject
execute
malicious
code
Security
availability
common
attack
web
based
system
denialof
service
attack
web
server
flooded
service
requests
range
different
sources
aim
attack
make
system
unavailable
variant
attack
profitable
site
threatened
type
attack
unless
ransom
paid
attackers
Security
safety
key
problem
attack
corrupts
system
data
Safety
checks
based
assumption
analyze
source
code
safety
critical
software
executing
code
completely
accurate
translation
source
code
case
attacker
changed
executing
code
safety
related
failures
induced
safety
case
made
software
invalid
Like
safety
cannot
assign
numeric
value
security
system
exhaustively
test
system
security
safety
security
thought
negative
shall
characteristics
concerned
things
happen
never
prove
negative
never
prove
system
safe
secure
Security
resilience
Resilience
covered
Chapter
system
characteristic
reflects
ability
resist
recover
damaging
events
probable
damaging
event
networked
software
systems
cyberattack
kind
work
now
done
resilience
aimed
deterring
detecting
recovering
attacks
Security
maintained
create
reliable
available
safe
software
intensive
systems
add
added
later
considered
stages
development
life
cycle
early
requirements
system
operation
@@@@@@@@@@
Chapter
Security
engineering
Security
organizations
Building
secure
systems
expensive
uncertain
impossible
predict
costs
security
failure
companies
organizations
find
difficult
judge
much
spend
system
security
respect
security
safety
different
laws
govern
workplace
operator
safety
developers
safety
critical
systems
comply
irrespective
costs
subject
legal
action
use
unsafe
system
However
unless
security
failure
discloses
personal
information
no
laws
prevent
insecure
system
deployed
Companies
assess
risks
losses
arise
certain
types
attacks
system
assets
decide
cheaper
accept
risks
rather
build
secure
system
deter
repel
external
attacks
Credit
card
companies
apply
approach
fraud
prevention
usually
possible
introduce
new
technology
reduce
credit
card
fraud
However
often
cheaper
companies
compensate
users
losses
due
fraud
buy
deploy
fraud
reduction
technology
Security
risk
management
therefore
business
rather
technical
issue
take
account
financial
reputational
losses
successful
system
attack
well
costs
security
procedures
technologies
reduce
losses
risk
management
effective
organizations
documented
information
security
policy
sets
assets
protected
necessarily
make
sense
apply
stringent
security
procedures
organizational
assets
Many
assets
confidential
company
improve
image
making
assets
freely
available
costs
maintaining
security
information
public
domain
much
less
costs
keeping
confidential
information
secure
level
protection
required
different
types
assets
assets
need
level
protection
cases
e
g
sensitive
personal
information
high
level
security
required
information
consequences
loss
minor
lower
level
security
adequate
Therefore
information
made
available
authorized
logged
user
information
much
sensitive
available
users
certain
roles
positions
responsibility
responsibilities
individual
users
managers
organization
security
policy
set
expected
users
example
use
strong
passwords
log
computers
lock
offices
defines
users
expect
company
backup
information
archiving
services
equipment
provision
Existing
security
procedures
technologies
maintained
reasons
practicality
cost
essential
continue
use
existing
approaches
security
even
known
limitations
example
@@@@@@@@@@
Security
organizations
company
require
use
login
name
password
authentication
simply
approaches
likely
rejected
users
Security
policies
often
set
general
information
access
strategies
apply
across
organization
example
access
strategy
based
clearance
seniority
person
accessing
information
Therefore
military
security
policy
state
Readers
examine
documents
classification
reader
s
vetting
level
means
reader
vetted
secret
level
access
documents
classed
secret
confidential
open
documents
classed
top
secret
point
security
policies
inform
everyone
organization
security
long
detailed
technical
documents
security
engineering
perspective
security
policy
defines
broad
terms
security
goals
organization
security
engineering
process
concerned
implementing
goals
Security
risk
assessment
Security
risk
assessment
management
organizational
activities
focus
identifying
understanding
risks
information
assets
systems
data
organization
principle
individual
risk
assessment
carried
assets
practice
however
impractical
large
number
existing
systems
databases
need
assessed
situations
generic
assessment
applied
However
individual
risk
assessments
carried
new
systems
Risk
assessment
management
organizational
activity
rather
technical
activity
part
software
development
life
cycle
reason
types
attack
technology
based
rather
rely
weaknesses
general
organizational
security
example
attacker
gain
access
equipment
pretending
accredited
engineer
organization
process
check
equipment
supplier
engineer
s
visit
planned
deter
type
attack
approach
much
simpler
trying
address
problem
using
technological
solution
new
system
developed
security
risk
assessment
management
continuing
process
throughout
development
life
cycle
initial
specification
operational
use
stages
risk
assessment
Preliminary
risk
assessment
aim
initial
risk
assessment
identify
generic
risks
applicable
system
decide
adequate
level
security
achieved
reasonable
cost
stage
decisions
detailed
system
requirements
system
design
implementation
technology
made
don
t
know
potential
technology
vulnerabilities
controls
included
reused
system
components
middleware
risk
assessment
therefore
focus
identification
analysis
high
level
risks
system
outcomes
risk
assessment
process
used
help
identify
security
requirements
@@@@@@@@@@
Chapter
Security
engineering
Design
risk
assessment
risk
assessment
takes
place
system
development
life
cycle
informed
technical
system
design
implementation
decisions
results
assessment
lead
changes
security
requirements
addition
new
requirements
Known
potential
vulnerabilities
identified
knowledge
used
inform
decision
making
system
functionality
implemented
tested
deployed
Operational
risk
assessment
risk
assessment
process
focuses
use
system
possible
risks
arise
example
system
used
environment
interruptions
common
security
risk
logged
user
leaves
computer
unattended
deal
problem
counter
risk
timeout
requirement
specified
user
automatically
logged
period
inactivity
Operational
risk
assessment
continue
system
installed
take
account
system
used
proposals
new
changed
requirements
Assumptions
operating
requirement
made
system
specified
incorrect
Organizational
changes
mean
system
used
different
ways
originally
planned
changes
lead
new
security
requirements
implemented
system
evolves
Security
requirements
specification
security
requirements
systems
much
common
specification
safety
requirements
cannot
specify
safety
security
requirements
probabilities
Like
safety
requirements
security
requirements
often
shall
requirements
define
unacceptable
system
behavior
rather
required
system
functionality
However
security
challenging
problem
safety
number
reasons
considering
safety
assume
environment
system
installed
hostile
No
one
trying
cause
safety
related
incident
considering
security
assume
attacks
system
deliberate
attacker
knowledge
system
weaknesses
system
failures
occur
pose
risk
safety
look
errors
omissions
caused
failure
deliberate
attacks
cause
system
failure
finding
root
cause
difficult
attacker
try
conceal
cause
failure
usually
acceptable
shut
system
degrade
system
services
avoid
safety
related
failure
However
attacks
system
denial
ofservice
attacks
intended
compromise
system
availability
Shutting
system
means
attack
successful
@@@@@@@@@@
Security
requirements
Safety
related
events
accidental
created
intelligent
adversary
attacker
probe
system
s
defenses
series
attacks
modifying
attacks
learns
system
responses
distinctions
mean
security
requirements
extensive
safety
requirements
Safety
requirements
lead
generation
functional
system
requirements
provide
protection
events
faults
cause
safety
related
failures
requirements
mostly
concerned
checking
problems
taking
actions
problems
occur
contrast
many
types
security
requirements
cover
different
threats
faced
system
Firesmith
Firesmith
identified
types
security
requirements
included
system
specification
Identification
requirements
specify
system
identify
users
interacting
Authentication
requirements
specify
users
identified
Authorization
requirements
specify
privileges
access
permissions
identified
users
Immunity
requirements
specify
system
protect
viruses
worms
similar
threats
Integrity
requirements
specify
data
corruption
avoided
Intrusion
detection
requirements
specify
mechanisms
used
detect
attacks
system
Nonrepudiation
requirements
specify
party
transaction
cannot
deny
involvement
transaction
Privacy
requirements
specify
data
privacy
maintained
Security
auditing
requirements
specify
system
use
audited
checked
System
maintenance
security
requirements
specify
application
prevent
authorized
changes
accidentally
defeating
security
mechanisms
course
see
types
security
requirements
every
system
particular
requirements
depend
type
system
situation
use
expected
users
Preliminary
risk
assessment
analysis
aim
identify
generic
security
risks
system
associated
data
risk
assessment
important
input
security
requirements
engineering
process
Security
requirements
proposed
support
general
risk
management
strategies
avoidance
detection
mitigation
Risk
avoidance
requirements
set
risks
avoided
designing
system
risks
simply
cannot
arise
@@@@@@@@@@
Chapter
Security
engineering
Asset
identification
Asset
value
assessment
Threat
identification
Attack
assessment
Exposure
assessment
Security
req
definition
Control
identification
Feasibility
assessment
Figure
preliminary
risk
assessment
process
security
requirements
Risk
detection
requirements
define
mechanisms
identify
risk
arises
neutralize
risk
losses
occur
Risk
mitigation
requirements
set
system
designed
recover
restore
system
assets
loss
occurred
risk
driven
security
requirements
process
shown
Figure
process
stages
Asset
identification
system
assets
require
protection
identified
system
particular
system
functions
identified
assets
well
data
associated
system
Asset
value
assessment
estimate
value
identified
assets
Exposure
assessment
assess
potential
losses
associated
asset
process
take
account
direct
losses
theft
information
costs
recovery
possible
loss
reputation
Threat
identification
identify
threats
system
assets
Attack
assessment
decompose
threat
attacks
made
system
possible
ways
attacks
occur
use
attack
trees
Schneier
analyze
possible
attacks
similar
fault
trees
Chapter
start
threat
root
tree
identify
possible
causal
attacks
made
Control
identification
propose
controls
put
place
protect
asset
controls
technical
mechanisms
encryption
use
protect
assets
Feasibility
assessment
assess
technical
feasibility
costs
proposed
controls
worth
expensive
controls
protect
assets
don
t
high
value
@@@@@@@@@@
Security
requirements
Asset
Value
Exposure
information
High
Required
support
High
Financial
loss
clinics
system
clinical
consultations
canceled
Costs
restoring
system
Potentially
safety
critical
Possible
patient
harm
treatment
cannot
prescribed
Figure
Assetanalysis
apreliminary
riskassessment
report
forthe
Mentcare
systemThe
patient
database
High
Required
support
clinical
consultations
High
Financial
loss
clinics
Potentially
safety
critical
canceled
Costs
restoring
system
Possible
patient
harm
treatment
cannot
prescribed
individual
patient
Normally
low
Low
direct
losses
possible
loss
record
high
specific
high
profile
patients
reputation
Security
requirements
definition
knowledge
exposure
threats
control
assessments
used
derive
system
security
requirements
requirements
apply
system
infrastructure
application
system
Mentcare
patient
management
system
security
critical
system
Figures
fragments
report
documents
risk
analysis
software
system
Figure
asset
analysis
describes
assets
system
value
Figure
shows
threats
system
face
preliminary
risk
assessment
completed
requirements
proposed
aim
avoid
detect
mitigate
risks
system
However
creating
requirements
formulaic
automated
process
requires
inputs
engineers
domain
experts
suggest
requirements
based
understanding
risk
analysis
functional
requirements
software
system
examples
Mentcare
system
security
requirements
associated
risks
Patient
information
shall
downloaded
start
clinic
session
database
secure
area
system
client
Risk
Damage
denial
service
attack
Maintaining
local
copies
means
access
still
possible
patient
information
system
client
shall
encrypted
Risk
External
access
patient
records
data
encrypted
attacker
access
encryption
key
discover
patient
information
Patient
information
shall
uploaded
database
clinic
session
deleted
client
computer
Risk
External
access
patience
records
stolen
laptop
log
changes
made
system
database
initiator
changes
shall
maintained
separate
computer
database
server
Risk
Insider
external
attacks
corrupt
current
data
log
allow
date
records
re
created
backup
@@@@@@@@@@
Chapter
Security
engineering
Threat
Probability
Control
Feasibility
unauthorized
user
Low
allow
system
Low
cost
implementation
care
gains
access
system
management
taken
key
distribution
manager
makes
specific
locations
ensure
keys
available
system
unavailable
physically
secure
event
emergency
unauthorized
user
gains
access
system
user
confidential
information
High
Require
users
authenticate
using
biometric
mechanism
Technically
feasible
high
cost
solution
Possible
user
resistance
Log
changes
patient
information
track
system
usage
Simple
transparent
implement
supports
recovery
Figure
Threat
control
analysis
preliminary
risk
assessment
report
first
two
requirements
related
patient
information
downloaded
local
machine
consultations
continue
patient
database
server
attacked
becomes
unavailable
However
information
deleted
later
users
client
computer
cannot
access
information
fourth
requirement
recovery
auditing
requirement
means
changes
recovered
replaying
change
log
possible
discover
made
changes
accountability
discourages
misuse
system
authorized
staff
Misuse
cases
derivation
security
requirements
risk
analysis
creative
process
involving
engineers
domain
experts
One
approach
developed
support
process
users
UML
idea
misuse
cases
Sindre
Opdahl
Misuse
cases
scenarios
represent
malicious
interactions
system
use
scenarios
discuss
identify
possible
threats
therefore
determine
system
s
security
requirements
used
alongside
use
cases
deriving
system
requirements
Chapters
Misuse
cases
associated
use
case
instances
represent
threats
attacks
associated
use
cases
included
use
case
diagram
complete
detailed
textual
description
Figure
taken
use
cases
medical
receptionist
using
Mentcare
system
added
misuse
cases
normally
represented
black
ellipses
use
cases
misuse
cases
described
several
ways
think
helpful
describe
supplement
original
use
case
description
think
best
flexible
format
misuse
cases
different
types
attack
described
different
ways
Figure
shows
original
description
Transfer
Data
use
case
Figure
addition
misuse
case
description
problem
misuse
cases
mirrors
general
problem
use
cases
interactions
end
users
system
capture
system
@@@@@@@@@@
Security
requirements
Medical
receptionist
Register
patient
Transfer
data
Contact
patient
View
patient
info
Unregister
patient
Impersonate
receptionist
Intercept
transfer
Attacker
Figure
Misuse
cases
Mentcare
system
Transfer
data
Actors
Medical
receptionist
Patient
records
system
PRS
Description
receptionist
transfer
data
Mentcare
system
general
patient
record
database
maintained
health
authority
information
transferred
updated
personal
information
address
phone
number
etc
summary
patient
s
diagnosis
treatment
Data
Patient
s
personal
information
treatment
summary
Stimulus
User
command
issued
medical
receptionist
Response
Confirmation
PRS
updated
Comments
receptionist
appropriate
security
permissions
access
patient
information
PRS
Mentcare
system
Intercept
transfer
Misuse
case
Actors
Medical
receptionist
Patient
records
system
PRS
Attacker
Description
receptionist
transfers
data
PC
Mentcare
system
server
attacker
intercepts
data
transfer
takes
copy
data
Data
assets
Patient
s
personal
information
treatment
summary
Attacks
network
monitor
added
system
packets
receptionist
server
intercepted
spoof
server
set
receptionist
database
server
receptionist
believes
interacting
real
system
Mitigations
networking
equipment
maintained
locked
room
Engineers
accessing
equipment
accredited
data
transfers
client
server
encrypted
Certificate
based
client
server
communication
used
Requirements
communications
client
server
use
Secure
Socket
Layer
SSL
https
protocol
uses
certificate
based
authentication
encryption
Figure
Misuse
case
descriptions
@@@@@@@@@@
Chapter
Security
engineering
requirements
Misuse
cases
used
part
security
requirements
engineering
process
need
consider
risks
associated
system
stakeholders
interact
directly
system
Secure
systems
design
difficult
add
security
system
implemented
Therefore
need
take
security
issues
account
systems
design
process
make
design
choices
enhance
security
system
section
focus
two
application
independent
issues
relevant
secure
systems
design
Architectural
design
architectural
design
decisions
affect
security
system
Good
practice
accepted
good
practice
designing
secure
systems
course
design
issues
important
security
Every
application
different
security
design
take
account
purpose
criticality
operational
environment
application
example
designing
military
system
need
adopt
security
classification
model
secret
top
secret
etc
designing
system
maintains
personal
information
take
account
data
protection
legislation
places
restrictions
data
managed
Using
redundancy
diversity
essential
dependability
mean
system
resist
recover
attacks
target
specific
design
implementation
characteristics
Mechanisms
support
high
level
availability
help
system
recover
denial
service
attacks
aim
attacker
bring
system
stop
working
properly
Designing
system
secure
inevitably
involves
compromises
usually
possible
design
multiple
security
measures
system
reduce
chances
successful
attack
However
security
measures
require
additional
computation
affect
overall
performance
system
example
reduce
chances
confidential
information
disclosed
encrypting
information
However
means
users
information
wait
decrypted
slow
work
tensions
security
usability
another
emergent
system
property
Security
measures
sometimes
require
user
remember
provide
additional
information
e
g
multiple
passwords
However
sometimes
users
forget
information
additional
security
means
t
use
system
System
designers
find
balance
security
performance
usability
depends
type
system
developed
expectations
users
operational
environment
example
military
system
users
familiar
high
security
systems
accept
follow
processes
require
frequent
checks
system
stock
trading
speed
essential
interruptions
operation
security
checks
completely
unacceptable
@@@@@@@@@@
Secure
systems
design
Denial
service
attacks
Denial
service
attacks
attempt
bring
networked
system
bombarding
huge
number
service
requests
usually
hundreds
attacking
systems
place
load
system
designed
exclude
legitimate
requests
system
service
Consequently
system
unavailable
crashes
heavy
load
taken
offline
system
managers
stop
flow
requests
http
software
engineering
book
com
web
denial
service
Design
risk
assessment
Security
risk
assessment
requirements
engineering
identifies
set
high
level
security
requirements
system
However
system
designed
implemented
architectural
technology
decisions
made
system
design
process
influence
security
system
decisions
generate
new
design
requirements
mean
existing
requirements
change
System
design
assessment
design
related
risks
interleaved
processes
Figure
Preliminary
design
decisions
made
risks
associated
decisions
assessed
assessment
lead
new
requirements
mitigate
risks
identified
design
changes
reduce
risks
system
design
evolves
developed
detail
risks
reassessed
results
fed
back
system
designers
design
risk
assessment
process
ends
design
complete
remaining
risks
acceptable
assessing
risks
design
implementation
information
needs
protected
know
something
vulnerabilities
system
vulnerabilities
inherent
design
choices
made
example
inherent
vulnerability
password
based
authentication
authorized
user
reveals
password
unauthorized
user
password
based
authentication
used
risk
assessment
process
suggest
new
requirements
mitigate
risk
example
requirement
multifactor
authentication
users
authenticate
using
personal
knowledge
well
password
Design
risk
assessment
System
design
Technology
choices
Design
assets
Design
requirements
changes
Architectural
design
System
requirements
Figure
Interleaved
design
risk
assessment
@@@@@@@@@@
Chapter
Security
engineering
Design
assets
Asset
value
assessment
Threat
identification
Attack
assessment
Exposure
assessment
Control
identification
Technology
architecture
choices
Design
requirements
changes
Figure
Design
risk
assessment
Available
controls
Figure
model
design
risk
assessment
process
key
difference
preliminary
risk
analysis
design
risk
assessment
design
stage
now
information
information
representation
distribution
database
organization
high
level
assets
protected
know
important
design
decisions
software
reused
infrastructure
controls
protection
forth
Based
information
assessment
identify
changes
security
requirements
system
design
provide
additional
protection
important
system
assets
Two
examples
Mentcare
system
illustrate
protection
requirements
influenced
decisions
information
representation
distribution
make
design
decision
separate
personal
patient
information
information
design
assets
treatments
received
key
linking
records
treatment
information
technical
much
less
sensitive
personal
patient
information
key
protected
attacker
able
access
routine
information
without
able
link
individual
patient
Assume
beginning
session
design
decision
made
copy
patient
records
local
client
system
allows
work
continue
server
unavailable
makes
possible
healthcare
worker
access
patient
records
laptop
even
no
network
connection
available
However
now
two
sets
records
protect
client
copies
subject
additional
risks
theft
laptop
computer
therefore
think
controls
used
reduce
risk
therefore
include
requirement
client
records
held
laptops
personal
computers
encrypted
@@@@@@@@@@
Secure
systems
design
Technology
choice
Vulnerabilities
Figure
Vulnerabilities
associated
technology
choices
Login
password
authentication
Client
server
architecture
using
web
browser
Use
editable
web
forms
Users
set
Authorized
users
reveal
guessable
passwords
passwords
unauthorized
users
Server
subject
Confidential
information
denial
service
left
browser
attack
cache
Browser
security
loopholes
lead
unauthorized
access
Fine
grain
logging
Authorization
t
changes
varied
according
user
s
impossible
role
illustrate
decisions
development
technologies
influence
security
assume
health
care
provider
decided
build
Mentcare
system
using
off
shelf
information
system
maintaining
patient
records
system
configured
type
clinic
used
decision
made
appears
offer
extensive
functionality
lowest
development
cost
fastest
deployment
time
develop
application
reusing
existing
system
accept
design
decisions
made
developers
system
Let
us
assume
design
decisions
System
users
authenticated
using
login
name
password
combination
No
authentication
method
supported
system
architecture
client
server
clients
accessing
data
standard
web
browser
client
computer
Information
presented
users
editable
web
form
change
information
place
upload
revised
information
server
generic
system
design
decisions
perfectly
acceptable
design
risk
assessment
shows
associated
vulnerabilities
Examples
possible
vulnerabilities
shown
Figure
vulnerabilities
identified
decide
steps
take
reduce
associated
risks
often
involve
making
decisions
@@@@@@@@@@
Chapter
Security
engineering
additional
system
security
requirements
operational
process
using
system
Examples
requirements
password
checker
program
shall
made
available
shall
run
daily
check
user
passwords
User
passwords
appear
system
dictionary
shall
identified
users
weak
passwords
shall
reported
system
administrators
Access
system
shall
allowed
client
computers
approved
registered
system
administrators
one
approved
web
browser
shall
installed
client
computers
off
shelf
system
used
isn
t
possible
include
password
checker
application
system
separate
system
used
Password
checkers
analyze
strength
user
passwords
set
notify
users
chosen
weak
passwords
Therefore
vulnerable
passwords
identified
reasonably
quickly
set
action
taken
ensure
users
change
password
second
third
requirements
mean
users
access
system
browser
decide
secure
browser
system
deployed
install
client
computers
Security
updates
simplified
no
need
update
different
browsers
security
vulnerabilities
discovered
fixed
process
model
shown
Figure
assumes
design
process
design
developed
fairly
detailed
level
implementation
begins
case
agile
processes
design
implementation
developed
together
code
refactored
design
developed
Frequent
delivery
system
increments
allow
time
detailed
risk
assessment
even
information
assets
technology
choices
available
issues
surrounding
security
agile
development
widely
discussed
Lane
Schoenfield
far
issue
really
resolved
people
think
fundamental
conflict
exists
security
agile
development
others
believe
conflict
resolved
using
security
focused
stories
Safecode
remains
outstanding
problem
developers
agile
methods
Meanwhile
many
security
conscious
companies
refuse
use
agile
methods
conflict
security
risk
analysis
policies
Architectural
design
Software
architecture
design
decisions
profound
effects
emergent
properties
software
system
inappropriate
architecture
used
difficult
maintain
confidentiality
integrity
information
system
guarantee
required
level
system
availability
@@@@@@@@@@
Figure
layered
protection
architecture
Secure
systems
design
Platform
level
protection
System
authentication
System
authorization
Application
level
protection
File
integrity
management
Database
login
Database
authorization
Transaction
management
Database
recovery
Record
level
protection
Patient
records
Record
access
authorization
Record
encryption
Record
integrity
management
designing
system
architecture
maintains
security
need
consider
two
fundamental
issues
Protection
system
organized
critical
assets
protected
external
attack
Distribution
system
assets
distributed
consequences
successful
attack
minimized
issues
potentially
conflicting
put
assets
one
place
build
layers
protection
around
build
single
protection
system
able
afford
strong
system
several
protection
layers
However
protection
fails
assets
compromised
Adding
several
layers
protection
affects
usability
system
mean
difficult
meet
system
usability
performance
requirements
hand
distribute
assets
expensive
protect
protection
systems
implemented
distributed
asset
Typically
cannot
afford
implement
many
protection
layers
chances
greater
protection
breached
However
happens
don
t
suffer
total
loss
possible
duplicate
distribute
information
assets
one
copy
corrupted
inaccessible
copy
used
However
information
confidential
keeping
additional
copies
increases
risk
intruder
gain
access
information
Mentcare
system
client
server
architecture
shared
central
database
used
provide
protection
system
layered
architecture
@@@@@@@@@@
Chapter
Security
engineering
critical
protected
assets
lowest
level
system
Figure
illustrates
multilevel
system
architecture
critical
assets
protected
records
individual
patients
access
modify
patient
records
attacker
penetrate
three
system
layers
Platform
level
protection
top
level
controls
access
platform
patient
record
system
runs
usually
involves
user
signing
particular
computer
platform
normally
include
support
maintaining
integrity
files
system
backups
Application
level
protection
next
protection
level
built
application
involves
user
accessing
application
authenticated
getting
authorization
take
actions
viewing
modifying
data
Application
specific
integrity
management
support
available
Record
level
protection
level
invoked
access
specific
records
required
involves
checking
user
authorized
carry
requested
operations
record
Protection
level
involve
encryption
ensure
records
cannot
browsed
using
file
browser
Integrity
checking
using
example
cryptographic
checksums
detect
changes
made
outside
normal
record
update
mechanisms
number
protection
layers
need
particular
application
depends
criticality
data
applications
need
protection
record
level
therefore
coarser
grain
access
control
commonly
used
achieve
security
allow
user
credentials
used
level
Ideally
password
based
system
application
password
different
system
password
record
level
password
However
multiple
passwords
difficult
users
remember
find
repeated
requests
authenticate
irritating
Therefore
often
compromise
security
favor
system
usability
protection
data
critical
requirement
centralized
client
server
architecture
usually
effective
security
architecture
server
responsible
protecting
sensitive
data
However
protection
compromised
losses
associated
attack
high
data
lost
damaged
Recovery
costs
high
e
g
user
credentials
reissued
Centralized
systems
vulnerable
denial
service
attacks
overload
server
make
impossible
anyone
access
system
database
consequences
server
breach
high
decide
use
alternative
distributed
architecture
application
situation
system
s
assets
distributed
across
number
different
platforms
separate
protection
mechanisms
used
platforms
attack
one
node
mean
assets
unavailable
still
possible
provide
system
services
Data
replicated
across
nodes
system
recovery
attacks
simplified
Figure
illustrates
architecture
banking
system
trading
stocks
funds
New
York
London
Frankfurt
Hong
Kong
markets
system
@@@@@@@@@@
Secure
systems
design
US
equity
data
US
trading
history
International
equity
prices
US
funds
data
US
user
accounts
International
user
accounts
New
York
trading
system
Authentication
authorization
UK
equity
data
UK
trading
history
International
equity
prices
UK
funds
data
UK
user
accounts
International
user
accounts
London
trading
system
Authentication
authorization
Euro
equity
dataEuro
trading
history
International
equity
prices
Euro
funds
data
European
user
accounts
International
user
accounts
Frankfurt
trading
system
Authentication
authorization
Asian
equity
dataHK
trading
history
International
equity
prices
Asian
funds
data
HK
user
accounts
International
user
accounts
Hong
Kong
trading
system
Authentication
authorization
Figure
Distributed
assets
equity
trading
system
distributed
data
market
maintained
separately
Assets
required
support
critical
activity
equity
trading
user
accounts
prices
replicated
available
nodes
node
system
attacked
becomes
unavailable
critical
activity
equity
trading
transferred
another
country
still
available
users
already
discussed
problem
finding
balance
security
system
performance
problem
secure
system
design
many
cases
architectural
style
best
security
requirements
best
one
meeting
performance
requirements
example
say
application
absolute
requirement
maintain
confidentiality
large
database
another
requirement
fast
access
data
high
level
protection
suggests
layers
protection
required
means
communications
system
layers
inevitable
performance
overhead
slow
access
data
alternative
architecture
used
implementing
protection
guaranteeing
confidentiality
difficult
expensive
situation
discuss
inherent
conflicts
customer
paying
system
agree
conflicts
resolved
@@@@@@@@@@
Chapter
Security
engineering
Design
guidelines
no
easy
ways
ensure
system
security
Different
types
systems
require
different
technical
measures
achieve
level
security
acceptable
system
owner
attitudes
requirements
different
groups
users
profoundly
affect
acceptable
example
bank
users
likely
accept
higher
level
security
intrusive
security
procedures
say
university
However
general
guidelines
wide
applicability
designing
system
security
solutions
guidelines
encapsulate
good
design
practice
secure
systems
engineering
General
design
guidelines
security
discussed
two
principal
uses
help
raise
awareness
security
issues
software
engineering
team
Software
engineers
often
focus
short
term
goal
getting
software
working
delivered
customers
easy
overlook
security
issues
Knowledge
guidelines
mean
security
issues
considered
software
design
decisions
made
used
review
checklist
used
system
validation
process
high
level
guidelines
discussed
specific
questions
derived
explore
security
engineered
system
Security
guidelines
sometimes
general
principles
Secure
weakest
link
system
Keep
simple
Avoid
security
obscurity
think
general
guidelines
vague
real
use
design
process
Consequently
focused
specific
design
guidelines
design
guidelines
summarized
Figure
taken
different
sources
Schneier
Viega
McGraw
Wheeler
Guideline
Base
security
decisions
explicit
security
policy
organizational
security
policy
high
level
statement
sets
fundamental
security
conditions
organization
defines
security
rather
policy
define
mechanisms
used
provide
enforce
security
principle
aspects
security
policy
reflected
system
requirements
practice
especially
agile
development
used
unlikely
happen
Designers
use
security
policy
framework
making
evaluating
design
decisions
example
say
designing
access
control
system
Mentcare
system
hospital
security
policy
state
accredited
clinical
staff
modify
electronic
patient
records
leads
requirements
check
accreditation
anyone
attempting
modify
system
reject
modifications
unaccredited
people
problem
face
many
organizations
explicit
systems
security
policy
time
changes
made
systems
response
identified
problems
no
overarching
policy
document
guide
evolution
system
situations
need
work
document
policy
examples
confirm
managers
company
@@@@@@@@@@
Secure
systems
design
Design
guidelines
security
Base
security
decisions
explicit
security
policy
Use
defense
depth
Fail
securely
Balance
security
usability
Log
user
actions
Use
redundancy
diversity
reduce
risk
Specify
format
system
inputs
Compartmentalize
assets
Design
deployment
Design
recovery
Figure
Design
guidelines
secure
systems
engineering
Guideline
Use
defense
depth
critical
system
good
design
practice
try
avoid
single
point
failure
single
failure
part
system
result
overall
systems
failure
security
terms
means
rely
single
mechanism
ensure
security
rather
employ
several
different
techniques
concept
sometimes
called
defense
depth
example
defense
depth
multifactor
authentication
example
use
password
authenticate
users
system
include
challenge
response
authentication
mechanism
users
pre
register
questions
answers
system
input
login
credentials
answer
questions
correctly
allowed
access
Guideline
Fail
securely
System
failures
inevitable
systems
way
safety
critical
systems
fail
safe
security
critical
systems
fail
secure
system
fails
use
fallback
procedures
less
secure
system
system
failure
mean
attacker
access
data
normally
allowed
example
Mentcare
system
suggested
requirement
patient
data
downloaded
system
client
beginning
clinic
session
speeds
access
means
access
possible
server
unavailable
Normally
server
deletes
data
end
clinic
session
However
server
failed
possible
information
client
maintained
fail
secure
approach
circumstances
encrypt
patient
data
stored
client
means
unauthorized
user
cannot
read
data
Guideline
Balance
security
usability
demands
security
usability
often
contradictory
make
system
secure
introduce
checks
users
authorized
use
system
@@@@@@@@@@
Chapter
Security
engineering
acting
accordance
security
policies
inevitably
make
demands
users
remember
login
names
passwords
use
system
certain
computers
mean
takes
users
time
get
started
system
use
effectively
add
security
features
system
usually
becomes
difficult
use
recommend
Cranor
Garfinkel
s
book
Cranor
Garfinkel
discusses
wide
range
issues
general
area
security
usability
comes
point
counterproductive
keep
adding
new
security
features
expense
usability
example
require
users
input
multiple
passwords
change
passwords
impossible
remember
character
strings
frequent
intervals
simply
write
passwords
attacker
especially
insider
able
find
passwords
written
gain
access
system
Guideline
Log
user
actions
practically
possible
maintain
log
user
actions
log
least
record
assets
used
time
date
action
maintain
list
executable
commands
replay
log
recover
failures
need
tools
allow
analyze
log
detect
potentially
anomalous
actions
tools
scan
log
find
anomalous
actions
thus
help
detect
attacks
trace
attacker
gained
access
system
Apart
helping
recover
failure
log
user
actions
useful
acts
deterrent
insider
attacks
people
know
actions
logged
less
likely
unauthorized
things
effective
casual
attacks
nurse
looking
patient
records
neighbors
detecting
attacks
legitimate
user
credentials
stolen
social
engineering
course
approach
foolproof
technically
skilled
insiders
able
access
change
log
Guideline
Use
redundancy
diversity
reduce
risk
Redundancy
means
maintain
one
version
software
data
system
Diversity
applied
software
means
different
versions
rely
platform
implemented
using
technologies
Therefore
platform
technology
vulnerabilities
affect
versions
lead
common
failure
already
discussed
examples
redundancy
maintaining
patient
information
server
client
first
Mentcare
system
distributed
equity
trading
system
shown
Figure
patient
records
system
use
diverse
operating
systems
client
server
e
g
Linux
server
Windows
client
ensures
attack
based
operating
system
vulnerability
affect
server
client
course
running
multiple
operating
systems
leads
higher
systems
management
costs
trade
off
security
benefits
increased
cost
@@@@@@@@@@
Secure
systems
design
Guideline
Specify
format
system
inputs
common
attack
system
involves
providing
system
unexpected
inputs
cause
behave
unanticipated
way
inputs
simply
cause
system
crash
resulting
loss
service
inputs
made
malicious
code
executed
system
Buffer
overflow
vulnerabilities
first
demonstrated
Internet
worm
Spafford
commonly
used
attackers
triggered
using
long
input
strings
called
SQL
poisoning
malicious
user
inputs
SQL
fragment
interpreted
server
another
fairly
common
attack
avoid
many
problems
specify
format
structure
system
inputs
expected
specification
based
knowledge
expected
system
inputs
example
surname
input
specify
characters
alphabetic
no
numbers
punctuation
apart
hyphen
allowed
limit
length
name
example
no
one
family
name
characters
no
addresses
characters
long
numeric
value
expected
no
alphabetic
characters
allowed
information
used
input
checks
system
implemented
Guideline
Compartmentalize
assets
Compartmentalizing
means
provide
users
access
information
system
Based
general
need
know
security
principle
organize
information
system
compartments
Users
access
information
need
work
rather
information
system
means
effects
attack
compromises
individual
user
account
contained
information
lost
damaged
unlikely
information
system
affected
example
Mentcare
system
designed
clinic
staff
normally
access
records
patients
appointment
clinic
normally
access
patient
records
system
limit
potential
loss
insider
attacks
means
intruder
steals
credentials
cannot
damage
patient
records
said
mechanisms
system
grant
unexpected
access
say
patient
seriously
ill
requires
urgent
treatment
without
appointment
circumstances
use
alternative
secure
mechanism
override
compartmentalization
system
situations
security
relaxed
maintain
system
availability
essential
use
logging
mechanism
record
system
usage
check
logs
trace
unauthorized
use
Guideline
Design
deployment
Many
security
problems
arise
system
configured
correctly
deployed
operational
environment
Deployment
means
installing
software
@@@@@@@@@@
Chapter
Security
engineering
computers
execute
setting
software
parameters
reflect
execution
environment
preferences
system
user
Mistakes
forgetting
turn
off
debugging
facilities
forgetting
change
default
administration
password
introduce
vulnerabilities
system
Good
management
practice
avoid
many
security
problems
arise
configuration
deployment
mistakes
However
software
designers
responsibility
design
deployment
provide
support
deployment
reduces
chances
users
system
administrators
making
mistakes
configuring
software
recommend
four
ways
incorporate
deployment
support
system
Include
support
viewing
analyzing
configurations
include
facilities
system
allow
administrators
permitted
users
examine
current
configuration
system
Minimize
default
privileges
design
software
default
configuration
system
provides
minimum
essential
privileges
Localize
configuration
settings
designing
system
configuration
support
ensure
everything
configuration
affects
part
system
set
place
Provide
easy
ways
fix
security
vulnerabilities
include
straightforward
mechanisms
updating
system
repair
security
vulnerabilities
discovered
Deployment
issues
less
problem
used
software
require
client
installation
Rather
software
runs
service
accessed
web
browser
However
server
software
still
vulnerable
deployment
errors
omissions
types
system
require
dedicated
software
running
user
s
computer
Guideline
Design
recovery
Irrespective
much
effort
put
maintaining
systems
security
design
system
assumption
security
failure
occur
Therefore
think
recover
possible
failures
restore
system
secure
operational
state
example
include
backup
authentication
system
case
password
authentication
compromised
example
say
unauthorized
person
outside
clinic
gains
access
Mentcare
system
don
t
know
person
obtained
valid
login
password
combination
need
re
initialize
authentication
system
change
credentials
used
intruder
essential
intruder
gained
access
user
passwords
need
therefore
ensure
authorized
users
change
passwords
ensure
unauthorized
person
access
password
changing
mechanism
@@@@@@@@@@
Secure
systems
design
therefore
design
system
deny
access
everyone
changed
password
email
users
asking
make
change
need
alternative
mechanism
authenticate
real
users
password
change
assuming
chosen
passwords
secure
One
way
use
challenge
response
mechanism
users
answer
questions
pre
registered
answers
invoked
passwords
changed
allowing
recovery
attack
relatively
little
user
disruption
Designing
recoverability
essential
element
building
resilience
systems
cover
topic
detail
Chapter
Secure
systems
programming
Secure
system
design
means
designing
security
application
system
However
well
focusing
security
design
level
important
consider
security
programming
software
system
Many
successful
attacks
software
rely
program
vulnerabilities
introduced
program
developed
first
widely
known
attack
Internet
based
systems
happened
worm
introduced
Unix
systems
across
network
Spafford
took
advantage
well
known
programming
vulnerability
systems
programmed
C
no
automatic
array
bound
checking
attacker
include
long
string
program
commands
input
overwrites
program
stack
cause
control
transferred
malicious
code
vulnerability
exploited
many
systems
programmed
C
C
since
example
illustrates
two
important
aspects
secure
systems
programming
Vulnerabilities
often
language
specific
Array
bound
checking
automatic
languages
Java
vulnerability
exploited
Java
programs
However
millions
programs
written
C
C
allow
development
efficient
software
Thus
simply
avoiding
use
languages
realistic
option
Security
vulnerabilities
closely
related
program
reliability
example
caused
program
concerned
crash
actions
taken
improve
program
reliability
improve
system
security
Chapter
introduced
programming
guidelines
dependable
system
programming
shown
Figure
guidelines
help
improve
security
program
attackers
focus
program
vulnerabilities
gain
access
system
example
SQL
poisoning
attack
based
attacker
filling
form
SQL
commands
rather
text
expected
system
corrupt
database
release
confidential
information
completely
avoid
problem
implement
input
checks
Guideline
based
expected
format
structure
inputs
@@@@@@@@@@
Chapter
Security
engineering
Figure
Dependable
programming
guidelines
Dependable
programming
guidelines
Limit
visibility
information
program
Check
inputs
validity
Provide
handler
exceptions
Minimize
use
error
prone
constructs
Provide
restart
capabilities
Check
array
bounds
Include
timeouts
calling
external
components
Name
constants
represent
real
world
values
Security
testing
assurance
assessment
system
security
increasingly
important
confident
systems
use
secure
verification
validation
processes
web
based
systems
therefore
focus
security
assessment
ability
system
resist
different
types
attack
tested
However
Anderson
explains
Anderson
type
security
assessment
difficult
carry
Consequently
systems
often
deployed
security
loopholes
Attackers
use
vulnerabilities
gain
access
system
cause
damage
system
data
Fundamentally
security
testing
difficult
two
reasons
Security
requirements
like
safety
requirements
shall
requirements
specify
happen
rather
system
functionality
required
behavior
usually
possible
define
unwanted
behavior
simple
constraints
checked
system
resources
available
demonstrate
principle
least
system
meets
functional
requirements
However
impossible
prove
system
something
Irrespective
amount
testing
security
vulnerabilities
remain
system
deployed
course
generate
functional
requirements
designed
guard
system
known
types
attack
However
cannot
derive
requirements
unknown
unanticipated
types
attack
Even
systems
use
many
years
ingenious
attacker
discover
new
attack
penetrate
thought
secure
system
people
attacking
system
intelligent
actively
looking
vulnerabilities
exploit
willing
experiment
system
try
things
far
outside
normal
activity
system
use
example
surname
field
enter
characters
mixture
letters
punctuation
numbers
simply
see
system
responds
find
vulnerability
publicize
increase
number
possible
attackers
Internet
forums
set
exchange
information
system
vulnerabilities
thriving
market
malware
@@@@@@@@@@
Security
testing
assurance
Security
checklist
files
created
application
appropriate
access
permissions
wrong
access
permissions
lead
files
accessed
unauthorized
users
system
automatically
terminate
user
sessions
period
inactivity
Sessions
left
active
allow
unauthorized
access
unattended
computer
system
written
programming
language
without
array
bound
checking
situations
buffer
overflow
exploited
Buffer
overflow
allow
attackers
send
code
strings
system
execute
passwords
set
system
check
passwords
strong
Strong
passwords
consist
mixed
letters
numbers
punctuation
normal
dictionary
entries
difficult
break
simple
passwords
inputs
system
s
environment
checked
input
specification
Incorrect
processing
badly
formed
inputs
common
cause
security
vulnerabilities
Figure
Examples
attackers
get
access
kits
help
easily
develop
malware
entries
security
worms
keystroke
loggers
checklist
Attackers
try
discover
assumptions
made
system
developers
challenge
assumptions
see
happens
position
use
explore
system
period
time
analyze
using
software
tools
discover
vulnerabilities
able
exploit
fact
time
spend
looking
vulnerabilities
system
test
engineers
testers
focus
testing
system
use
combination
testing
tool
based
analysis
formal
verification
check
analyze
security
application
system
Experience
based
testing
case
system
analyzed
types
attack
known
validation
team
involve
developing
test
cases
examining
source
code
system
example
check
system
susceptible
well
known
SQL
poisoning
attack
test
system
using
inputs
include
SQL
commands
check
buffer
overflow
errors
occur
examine
input
buffers
see
program
checking
assignments
buffer
elements
bounds
Checklists
known
security
problems
created
assist
process
Figure
gives
examples
questions
used
drive
experience
based
testing
Checks
design
programming
guidelines
security
followed
included
security
problem
checklist
Penetration
testing
form
experience
based
testing
possible
draw
experience
outside
development
team
test
application
system
penetration
testing
teams
given
objective
breaching
system
security
simulate
attacks
system
use
ingenuity
discover
new
ways
compromise
system
security
Penetration
testing
team
@@@@@@@@@@
Chapter
Security
engineering
members
previous
experience
security
testing
finding
security
weaknesses
systems
Tool
based
analysis
approach
security
tools
password
checkers
used
analyze
system
Password
checkers
detect
insecure
passwords
common
names
strings
consecutive
letters
approach
really
extension
experience
based
validation
experience
security
flaws
embodied
tools
used
Static
analysis
course
another
type
tool
based
analysis
increasingly
used
Tool
based
static
analysis
Chapter
particularly
useful
approach
security
checking
static
analysis
program
quickly
guide
testing
team
areas
program
include
errors
vulnerabilities
Anomalies
revealed
static
analysis
directly
fixed
help
identify
tests
need
done
reveal
anomalies
represent
risk
system
Microsoft
uses
static
analysis
routinely
check
software
possible
security
vulnerabilities
Jenney
Hewlett
Packard
offers
tool
called
Fortify
Hewlett
Packard
specifically
designed
checking
Java
programs
security
vulnerabilities
Formal
verification
discussed
use
formal
program
verification
Chapters
Essentially
involves
making
formal
mathematical
arguments
demonstrate
program
conforms
specification
Hall
Chapman
Hall
Chapman
demonstrated
feasibility
proving
system
met
formal
security
requirements
years
ago
number
experiments
since
However
areas
formal
verification
security
widely
used
requires
specialist
expertise
unlikely
cost
effective
static
analysis
Security
testing
takes
long
time
usually
time
available
testing
team
limited
means
adopt
risk
based
approach
security
testing
focus
think
significant
risks
faced
system
analysis
security
risks
system
used
drive
testing
process
well
testing
system
security
requirements
derived
risks
test
team
try
break
system
adopting
alternative
approaches
threaten
system
assets
Key
Points
Security
engineering
focuses
develop
maintain
software
systems
resist
malicious
attacks
intended
damage
computer
based
system
data
Security
threats
threats
confidentiality
integrity
availability
system
data
@@@@@@@@@@
Chapter
Website
Security
risk
management
involves
assessing
losses
ensue
attacks
system
deriving
security
requirements
aimed
eliminating
reducing
losses
specify
security
requirements
identify
assets
protected
define
security
techniques
technology
used
protect
assets
Key
issues
designing
secure
systems
architecture
include
organizing
system
structure
protect
key
assets
distributing
system
assets
minimize
losses
successful
attack
Security
design
guidelines
sensitize
system
designers
security
issues
considered
provide
basis
creating
security
review
checklists
Security
validation
difficult
security
requirements
state
happen
system
rather
Furthermore
system
attackers
intelligent
time
probe
weaknesses
available
security
testing
reading
Security
Engineering
Guide
Building
Dependable
Distributed
Systems
nd
ed
thorough
comprehensive
discussion
problems
building
secure
systems
focus
systems
rather
software
engineering
extensive
coverage
hardware
networking
excellent
examples
drawn
real
system
failures
R
Anderson
John
Wiley
Sons
http
www
cl
cam
ac
uk
rja
book
html
Deadly
Sins
Software
Security
Programming
Flaws
Fix
think
one
best
practical
books
secure
systems
programming
authors
discuss
common
programming
vulnerabilities
describe
avoided
practice
M
Howard
D
LeBlanc
J
Viega
McGraw
Hill
Computer
Security
Principles
Practice
good
general
text
computer
security
issues
covers
security
technology
trusted
systems
security
management
cryptography
W
Stallings
L
Brown
Addison
Wesley
WebSite
PowerPoint
slides
chapter
www
pearsonglobaleditions
com
Sommerville
Links
supporting
videos
http
software
engineering
book
com
videos
security
resilience
@@@@@@@@@@
Chapter
Security
engineering
exerCiSeS
Describe
security
dimensions
security
levels
considered
secure
systems
engineering
Mentcare
system
suggest
example
asset
exposure
vulnerability
attack
threat
control
addition
discussed
chapter
Explain
security
considered
challenging
problem
safety
system
Extend
table
Figure
identify
two
threats
Mentcare
system
along
associated
controls
Use
basis
generating
software
security
requirements
implement
proposed
controls
Explain
using
analogy
drawn
non
software
engineering
context
layered
approach
asset
protection
used
Explain
important
log
user
actions
development
secure
systems
equity
trading
system
discussed
Section
architecture
shown
Figure
suggest
two
plausible
attacks
system
propose
possible
strategies
counter
attacks
Explain
important
writing
secure
systems
validate
user
inputs
check
expected
format
Suggest
go
validating
password
protection
system
application
developed
Explain
function
tools
think
useful
Mentcare
system
secure
attacks
reveal
confidential
patient
information
Suggest
three
possible
attacks
system
occur
Using
information
extend
checklist
Figure
guide
testers
Mentcare
system
reFerenCeS
Anderson
R
Security
Engineering
nd
ed
Chichester
UK
John
Wiley
Sons
Cranor
L
S
Garfinkel
Designing
Secure
Systems
People
Use
Sebastopol
CA
O
Reilly
Media
Inc
Firesmith
D
G
Engineering
Security
Requirements
Journal
Object
Technology
http
www
jot
fm
issues
issue
column
Hall
R
Chapman
Correctness
Construction
Developing
Commercially
Secure
System
IEEE
Software
doi
Hewlett
Packard
Securing
Enterprise
Software
Hp
Fortify
Code
Analyzer
http
h
www
hp
com
V
GetDocument
aspx
docname
AA
ENW
cc
us
lc
en
@@@@@@@@@@
Chapter
References
Jenney
P
Static
Analysis
Strategies
Success
Code
Scanning
http
msdn
microsoft
com
en
us
security
gg
aspx
Lane
Agile
Development
Security
https
securosis
com
blog
agile
developmentand
security
Pfleeger
C
P
S
L
Pfleeger
Security
Computing
th
ed
Boston
Addison
Wesley
Safecode
Practical
Security
Stories
Security
Tasks
Agile
Development
Environments
http
www
safecode
org
publications
SAFECode
Agile
Dev
Security
pdf
Schneier
B
Attack
Trees
Dr
Dobbs
Journal
https
www
schneier
com
paper
attacktrees
ddj
ft
html
Secrets
Lies
Digital
Security
Networked
World
New
York
John
Wiley
Sons
Schoenfield
B
Agile
Security
Enemies
Life
http
brookschoenfield
com
p
Sindre
G
L
Opdahl
Eliciting
Security
Requirements
Misuse
Cases
Requirements
Engineering
doi
s
Spafford
E
Internet
Worm
Crisis
Aftermath
Comm
ACM
doi
Stallings
W
L
Brown
Computer
Security
Principles
d
Practice
nd
ed
Boston
Addison
Wesley
Viega
J
G
McGraw
Building
Secure
Software
Boston
Addison
Wesley
Wheeler
D
Secure
Programming
Linux
Unix
Self
published
http
www
dwheeler
com
secure
programs
@@@@@@@@@@
Resilience
engineering
Objectives
objective
chapter
introduce
idea
resilience
engineering
systems
designed
withstand
adverse
external
events
operator
errors
cyberattacks
read
chapter
understand
differences
resilience
reliability
security
resilience
important
networked
systems
aware
fundamental
issues
building
resilient
systems
namely
recognition
problems
resistance
failures
attacks
recovery
critical
services
system
reinstatement
understand
resilience
sociotechnical
rather
technical
issue
role
system
operators
managers
providing
resilience
introduced
system
design
method
supports
resilience
Contents
Cybersecurity
Sociotechnical
resilience
Resilient
systems
design
@@@@@@@@@@
Chapter
Resilience
engineering
April
Apollo
manned
mission
moon
suffered
catastrophic
failure
oxygen
tank
exploded
space
resulting
serious
loss
atmospheric
oxygen
oxygen
fuel
cells
powered
spacecraft
situation
life
threatening
no
possibility
rescue
no
contingency
plans
situation
However
using
equipment
unintended
ways
adapting
standard
procedures
combined
efforts
spacecraft
crew
ground
staff
worked
around
problems
spacecraft
brought
back
earth
safely
crew
survived
overall
system
people
equipment
processes
resilient
adapted
cope
recover
failure
introduced
idea
resilience
Chapter
one
fundamental
attributes
system
dependability
defined
resilience
Chapter
resilience
system
judgment
well
system
maintain
continuity
critical
services
presence
disruptive
events
equipment
failure
cyberattacks
standard
definition
resilience
different
authors
Laprie
Laprie
Hollnagel
Hollnagel
propose
general
definitions
based
ability
system
withstand
change
resilient
system
one
operate
successfully
fundamental
assumptions
made
system
designers
no
longer
hold
example
initial
design
assumption
users
make
mistakes
deliberately
seek
system
vulnerabilities
exploited
system
used
environment
subject
cyberattacks
no
longer
true
resilient
system
cope
environmental
change
continue
operate
successfully
definitions
general
definition
resilience
closer
term
now
used
practice
governments
industry
embeds
three
essential
ideas
idea
services
offered
system
critical
services
failure
serious
human
social
economic
effects
idea
events
disruptive
affect
ability
system
deliver
critical
services
idea
resilience
judgment
no
resilience
metrics
resilience
cannot
measured
resilience
system
assessed
experts
examine
system
operational
processes
Fundamental
work
system
resilience
started
safety
critical
systems
community
aim
understand
factors
led
accidents
avoided
survived
However
increasing
number
cyberattacks
networked
systems
meant
resilience
now
often
seen
security
issue
essential
build
systems
withstand
malicious
cyberattacks
continue
deliver
services
users
@@@@@@@@@@
Obviously
resilience
engineering
closely
related
reliability
security
engineering
aim
reliability
engineering
ensure
systems
fail
system
failure
externally
observable
event
often
consequence
fault
system
Therefore
techniques
fault
avoidance
fault
tolerance
discussed
Chapter
developed
reduce
number
system
faults
trap
faults
lead
system
failure
spite
best
efforts
faults
present
large
complex
system
lead
system
failure
Delivery
schedules
short
testing
budgets
limited
Development
teams
working
pressure
practically
impossible
detect
faults
security
vulnerabilities
software
system
building
systems
complex
see
Chapter
cannot
possibly
understand
interactions
system
components
interactions
trigger
overall
system
failure
Resilience
engineering
focus
avoiding
failure
rather
accepting
reality
failures
occur
makes
two
important
assumptions
Resilience
engineering
assumes
impossible
avoid
system
failures
concerned
limiting
costs
failures
recovering
Resilience
engineering
assumes
good
reliability
engineering
practices
used
minimize
number
technical
faults
system
therefore
places
emphasis
limiting
number
system
failures
arise
external
events
operator
errors
cyberattacks
practice
technical
system
failures
often
triggered
events
external
system
events
involve
operator
actions
user
errors
unexpected
last
years
however
number
networked
systems
increased
events
often
cyberattacks
cyberattack
malicious
person
group
tries
damage
system
steal
confidential
information
now
significant
user
operator
errors
potential
source
system
failure
assumption
failures
inevitably
occur
resilience
engineering
concerned
immediate
recovery
failure
maintain
critical
services
longer
term
reinstatement
system
services
discuss
Section
means
system
designers
include
system
features
maintain
state
system
s
software
data
event
failure
essential
information
restored
Four
related
resilience
activities
involved
detection
recovery
system
problems
Recognition
system
operators
able
recognize
symptoms
problem
lead
system
failure
Ideally
recognition
possible
failure
occurs
Resistance
symptoms
problem
signs
cyberattack
detected
early
resistance
strategies
invoked
reduce
probability
system
fail
resistance
strategies
focus
isolating
critical
parts
system
unaffected
problems
elsewhere
Resistance
includes
@@@@@@@@@@
Chapter
Resilience
engineering
Recognition
Resistance
Recovery
Reinstatement
Normal
operating
state
Attack
recognition
Critical
service
delivery
Critical
service
delivery
Attack
resistance
System
repair
Software
data
restoration
Restricted
service
delivery
Attack
detected
Attack
successful
Repair
complete
Attack
repelled
Figure
Resilience
activities
Reinstatement
complete
proactive
resistance
defenses
included
system
trap
problems
reactive
resistance
actions
taken
problem
discovered
Recovery
failure
occurs
aim
recovery
activity
ensure
critical
system
services
restored
quickly
system
users
seriously
affected
failure
Reinstatement
final
activity
system
services
restored
normal
system
operation
continue
activities
lead
changes
system
state
shown
Figure
shows
state
changes
system
event
cyberattack
parallel
normal
system
operation
system
monitors
network
traffic
possible
cyberattacks
event
cyberattack
system
moves
resistance
state
normal
services
restricted
resistance
successfully
repels
attack
normal
service
resumed
Otherwise
system
moves
recovery
state
critical
services
available
Repairs
damage
caused
cyberattack
carried
Finally
repairs
complete
system
moves
reinstatement
state
state
system
s
services
incrementally
restored
Finally
restoration
complete
normal
service
resumed
Apollo
example
illustrates
resilience
cannot
programmed
system
impossible
anticipate
everything
go
wrong
every
context
problems
arise
key
resilience
therefore
flexibility
adaptability
discuss
Section
possible
system
operators
managers
take
actions
protect
repair
system
even
actions
abnormal
normally
disallowed
Increasing
resilience
system
course
significant
costs
Software
purchased
modified
additional
investments
made
hardware
cloud
services
provide
backup
systems
used
event
system
failure
benefits
costs
impossible
calculate
losses
failure
attack
calculated
event
Companies
therefore
reluctant
invest
resilience
never
suffered
serious
attack
associated
loss
However
increasing
number
@@@@@@@@@@
high
profile
cyberattacks
damaged
business
government
systems
increased
awareness
need
resilience
clear
losses
significant
sometimes
businesses
survive
successful
cyberattack
Therefore
increasing
investment
resilience
engineering
reduce
business
risks
associated
system
failure
Cybersecurity
Maintaining
security
networked
infrastructure
government
business
personal
computer
systems
one
significant
problems
facing
society
ubiquity
Internet
dependence
computer
systems
created
new
criminal
opportunities
theft
social
disruption
difficult
measure
losses
due
cybercrime
However
estimated
losses
global
economy
due
cybercrime
billion
billion
InfoSecurity
suggested
Chapter
cybersecurity
broader
issue
system
security
engineering
Software
security
engineering
primarily
technical
activity
focuses
techniques
technologies
ensure
application
systems
secure
Cybersecurity
sociotechnical
concern
covers
aspects
ensuring
protection
citizens
businesses
critical
infrastructures
threats
arise
use
computers
Internet
technical
issues
important
technology
cannot
guarantee
security
Factors
contribute
cybersecurity
failures
include
organizational
ignorance
seriousness
problem
poor
design
lax
application
security
procedures
human
carelessness
inappropriate
trade
offs
usability
security
Cybersecurity
concerned
organization
s
assets
networks
application
systems
vast
majority
assets
externally
procured
companies
understand
detailed
operation
Systems
web
browsers
large
complex
programs
inevitably
contain
bugs
source
vulnerability
different
systems
organization
related
many
different
ways
stored
disk
share
data
rely
common
operating
systems
components
organizational
system
systems
incredibly
complex
impossible
ensure
free
security
vulnerabilities
Consequently
generally
assume
systems
vulnerable
cyberattack
stage
cyberattack
likely
occur
successful
cyberattack
serious
financial
consequences
businesses
essential
attacks
contained
losses
minimized
Effective
resilience
engineering
organizational
systems
levels
repel
attacks
bring
systems
back
operation
quickly
limit
losses
incurred
@@@@@@@@@@
Cybersecurity
Chapter
discussed
security
engineering
introduced
concepts
fundamental
resilience
planning
concepts
Assets
systems
data
protected
assets
valuable
others
require
higher
level
protection
Threats
circumstances
cause
harm
damaging
stealing
organizational
infrastructure
system
assets
Attacks
manifestations
threat
attacker
aims
damage
steal
assets
websites
personal
data
Three
types
threats
considered
resilience
planning
Threats
confidentiality
assets
case
data
damaged
made
available
people
access
example
threat
confidentiality
credit
card
database
held
company
stolen
potential
illegal
use
card
information
Threats
integrity
assets
threats
systems
data
damaged
way
cyberattack
involve
introducing
virus
worm
software
corrupting
organizational
databases
Threats
availability
assets
threats
aim
deny
use
assets
authorized
users
best
known
example
denial
service
attack
aims
take
website
make
unavailable
external
use
independent
threat
classes
attacker
compromise
integrity
user
s
system
introducing
malware
botnet
component
invoked
remotely
part
distributed
denial
service
attack
another
system
types
malware
used
capture
personal
details
allow
confidential
assets
accessed
counter
threats
organizations
put
controls
place
make
difficult
attackers
access
damage
assets
important
raise
awareness
cybersecurity
issues
people
know
controls
important
less
likely
reveal
information
attacker
Examples
controls
used
Authentication
users
system
show
authorized
access
system
familiar
login
password
approach
authentication
universally
used
rather
weak
control
Encryption
data
algorithmically
scrambled
unauthorized
reader
cannot
access
information
Many
companies
now
require
laptop
disks
encrypted
computer
lost
stolen
reduces
likelihood
confidentiality
information
breached
Firewalls
incoming
network
packets
examined
accepted
rejected
according
set
organizational
rules
Firewalls
used
@@@@@@@@@@
ensure
traffic
trusted
sources
allowed
pass
external
Internet
local
organizational
network
set
controls
organization
provides
layered
protection
system
attacker
get
protection
layers
attack
succeed
However
trade
off
protection
efficiency
number
layers
protection
increases
system
slows
protection
systems
consume
increasing
amount
memory
processor
resources
leaving
less
available
useful
work
security
inconvenient
users
likely
adopt
insecure
practices
increase
system
usability
aspects
system
dependability
fundamental
means
protecting
cyberattacks
depends
redundancy
diversity
Recall
redundancy
means
spare
capacity
duplicated
resources
system
Diversity
means
different
types
equipment
software
procedures
used
common
failures
less
likely
occur
across
number
systems
Examples
redundancy
diversity
valuable
cyber
resilience
system
copies
data
software
maintained
separate
computer
systems
Shared
disks
avoided
possible
supports
recovery
successful
cyberattack
recovery
reinstatement
Multi
stage
diverse
authentication
protect
password
attacks
well
login
password
authentication
additional
authentication
steps
involved
require
users
provide
personal
information
code
generated
mobile
device
resistance
Critical
servers
overprovisioned
powerful
required
handle
expected
load
spare
capacity
means
attacks
resisted
without
necessarily
degrading
normal
response
server
Furthermore
servers
damaged
spare
capacity
available
run
software
repaired
resistance
recovery
Planning
cybersecurity
based
assets
controls
Rs
resilience
engineering
recognition
resistance
recovery
reinstatement
Figure
shows
planning
process
followed
key
stages
process
Asset
classification
organization
s
hardware
software
human
assets
examined
classified
depending
essential
normal
operations
classed
critical
important
useful
Threat
identification
assets
least
critical
important
assets
identify
classify
threats
asset
cases
try
estimate
probability
threat
arise
estimates
often
inaccurate
don
t
enough
information
potential
attackers
Threat
recognition
threat
sometimes
asset
threat
pair
identify
attack
based
threat
recognized
@@@@@@@@@@
Cybersecurity
Threat
recognitionInterface
development
Integration
deployment
Asset
classification
Threat
identification
Threat
resistance
Interface
development
Integration
deployment
Asset
recovery
Asset
reinstatement
Cyber
resilience
plan
Figure
Cyber
decide
additional
software
needs
bought
written
threat
recogni
resilience
planning
tion
regular
checking
procedures
put
place
Threat
resistance
threat
asset
threat
pair
identify
possible
resistance
strategies
embedded
system
technical
strategies
rely
operational
procedures
need
think
threat
neutralization
strategies
threat
recur
Asset
recovery
critical
asset
asset
threat
pair
work
asset
recovered
event
successful
cyberattack
involve
making
extra
hardware
available
changing
backup
procedures
make
easier
access
redundant
copies
data
Asset
reinstatement
general
process
asset
recovery
define
procedures
bring
system
back
normal
operation
Asset
reinstatement
concerned
assets
simply
assets
critical
organization
Information
stages
maintained
cyber
resilience
plan
plan
regularly
updated
possible
strategies
identified
tested
mock
attacks
system
Another
important
part
cyber
resilience
planning
decide
support
flexible
response
event
cyberattack
Paradoxically
resilience
security
requirements
often
conflict
aim
security
usually
limit
privilege
far
possible
users
security
policy
organization
allows
However
deal
problems
user
system
operator
take
initiative
take
actions
normally
carried
someone
higher
level
privilege
example
system
manager
medical
system
normally
allowed
change
access
rights
medical
staff
records
security
reasons
access
permissions
formally
authorized
two
people
need
involved
making
change
reduces
chances
system
managers
colluding
attackers
allowing
access
confidential
medical
information
Now
imagine
system
manager
notices
logged
user
accessing
large
number
records
outside
normal
working
hours
manager
suspects
@@@@@@@@@@
account
compromised
user
accessing
records
authorized
user
limit
damage
user
s
access
rights
removed
check
made
authorized
user
see
accesses
illegal
However
security
procedures
limiting
rights
system
managers
change
users
permissions
make
impossible
Resilience
planning
take
situations
account
One
way
include
emergency
mode
systems
normal
checks
ignored
Rather
forbidding
operations
system
logs
done
responsible
Therefore
audit
trail
emergency
actions
used
check
system
manager
s
actions
justified
course
scope
misuse
existence
emergency
mode
potential
vulnerability
Therefore
organizations
trade
off
possible
losses
benefits
adding
features
system
support
resilience
Sociotechnical
resilience
Fundamentally
resilience
engineering
sociotechnical
rather
technical
activity
explained
Chapter
sociotechnical
system
includes
hardware
software
people
influenced
culture
policies
procedures
organization
owns
uses
system
design
resilient
system
think
sociotechnical
systems
design
exclusively
focus
software
Resilience
engineering
concerned
adverse
external
events
lead
system
failure
Dealing
events
often
easier
effective
broader
sociotechnical
system
example
Mentcare
system
maintains
confidential
patient
data
possible
external
cyberattack
aim
steal
data
Technical
safeguards
authentication
encryption
used
protect
data
effective
attacker
access
credentials
genuine
system
user
try
solve
problem
technical
level
using
complex
authentication
procedures
However
procedures
annoy
users
lead
vulnerabilities
write
authentication
information
better
strategy
introduce
organizational
policies
procedures
emphasize
importance
sharing
login
credentials
tell
users
easy
ways
create
maintain
strong
passwords
Resilient
systems
flexible
adaptable
cope
unexpected
difficult
create
software
adapt
cope
problems
anticipated
However
saw
Apollo
accident
people
good
Therefore
achieve
resilience
take
advantage
fact
people
inherent
part
sociotechnical
systems
Rather
try
anticipate
deal
problems
software
leave
types
problem
solving
people
responsible
operating
managing
software
system
understand
leave
types
problem
solving
people
consider
hierarchy
sociotechnical
systems
includes
technical
software
intensive
systems
Figure
shows
technical
systems
S
S
@@@@@@@@@@
Sociotechnical
resilience
S
S
ST
OrganizationFailureFailureOperatorsManagers
Figure
Nested
technical
sociotechnical
systems
part
broader
sociotechnical
system
ST
sociotechnical
system
includes
operators
monitor
condition
S
S
take
actions
resolve
problems
systems
system
S
say
fails
operators
ST
detect
failure
take
recovery
actions
software
failure
leads
failure
broader
sociotechnical
system
Operators
invoke
recovery
reinstatement
procedures
get
S
back
normal
operating
state
Operational
management
processes
interface
organization
technical
systems
used
processes
well
designed
allow
people
discover
cope
technical
system
failures
well
ensuring
operator
errors
minimized
discuss
Section
rigid
processes
overautomated
inherently
resilient
allow
people
use
skills
knowledge
adapt
change
processes
cope
unexpected
deal
unanticipated
failures
system
ST
one
number
sociotechnical
systems
organization
system
operators
cannot
contain
technical
system
failure
lead
failure
sociotechnical
system
ST
Managers
organizational
level
detect
problem
take
steps
recover
Resilience
therefore
organizational
well
system
characteristic
Hollnagel
Hollnagel
early
advocate
resilience
engineering
argues
important
organizations
study
learn
successes
well
failure
High
profile
safety
security
failures
lead
inquiries
changes
practice
procedures
However
rather
respond
failures
better
avoid
observing
people
deal
problems
maintain
resilience
good
practice
disseminated
throughout
organization
Figure
shows
four
characteristics
Hollnagel
suggests
reflect
resilience
organization
characteristics
ability
respond
Organizations
able
adapt
processes
procedures
response
risks
risks
anticipated
risks
detected
threats
organization
systems
example
new
security
threat
detected
publicized
resilient
organization
make
changes
quickly
threat
disrupt
operations
ability
monitor
Organizations
monitor
internal
operations
external
environment
threats
arise
example
company
monitor
employees
follow
security
policies
@@@@@@@@@@
Learning
experience
Responding
threats
vulnerabilities
Anticipating
future
threats
opportunities
Monitoring
organization
environment
Figure
Characteristics
resilient
organizations
Anticipating
future
threats
opportunities
Monitoring
organization
environment
Figure
Characteristics
resilient
organizations
potentially
insecure
behavior
detected
company
respond
taking
actions
understand
occurred
change
employee
behavior
ability
anticipate
resilient
organization
simply
focus
current
operations
anticipate
possible
future
events
changes
affect
operations
resilience
events
include
technological
innovations
changes
regulations
laws
modifications
customer
behavior
example
wearable
technology
starting
available
companies
now
thinking
affect
current
security
policies
procedures
ability
learn
Organizational
resilience
improved
learning
experience
particularly
important
learn
successful
responses
adverse
events
effective
resistance
cyberattack
Learning
success
allows
good
practice
disseminated
throughout
organization
Hollnagel
says
resilient
organizations
address
issues
extent
focus
one
quality
others
example
company
running
large
scale
data
center
focus
mostly
monitoring
responsiveness
However
digital
library
manages
long
term
archival
information
anticipate
future
changes
affect
business
well
respond
immediate
security
threats
Human
error
Early
work
resilience
engineering
concerned
accidents
safety
critical
systems
behavior
human
operators
lead
safety
related
system
failures
led
understanding
system
defenses
equally
applicable
systems
withstand
malicious
well
accidental
human
actions
know
people
make
mistakes
unless
system
completely
automated
inevitable
users
system
operators
sometimes
wrong
thing
Unfortunately
human
errors
sometimes
lead
serious
system
failures
Reason
Reason
suggests
problem
human
error
viewed
two
ways
person
approach
Errors
considered
responsibility
individual
unsafe
acts
operator
failing
engage
safety
barrier
@@@@@@@@@@
Sociotechnical
resilience
consequence
individual
carelessness
reckless
behavior
People
adopt
approach
believe
human
errors
reduced
threats
disciplinary
action
stringent
procedures
retraining
view
error
fault
individual
responsible
making
mistake
systems
approach
basic
assumption
people
fallible
make
mistakes
People
make
mistakes
pressure
high
workloads
poor
training
inappropriate
system
design
Good
systems
recognize
possibility
human
error
include
barriers
safeguards
detect
human
errors
allow
system
recover
failure
occurs
failure
occur
best
way
avoid
recurrence
understand
system
defenses
trap
error
Blaming
punishing
person
triggered
failure
improve
long
term
system
safety
believe
systems
approach
right
one
systems
engineers
assume
human
errors
occur
system
operation
Therefore
improve
resilience
system
designers
think
defenses
barriers
human
error
part
system
think
barriers
built
technical
components
system
part
processes
procedures
guidelines
using
system
example
two
operators
required
check
critical
system
inputs
barriers
safeguards
protect
human
errors
technical
sociotechnical
example
code
validate
inputs
technical
defense
approval
procedure
critical
system
updates
needs
two
people
confirm
update
sociotechnical
defense
Using
diverse
barriers
means
shared
vulnerabilities
less
likely
user
error
likely
trapped
system
failure
general
use
redundancy
diversity
create
set
defensive
layers
Figure
layer
uses
different
approach
deter
attackers
trap
component
failures
human
errors
Dark
blue
barriers
software
checks
light
blue
barriers
checks
carried
people
example
approach
defense
depth
checks
controller
errors
part
air
traffic
control
system
include
conflict
alert
warning
part
air
traffic
control
system
controller
instructs
aircraft
change
speed
altitude
system
extrapolates
trajectory
see
intersects
aircraft
sounds
alarm
Formalized
recording
procedures
air
traffic
management
ATC
system
clearly
defined
procedure
setting
record
control
instructions
issued
aircraft
procedures
help
controllers
check
issued
instruction
correctly
make
information
visible
others
checking
Collaborative
checking
Air
traffic
control
involves
team
controllers
constantly
monitor
s
work
controller
makes
mistake
others
usually
detect
correct
incident
occurs
@@@@@@@@@@
Technical
defenses
Figure
Defensive
layers
Errors
attacks
Sociotechnical
defenses
Reason
Reason
draws
idea
defensive
layers
theory
human
errors
lead
system
failures
introduces
called
Swiss
cheese
model
suggests
defensive
layers
solid
barriers
instead
like
slices
Swiss
cheese
types
Swiss
cheese
Emmenthal
holes
varying
sizes
Reason
suggests
vulnerabilities
calls
latent
conditions
layers
analogous
holes
latent
conditions
static
change
depending
state
system
people
involved
system
operation
continue
analogy
holes
change
size
move
around
defensive
layers
system
operation
example
system
relies
operators
checking
s
work
possible
vulnerability
make
mistake
unlikely
normal
conditions
Swiss
cheese
model
hole
small
However
system
heavily
loaded
workload
operators
high
mistakes
likely
size
hole
representing
vulnerability
increases
Failure
system
layered
defenses
occurs
external
trigger
event
potential
cause
damage
event
human
error
Reason
calls
active
failure
cyberattack
defensive
barriers
fail
system
whole
fail
Conceptually
corresponds
holes
Swiss
cheese
slices
lining
shown
Figure
model
suggests
different
strategies
used
increase
system
resilience
adverse
external
events
Reduce
probability
occurrence
external
event
trigger
system
failures
reduce
human
errors
introduce
improved
training
operators
give
operators
control
workload
overloaded
reduce
cyberattacks
reduce
number
people
privileged
system
information
reduce
chances
disclosure
attacker
Increase
number
defensive
layers
general
rule
layers
system
less
likely
holes
line
system
failure
occur
However
layers
independent
share
common
vulnerability
Thus
barriers
likely
hole
place
limited
benefit
adding
new
layer
@@@@@@@@@@
Sociotechnical
resilience
System
failure
Active
failure
Human
error
Latent
conditions
defensive
layers
Figure
Reason
s
Swiss
cheese
model
system
failure
Design
system
diverse
types
barriers
included
means
holes
probably
different
places
less
chance
holes
lining
failing
trap
error
Minimize
number
latent
conditions
system
Effectively
means
reducing
number
size
system
holes
However
significantly
increase
systems
engineering
costs
Reducing
number
bugs
system
increases
testing
V
V
costs
Therefore
option
cost
effective
designing
system
need
consider
options
make
choices
cost
effective
ways
improve
system
s
defenses
building
custom
software
using
software
checking
increase
number
diversity
layers
best
option
However
using
off
shelf
software
consider
sociotechnical
defenses
added
decide
change
training
procedures
reduce
chances
problems
occurring
make
easier
deal
incidents
arise
Operational
management
processes
software
systems
associated
operational
processes
reflect
assumptions
designers
systems
used
software
systems
particularly
control
interfaced
special
equipment
trained
operators
intrinsic
part
control
system
Decisions
made
design
stage
functions
part
technical
system
functions
operator
s
responsibility
example
imaging
system
hospital
operator
responsibility
checking
quality
images
immediately
processed
check
allows
imaging
procedure
repeated
problem
Operational
processes
processes
involved
using
system
defined
purpose
example
operators
air
traffic
control
system
follow
specific
processes
aircraft
enter
leave
airspace
change
height
speed
emergency
occurs
new
systems
operational
processes
defined
documented
system
development
process
Operators
trained
work
processes
adapted
make
effective
use
new
system
@@@@@@@@@@
software
systems
however
trained
operators
system
users
use
system
part
work
support
personal
interests
personal
systems
designers
describe
expected
use
system
no
control
users
behave
enterprise
systems
however
training
provided
users
teach
use
system
user
behavior
cannot
controlled
reasonable
expect
normally
follow
defined
process
Enterprise
systems
usually
system
administrators
managers
responsible
maintaining
system
part
business
process
supported
system
job
monitor
software
system
errors
problems
problems
arise
system
managers
take
action
resolve
restore
system
normal
operational
state
previous
section
discussed
importance
defense
depth
use
diverse
mechanisms
check
adverse
events
lead
system
failure
Operational
management
processes
important
defense
mechanism
designing
process
need
find
balance
efficient
operation
problem
management
often
conflict
shown
Figure
increasing
efficiency
removes
redundancy
diversity
system
past
years
businesses
focused
called
process
improvement
improve
efficiency
operational
management
processes
companies
study
processes
enacted
look
particularly
efficient
inefficient
practice
Efficient
practice
codified
documented
software
developed
support
optimum
process
Inefficient
practice
replaced
efficient
ways
things
Sometimes
process
control
mechanisms
introduced
ensure
system
operators
managers
follow
best
practice
problem
process
improvement
often
makes
harder
people
cope
problems
seems
inefficient
practice
often
arises
people
maintain
redundant
information
share
information
know
makes
easier
deal
problems
things
go
wrong
example
air
traffic
controllers
print
flight
details
well
rely
flight
database
information
flights
air
system
database
becomes
unavailable
People
unique
capability
respond
effectively
unexpected
situations
even
never
direct
experience
situations
Therefore
things
go
wrong
operators
system
managers
often
recover
situation
sometimes
break
rules
work
around
defined
process
therefore
design
operational
processes
flexible
adaptable
operational
processes
constraining
require
operations
done
particular
order
system
software
rely
specific
process
followed
example
emergency
service
control
room
system
used
manage
emergency
calls
initiate
response
calls
normal
process
handling
call
log
caller
s
details
send
message
appropriate
emergency
service
giving
details
incident
address
procedure
provides
audit
trail
actions
taken
subsequent
investigation
check
emergency
call
properly
handled
@@@@@@@@@@
Sociotechnical
resilience
Efficient
process
operation
Problem
management
Process
optimization
control
Process
flexibility
adaptability
Information
hiding
security
Information
sharing
visibility
Automation
reduce
operator
workload
fewer
operators
managers
Manual
processes
spare
operator
manager
capacity
deal
problems
Role
specialization
Role
sharing
Figure
Efficiency
resilience
Now
imagine
system
subject
denial
service
attack
makes
messaging
system
unavailable
Rather
simply
responding
calls
operators
use
personal
mobile
phones
knowledge
call
responders
call
emergency
service
units
directly
respond
serious
incidents
Management
provision
information
important
resilient
operation
make
process
efficient
make
sense
present
operators
information
need
need
security
perspective
information
accessible
unless
operator
manager
needs
information
However
liberal
approach
information
access
improve
system
resilience
operators
presented
information
process
designer
thinks
need
know
unable
detect
problems
directly
affect
immediate
tasks
things
go
wrong
system
operators
broad
picture
happening
system
difficult
formulate
strategies
dealing
problems
cannot
access
information
system
security
reasons
unable
stop
attacks
repair
damage
caused
Automating
system
management
process
means
single
manager
able
manage
large
number
systems
Automated
systems
detect
common
problems
take
actions
recover
problems
Fewer
people
needed
system
operations
management
costs
reduced
However
process
automation
two
disadvantages
Automated
management
systems
go
wrong
take
incorrect
actions
problems
develop
system
take
unexpected
actions
make
situation
worse
cannot
understood
system
managers
Problem
solving
collaborative
process
fewer
managers
available
likely
take
longer
work
strategy
recover
problem
cyberattack
Therefore
process
automation
positive
negative
effects
system
resilience
automated
system
works
properly
detect
problems
invoke
cyberattack
resistance
necessary
start
automated
recovery
procedures
However
automated
system
t
handle
problem
fewer
people
available
tackle
problem
system
damaged
process
automation
wrong
thing
environment
different
types
system
equipment
impractical
expect
operators
managers
able
deal
@@@@@@@@@@
different
systems
Individuals
therefore
specialize
expert
knowledgeable
small
number
systems
leads
efficient
operation
consequences
resilience
system
problem
role
specialization
anyone
available
particular
time
understands
interactions
systems
Consequently
difficult
cope
problems
specialist
available
people
work
several
systems
come
understand
dependencies
relationships
tackle
problems
affect
one
system
no
specialist
available
becomes
much
difficult
contain
problem
repair
damage
caused
use
risk
assessment
discussed
Chapter
help
make
decisions
balance
process
efficiency
resilience
consider
risks
operator
manager
intervention
required
assess
likelihood
risks
extent
possible
losses
arise
risks
lead
serious
damage
extensive
loss
risks
likely
occur
favor
resilience
process
efficiency
Resilient
systems
design
Resilient
systems
resist
recover
adverse
incidents
software
failures
cyberattacks
deliver
critical
services
minimal
interruptions
quickly
return
normal
operating
state
incident
occurred
designing
resilient
system
assume
system
failures
penetration
attacker
occur
include
redundant
diverse
features
cope
adverse
events
Designing
systems
resilience
involves
two
closely
related
streams
work
Identifying
critical
services
assets
Critical
services
assets
elements
system
allow
system
fulfill
primary
purpose
example
primary
purpose
system
handles
ambulance
dispatch
response
emergency
calls
get
help
people
need
quickly
possible
critical
services
concerned
taking
calls
dispatching
ambulances
medical
emergency
services
call
logging
ambulance
tracking
less
important
Designing
system
components
support
problem
recognition
resistance
recovery
reinstatement
example
ambulance
dispatch
system
watchdog
timer
see
Chapter
included
detect
system
responding
events
Operators
authenticate
hardware
token
resist
possibility
unauthorized
access
system
fails
calls
diverted
another
center
essential
services
maintained
Copies
system
database
software
alternative
hardware
maintained
allow
reinstatement
outage
@@@@@@@@@@
Resilient
systems
design
Review
system
Figure
Stages
survivability
analysis
requirements
architecture
Identify
critical
services
components
Identify
attacks
compromisable
components
Identify
softspots
survivability
strategies
fundamental
notions
recognition
resistance
recovery
basis
early
work
resilience
engineering
Ellison
et
al
Ellison
et
al
designed
method
analysis
called
survivable
systems
analysis
method
used
assess
vulnerabilities
systems
support
design
system
architectures
features
promote
system
survivability
Survivable
systems
analysis
four
stage
process
Figure
analyzes
current
proposed
system
requirements
architecture
identifies
critical
services
attack
scenarios
system
softspots
proposes
changes
improve
survivability
system
key
activities
stages
follows
System
understanding
existing
proposed
system
review
goals
system
sometimes
called
mission
objectives
system
requirements
system
architecture
Critical
service
identification
services
maintained
components
required
maintain
services
identified
Attack
simulation
Scenarios
use
cases
possible
attacks
identified
along
system
components
affected
attacks
Survivability
analysis
Components
essential
compromisable
attack
identified
survivability
strategies
based
resistance
recognition
recovery
identified
fundamental
problem
approach
survivability
analysis
starting
point
requirements
architecture
documentation
system
reasonable
assumption
defense
systems
work
sponsored
U
S
Department
Defense
poses
two
problems
business
systems
explicitly
related
business
requirements
resilience
believe
appropriate
starting
point
technical
system
requirements
@@@@@@@@@@
Identify
business
resilience
requirements
Identify
critical
services
Plan
backup
strategy
Test
system
reinstatement
Plan
system
reinstatement
Identify
assets
deliver
critical
services
Identify
events
compromise
assets
Plan
event
recognition
resistance
Propose
software
changes
Buy
new
software
required
Plan
critical
service
recovery
Plan
critical
asset
recovery
Develop
software
support
asset
recovery
Design
asset
redundancy
strategy
Resilience
test
planning
Identify
attack
failure
scenarios
Test
service
recovery
Test
system
resistance
Develop
software
support
reinstatement
Reinstatement
Recognition
resistance
Recovery
Testing
Identify
business
resilience
requirements
Identify
critical
services
Plan
backup
strategy
Test
system
reinstatement
Plan
system
reinstatement
Identify
assets
deliver
critical
services
Identify
events
compromise
assets
Plan
event
recognition
resistance
Propose
software
changes
Buy
new
software
required
Plan
critical
service
recovery
Plan
critical
asset
recovery
Develop
software
support
asset
recovery
Design
asset
redundancy
strategy
Resilience
test
planning
Identify
attack
failure
scenarios
Test
service
recovery
Test
system
resistance
Develop
software
support
reinstatement
Reinstatement
Recognition
resistance
Recovery
Testing
Figure
assumes
detailed
requirements
statement
system
fact
Resilience
engineering
resilience
retrofitted
system
no
complete
date
requirements
document
new
systems
resilience
requirement
systems
developed
using
agile
approach
system
architecture
designed
take
resilience
account
general
resilience
engineering
method
shown
Figure
takes
lack
detailed
requirements
account
well
explicitly
designing
recovery
reinstatement
system
majority
components
system
access
source
code
able
make
changes
strategy
resilience
designed
limitation
mind
five
interrelated
streams
work
approach
resilience
engineering
identify
business
resilience
requirements
requirements
set
business
whole
maintain
services
delivers
customers
resilience
requirements
individual
systems
developed
Providing
resilience
expensive
important
overengineer
systems
unnecessary
resilience
support
plan
reinstate
system
set
systems
normal
operating
state
adverse
event
plan
integrated
business
s
@@@@@@@@@@
Resilient
systems
design
normal
backup
archiving
strategy
allows
recovery
information
technical
human
error
part
wider
disaster
recovery
strategy
take
account
possibility
physical
events
fire
flooding
study
maintain
critical
information
separate
locations
decide
use
cloud
backups
plan
identify
system
failures
cyberattacks
compromise
system
design
recognition
resilience
strategies
cope
adverse
events
plan
recover
critical
services
quickly
damaged
taken
offline
failure
cyberattack
step
usually
involves
providing
redundant
copies
critical
assets
provide
services
switching
copies
required
Critically
test
aspects
resilience
planning
testing
involves
identifying
failure
attack
scenarios
playing
scenarios
system
Maintaining
availability
critical
services
essence
resilience
Accordingly
know
system
services
critical
business
minimal
quality
service
maintained
services
compromised
services
protected
recover
quickly
services
unavailable
part
analysis
critical
services
identify
system
assets
essential
delivering
services
assets
hardware
servers
network
etc
software
data
people
build
resilient
system
think
use
redundancy
diversity
ensure
assets
remain
available
event
system
failure
activities
key
providing
rapid
response
recovery
plan
adverse
event
additional
software
supports
resistance
recovery
reinstatement
commercial
security
software
resilience
support
programmed
application
systems
include
scripts
specially
written
programs
developed
recovery
reinstatement
right
support
software
processes
recovery
reinstatement
partially
automated
quickly
invoked
executed
system
failure
Resilience
testing
involves
simulating
possible
system
failures
cyberattacks
test
resilience
plans
drawn
work
expected
Testing
essential
know
experience
assumptions
made
resilience
planning
often
invalid
planned
actions
work
Testing
resilience
reveal
problems
resilience
plan
refined
@@@@@@@@@@
Mentcare
client
Mentcare
server
Patient
database
Mentcare
client
Mentcare
client
Network
Mentcare
client
Mentcare
server
Patient
database
Mentcare
client
Mentcare
client
Network
Figure
client
server
architecture
Mentcare
system
Testing
difficult
expensive
obviously
testing
cannot
carried
operational
system
system
environment
duplicated
testing
staff
released
normal
responsibilities
work
test
system
reduce
costs
use
desk
testing
testing
team
assumes
problem
occurred
tests
reactions
simulate
problem
real
system
approach
provide
useful
information
system
resilience
less
effective
testing
discovering
deficiencies
resilience
plan
example
approach
let
us
look
resilience
engineering
Mentcare
system
recap
system
used
support
clinicians
treating
patients
variety
locations
mental
health
problems
provides
patient
information
records
consultations
doctors
specialist
nurses
includes
number
checks
flag
patients
potentially
dangerous
suicidal
Figure
shows
architecture
system
system
consulted
doctors
nurses
consultation
patient
information
updated
consultation
ensure
effectiveness
clinics
business
resilience
requirements
critical
system
services
available
normal
working
hours
patient
data
permanently
damaged
lost
system
failure
cyberattack
patient
information
released
unauthorized
people
Two
critical
services
system
maintained
information
service
provides
information
patient
s
current
diagnosis
treatment
plan
warning
service
highlights
patients
pose
danger
others
Notice
critical
service
availability
complete
patient
record
Doctors
nurses
need
go
back
previous
treatments
occasionally
@@@@@@@@@@
Resilient
systems
design
clinical
care
seriously
affected
full
record
available
Therefore
possible
deliver
effective
care
using
summary
record
includes
information
patient
recent
treatment
assets
required
deliver
services
normal
system
operations
patient
record
database
maintains
patient
information
database
server
provides
access
database
local
client
computers
network
client
server
communications
Local
laptop
desktop
computers
used
clinicians
access
patient
information
set
rules
identify
patients
potentially
dangerous
flag
patient
records
Client
software
highlights
dangerous
patients
system
users
plan
recognition
resistance
recovery
strategies
need
develop
set
scenarios
anticipate
adverse
events
compromise
critical
services
offered
system
Examples
adverse
events
unavailability
database
server
system
failure
network
failure
denial
service
cyberattack
deliberate
accidental
corruption
patient
record
database
rules
define
meant
dangerous
patient
Infection
client
computers
malware
Access
client
computers
unauthorized
people
gain
access
patient
records
Figure
shows
possible
recognition
resistance
strategies
adverse
events
Notice
technical
approaches
include
workshops
inform
system
users
security
issues
know
many
security
breaches
arise
users
inadvertently
reveal
privileged
information
attacker
workshops
reduce
chances
happening
don
t
space
discuss
options
identified
Figure
Instead
focus
system
architecture
modified
resilient
Figure
suggested
maintaining
patient
information
client
computers
possible
redundancy
strategy
help
maintain
critical
services
leads
modified
software
architecture
shown
Figure
key
features
architecture
Summary
patient
records
maintained
local
client
computers
local
computers
communicate
directly
exchange
information
using
system
network
necessary
ad
hoc
network
created
using
mobile
phones
Therefore
database
unavailable
doctors
nurses
still
access
essential
patient
information
resistance
recovery
backup
server
allow
main
server
failure
server
responsible
taking
regular
snapshots
database
backups
event
main
server
@@@@@@@@@@
Event
Recognition
Resistance
Event
Recognition
Resistance
Server
Watchdog
timer
client
unavailability
times
no
response
client
access
Text
messages
system
managers
clinical
users
Design
system
architecture
maintain
local
copies
critical
information
Provide
peer
peer
search
across
clients
patient
data
Provide
staff
smartphones
used
access
network
event
server
failure
Provide
backup
server
Replayable
transaction
log
update
database
backup
recent
transactions
Maintenance
local
copies
patient
information
software
restore
database
local
copies
backups
Security
awareness
workshops
system
users
Disabling
USB
ports
client
computers
Automated
system
setup
new
clients
Support
access
system
mobile
devices
Installation
security
software
Multilevel
system
authentication
process
Disabling
USB
ports
client
computers
Access
logging
real
time
log
analysis
Security
awareness
workshops
system
users
fails
act
main
server
whole
system
provides
continuity
service
recovery
server
failure
resistance
recovery
Database
integrity
checking
recovery
software
Integrity
checking
runs
background
task
checking
signs
database
corruption
corruption
discovered
automatically
initiate
recovery
data
backups
transaction
log
allows
backups
updated
details
recent
changes
recognition
recovery
Figure
Recognition
resistance
strategies
adverse
events
Patient
database
corruption
Record
level
cryptographic
checksums
Regular
auto
checking
database
integrity
Reporting
system
incorrect
information
Malware
infection
Reporting
system
client
computers
computer
users
report
unusual
behavior
Automated
malware
checks
startup
Unauthorized
access
patient
Warning
text
messages
information
users
possible
intruders
Log
analysis
unusual
activity
maintain
key
services
patient
information
access
staff
warning
make
use
inherent
redundancy
client
server
system
downloading
information
client
start
clinic
session
consultation
continue
without
server
access
information
patients
scheduled
attend
consultations
day
needs
downloaded
need
access
patient
information
server
unavailable
client
computers
contacted
using
peer
peer
communication
see
information
available
service
provides
warning
staff
patients
dangerous
easily
implemented
using
approach
records
patients
harm
others
identified
download
process
clinical
staff
access
records
software
highlight
records
indicate
patients
require
special
care
@@@@@@@@@@
Resilient
systems
design
Mentcare
client
Mentcare
server
Patient
database
Mentcare
client
Mentcare
client
Network
Summary
patient
records
Summary
patient
records
Summary
patient
records
Backup
server
Database
integrity
checker
Transaction
log
Database
backup
Figure
architecture
Mentcare
system
resilience
features
architecture
support
resistance
adverse
events
useful
supporting
recovery
events
maintaining
multiple
copies
information
backup
hardware
available
critical
system
services
quickly
restored
normal
operation
system
need
available
normal
working
hours
say
m
p
m
system
reinstated
overnight
available
following
day
failure
well
maintaining
critical
services
business
requirements
maintaining
confidentiality
integrity
patient
data
supported
architecture
shown
Figure
includes
backup
system
explicit
database
integrity
checking
reduce
chances
patient
information
damaged
accidentally
malicious
attack
Information
client
computers
available
used
support
recovery
data
corruption
damage
maintaining
multiple
copies
data
safeguard
data
corruption
poses
risk
confidentiality
copies
secured
case
risk
controlled
downloading
summary
records
patients
scheduled
attend
clinic
limits
number
records
compromised
Encrypting
disk
local
client
computers
Attackers
encryption
key
cannot
read
disk
gain
access
computer
Securely
deleting
downloaded
information
end
clinic
session
reduces
chances
attacker
gaining
access
confidential
information
@@@@@@@@@@
Ensuring
network
transactions
encrypted
attacker
intercepts
transactions
cannot
get
access
information
performance
degradation
probably
impractical
encrypt
entire
patient
database
server
Strong
authentication
therefore
used
protect
information
Key
Points
resilience
system
judgment
well
system
maintain
continuity
critical
services
presence
disruptive
events
equipment
failure
cyberattacks
Resilience
based
Rs
model
recognition
resistance
recovery
reinstatement
Resilience
planning
based
assumption
networked
systems
subject
cyberattacks
malicious
insiders
outsiders
attacks
successful
Systems
designed
number
defensive
layers
different
types
layers
effective
human
technical
failures
trapped
cyberattacks
resisted
allow
system
operators
managers
cope
problems
processes
flexible
adaptable
Process
automation
make
difficult
people
cope
problems
Business
resilience
requirements
starting
point
designing
systems
resilience
achieve
system
resilience
focus
recognition
recovery
problems
recovery
critical
services
assets
reinstatement
system
important
part
design
resilience
identifying
critical
services
services
essential
system
ensure
primary
purpose
Systems
designed
services
protected
event
failure
recovered
quickly
possible
reading
Survivable
Network
System
Analysis
Case
Study
excellent
paper
introduces
notion
system
survivability
uses
case
study
mental
health
record
treatment
system
illustrate
application
survivability
method
R
J
Ellison
R
C
Linger
T
Longstaff
N
R
Mead
IEEE
Software
July
August
http
dx
doi
org
Resilience
Engineering
Practice
Guidebook
collection
articles
case
studies
resilience
engineering
takes
broad
sociotechnical
systems
perspective
E
Hollnagel
J
Paries
D
W
Woods
J
Wreathall
Ashgate
Publishing
Co
Cyber
Risk
Resilience
Management
website
wide
range
resources
cybersecurity
resilience
including
model
resilience
management
Software
Engineering
Institute
https
www
cert
org
resilience
@@@@@@@@@@
Chapter
Exercises
WebSite
PowerPoint
slides
chapter
www
pearsonglobaleditions
com
Sommerville
Links
supporting
videos
http
software
engineering
book
com
videos
security
resilience
exeRCiSeS
Explain
complementary
strategies
resistance
recognition
recovery
reinstatement
used
provide
system
resilience
types
threats
considered
resilience
planning
Provide
examples
controls
organizations
put
place
counter
threats
Describe
ways
human
error
viewed
according
Reason
Reason
strategies
used
increase
resilience
according
Swiss
cheese
model
Figure
hospital
proposes
introduce
policy
member
clinical
staff
doctors
nurses
takes
authorizes
actions
leads
patient
injured
subject
criminal
charges
Explain
bad
idea
unlikely
improve
patient
safety
likely
adversely
affect
resilience
organization
survivable
systems
analysis
key
activities
four
stages
involved
shown
Figure
Explain
process
inflexibility
inhibit
ability
sociotechnical
system
resist
recover
adverse
events
cyberattacks
software
failure
experience
process
inflexibility
illustrate
answer
examples
experience
Suggest
approach
resilience
engineering
proposed
Figure
used
conjunction
agile
development
process
software
system
problems
arise
using
agile
development
systems
resilience
important
Section
unauthorized
user
places
malicious
orders
move
prices
intrusion
corrupts
database
transactions
taken
place
cyberattacks
identify
resistance
recognition
recovery
strategies
used
Figure
suggested
number
adverse
events
affect
Mentcare
system
Draw
test
plan
system
sets
test
ability
Mentcare
system
recognize
resist
recover
events
senior
manager
company
concerned
insider
attacks
disaffected
staff
company
s
assets
part
resilience
improvement
program
proposes
logging
system
data
analysis
software
introduced
capture
analyze
employee
actions
employees
told
system
Discuss
ethics
introducing
logging
system
without
telling
system
users
@@@@@@@@@@
Chapter
Resilience
engineering
ReFeRenCeS
Ellison
R
J
R
C
Linger
T
Longstaff
N
R
Mead
Survivable
Network
System
Analysis
Case
Study
IEEE
Software
doi
Ellison
R
J
R
C
Linger
H
Lipson
N
R
Mead
Moore
Foundations
Survivable
Systems
Engineering
Crosstalk
Journal
Defense
Software
Engineering
http
resources
sei
cmu
edu
asset
files
WhitePaper
pdf
Hollnagel
E
Resilience
Challenge
Unstable
Resilience
Engineering
Concepts
Precepts
edited
E
Hollnagel
D
D
Woods
N
G
Leveson
RAG
Resilience
Analysis
Grid
Resilience
Engineering
Practice
edited
E
Hollnagel
J
Paries
D
Woods
J
Wreathall
Farnham
UK
Ashgate
Publishing
Group
InfoSecurity
Global
Cybercrime
Espionage
Costs
Billion
Per
Year
http
www
infosecurity
magazine
com
view
global
cybercrime
espionage
costs
billion
per
year
Laprie
J
C
Dependability
Resilience
th
Int
Conf
Dependable
Systems
Networks
Anchorage
Alaska
http
dsn
org
fastabs
dsn
fastabs
laprie
pdf
Reason
J
Human
Error
Models
Management
British
Medical
J
doi
bmj
@@@@@@@@@@
PART
Advanced
Software
Engineering
part
book
covers
advanced
software
engineering
topics
assume
chapters
readers
understand
basics
discipline
covered
Chapters
Chapters
focus
dominant
development
paradigm
web
based
information
systems
enterprise
systems
software
reuse
Chapter
introduces
topic
explains
different
types
reuse
possible
cover
common
approach
reuse
reuse
application
systems
configured
adapted
specific
needs
business
Chapter
concerned
reuse
software
components
rather
entire
software
systems
chapter
explain
meant
component
standard
component
models
needed
effective
component
reuse
discuss
general
process
component
based
software
engineering
problems
component
composition
majority
large
systems
now
distributed
systems
Chapter
covers
issues
problems
building
distributed
systems
introduce
client
server
approach
fundamental
paradigm
distributed
systems
engineering
explain
ways
implementing
architectural
style
final
section
explains
software
service
delivery
software
functionality
Internet
changed
market
software
products
@@@@@@@@@@
Chapter
introduces
related
topic
service
oriented
architectures
link
notions
distribution
reuse
Services
reusable
software
components
functionality
accessed
Internet
discuss
two
widely
used
approaches
service
development
namely
SOAP
based
RESTful
services
explain
involved
creating
services
service
engineering
composing
services
create
new
software
systems
focus
Chapters
systems
engineering
Chapter
introduce
topic
explain
important
software
engineers
understand
systems
engineering
discuss
systems
engineering
life
cycle
importance
procurement
life
cycle
Chapter
covers
systems
systems
SoS
large
systems
build
st
century
developed
scratch
created
integrating
existing
complex
systems
explain
understanding
complexity
important
SoS
development
discuss
architectural
patterns
complex
systems
systems
software
systems
apps
business
systems
embedded
real
time
systems
Chapter
covers
important
topic
introduce
idea
real
time
embedded
system
describe
architectural
patterns
used
embedded
systems
design
explain
process
timing
analysis
conclude
chapter
discussion
real
time
operating
systems
@@@@@@@@@@
Software
reuse
Objectives
objectives
chapter
introduce
software
reuse
describe
approaches
system
development
based
large
scale
software
reuse
read
chapter
understand
benefits
problems
reusing
software
developing
new
systems
understand
concept
application
framework
set
reusable
objects
frameworks
used
application
development
introduced
software
product
lines
made
common
core
architecture
reusable
components
configured
version
product
learned
systems
developed
configuring
composing
off
shelf
application
software
systems
Contents
reuse
landscape
Application
frameworks
Software
product
lines
Application
system
reuse
@@@@@@@@@@
Chapter
Software
reuse
Reuse
based
software
engineering
software
engineering
strategy
development
process
geared
reusing
existing
software
around
systematic
software
reuse
uncommon
now
used
extensively
development
new
business
systems
move
reuse
based
development
response
demands
lower
software
production
maintenance
costs
faster
delivery
systems
increased
software
quality
Companies
see
software
valuable
asset
promoting
reuse
existing
systems
increase
return
software
investments
Reusable
software
different
kinds
now
widely
available
open
source
movement
meant
huge
code
base
reused
form
program
libraries
entire
applications
Many
domain
specific
application
systems
ERP
systems
available
tailored
adapted
customer
requirements
large
companies
provide
range
reusable
components
customers
Standards
web
service
standards
made
easier
develop
software
services
reuse
across
range
applications
Reuse
based
software
engineering
approach
development
tries
maximize
reuse
existing
software
software
units
reused
radically
different
sizes
example
System
reuse
Complete
systems
made
number
application
programs
reused
part
system
systems
Chapter
Application
reuse
application
reused
incorporating
without
change
systems
configuring
application
different
customers
Alternatively
application
families
software
product
lines
common
architecture
adapted
individual
customer
requirements
used
develop
new
system
Component
reuse
Components
application
ranging
size
subsystems
single
objects
reused
example
pattern
matching
system
developed
part
text
processing
system
reused
database
management
system
Components
hosted
cloud
private
servers
accessible
application
programming
interface
API
services
Object
function
reuse
Software
components
implement
single
function
mathematical
function
object
class
reused
form
reuse
designed
around
standard
libraries
common
past
years
Many
libraries
functions
classes
freely
available
reuse
classes
functions
libraries
linking
newly
developed
application
code
areas
mathematical
algorithms
graphics
specialized
expensive
expertise
needed
develop
efficient
objects
functions
reuse
particularly
cost
effective
software
systems
components
include
generic
functionality
potentially
reusable
However
systems
components
sometimes
@@@@@@@@@@
Chapter
Software
reuse
Benefit
Explanation
Accelerated
development
Bringing
system
market
early
possible
often
important
overall
development
costs
Reusing
software
speed
system
production
development
validation
time
reduced
Instead
work
application
specialists
develop
reusable
software
encapsulates
knowledge
Reused
software
tried
tested
working
systems
dependable
new
software
design
implementation
faults
found
fixed
Development
costs
proportional
size
software
developed
Reusing
software
means
fewer
lines
code
written
cost
existing
software
already
known
costs
development
matter
judgment
important
factor
project
management
reduces
margin
error
project
cost
estimation
especially
true
large
software
components
subsystems
reused
standards
user
interface
standards
implemented
set
reusable
components
example
menus
user
interface
implemented
using
reusable
components
applications
present
menu
formats
users
use
standard
user
interfaces
improves
dependability
users
make
fewer
mistakes
presented
familiar
interface
specific
expensive
modify
new
situation
Rather
reuse
code
however
reuse
ideas
basis
software
called
concept
reuse
Figure
Benefits
software
reuse
Effective
use
specialists
Increased
dependability
Lower
development
costs
Reduced
process
risk
Standards
compliance
concept
reuse
reuse
software
component
rather
reuse
idea
way
working
algorithm
concept
reuse
represented
abstract
notation
system
model
include
implementation
detail
therefore
configured
adapted
range
situations
Concept
reuse
embodied
approaches
design
patterns
Chapter
configurable
system
products
program
generators
concepts
reused
reuse
process
include
activity
abstract
concepts
instantiated
create
executable
components
obvious
advantage
software
reuse
overall
development
costs
lower
Fewer
software
components
need
specified
designed
implemented
validated
However
cost
reduction
one
benefit
software
reuse
listed
advantages
reusing
software
Figure
However
costs
difficulties
associated
reuse
Figure
significant
cost
associated
understanding
component
suitable
reuse
particular
situation
testing
component
ensure
dependability
additional
costs
mean
savings
development
costs
less
anticipated
However
benefits
reuse
still
apply
@@@@@@@@@@
Chapter
Software
reuse
Problem
Explanation
Creating
maintaining
using
Populating
reusable
component
library
ensuring
software
component
library
developers
use
library
expensive
Development
processes
adapted
ensure
library
used
Software
components
discovered
library
understood
sometimes
adapted
work
new
environment
Engineers
reasonably
confident
finding
component
library
include
component
search
part
normal
development
process
source
code
reused
software
system
component
available
maintenance
costs
higher
reused
elements
system
incompatible
changes
made
system
software
tools
support
development
reuse
difficult
impossible
integrate
tools
component
library
system
software
process
assumed
tools
take
reuse
account
likely
case
tools
support
embedded
systems
engineering
object
oriented
development
tools
software
engineers
prefer
rewrite
components
believe
improve
partly
trust
partly
fact
writing
original
software
seen
challenging
reusing
people
s
software
Figure
Problems
software
reuse
discussed
Chapter
software
development
processes
adapted
take
reuse
account
particular
requirements
refinement
stage
requirements
system
modified
reflect
reusable
software
available
design
implementation
stages
system
include
explicit
activities
look
evaluate
candidate
components
reuse
Finding
understanding
adapting
reusable
components
Increased
maintenance
costs
Lack
tool
support
invented
syndrome
reuse
landscape
past
years
many
techniques
developed
support
software
reuse
techniques
exploit
facts
systems
application
domain
similar
potential
reuse
reuse
possible
different
levels
simple
functions
complete
applications
standards
reusable
components
facilitate
reuse
Figure
shows
reuse
landscape
different
ways
implementing
software
reuse
approaches
reuse
briefly
described
Figure
Given
array
techniques
reuse
key
question
appropriate
technique
use
particular
situation
Obviously
answer
question
depends
requirements
system
developed
technology
@@@@@@@@@@
reuse
landscape
Design
Architectural
patterns
patterns
Application
Software
product
Application
ERP
systems
frameworks
lines
system
integration
Systems
Configurable
Legacy
system
systems
application
systems
wrapping
Component
based
Model
driven
Service
oriented
software
engineering
engineering
systems
Aspect
oriented
Program
Program
software
engineering
generators
libraries
Figure
reuse
landscape
reusable
assets
available
expertise
development
team
Key
factors
consider
planning
reuse
development
schedule
software
software
developed
quickly
try
reuse
complete
systems
rather
individual
components
fit
requirements
imperfect
approach
minimizes
amount
development
required
expected
software
lifetime
developing
long
lifetime
system
focus
maintainability
system
think
immediate
benefits
reuse
long
term
implications
lifetime
adapt
system
new
requirements
mean
making
changes
parts
system
access
source
code
reusable
components
prefer
avoid
off
theshelf
components
systems
external
suppliers
suppliers
able
continue
support
reused
software
decide
safer
reuse
open
source
systems
components
Chapter
means
access
keep
copies
source
code
background
skills
experience
development
team
reuse
technologies
fairly
complex
need
quite
lot
time
understand
use
effectively
Therefore
focus
reuse
effort
areas
development
team
expertise
criticality
software
non
functional
requirements
critical
system
certified
external
regulator
create
safety
security
case
system
discussed
Chapter
difficult
don
t
access
source
code
software
software
stringent
performance
requirements
impossible
use
strategies
model
driven
engineering
MDE
Chapter
MDE
relies
generating
code
reusable
domain
specific
model
system
However
code
generators
used
MDE
often
generate
relatively
inefficient
code
@@@@@@@@@@
Chapter
Software
reuse
Approach
Description
Application
frameworks
Collections
abstract
concrete
classes
adapted
extended
create
application
systems
Application
system
integration
Two
application
systems
integrated
provide
extended
functionality
Architectural
patterns
Standard
software
architectures
support
common
types
application
system
used
basis
applications
Described
Chapters
Aspect
oriented
software
development
Shared
components
woven
application
different
places
program
compiled
Described
web
Chapter
Component
based
software
engineering
Systems
developed
integrating
components
collections
objects
conform
component
model
standards
Described
Chapter
Configurable
application
systems
Domain
specific
systems
designed
configured
needs
specific
system
customers
Design
patterns
Generic
abstractions
occur
across
applications
represented
design
patterns
showing
abstract
concrete
objects
interactions
Described
Chapter
ERP
systems
Large
scale
systems
encapsulate
generic
business
functionality
rules
configured
organization
Legacy
system
wrapping
Legacy
systems
Chapter
wrapped
defining
set
interfaces
providing
access
legacy
systems
interfaces
Model
driven
engineering
Software
represented
domain
models
implementation
independent
models
code
generated
models
Described
Chapter
Program
generators
generator
system
embeds
knowledge
type
application
used
generate
systems
domain
user
supplied
system
model
Program
libraries
Class
function
libraries
implement
commonly
used
abstractions
available
reuse
Service
oriented
systems
Systems
developed
linking
shared
services
externally
provided
Described
Chapter
Software
product
lines
application
type
generalized
around
common
architecture
adapted
different
customers
Systems
systems
Two
distributed
systems
integrated
create
new
system
Described
Chapter
Figure
Approaches
support
software
reuse
application
domain
many
application
domains
manufacturing
medical
information
systems
generic
products
reused
configuring
local
situation
one
effective
approaches
reuse
cheaper
buy
rather
build
new
system
@@@@@@@@@@
Application
frameworks
Generator
based
reuse
Generator
based
reuse
involves
incorporating
reusable
concepts
knowledge
automated
tools
providing
easy
way
tool
users
integrate
specific
code
generic
knowledge
approach
usually
effective
domain
specific
applications
Known
solutions
problems
domain
embedded
generator
system
selected
user
create
new
system
http
software
engineering
book
com
web
generator
reuse
platform
system
run
components
models
NET
specific
Microsoft
platforms
Similarly
generic
application
systems
platform
specific
able
reuse
system
designed
platform
range
available
reuse
techniques
situations
possibility
software
reuse
reuse
achieved
often
managerial
rather
technical
issue
Managers
unwilling
compromise
requirements
allow
reusable
components
used
understand
risks
associated
reuse
well
understand
risks
original
development
risks
new
software
development
higher
managers
prefer
known
risks
development
unknown
risks
reuse
promote
company
wide
reuse
necessary
introduce
reuse
program
focuses
creation
reusable
assets
processes
facilitate
reuse
Jacobsen
Griss
Jonsson
Application
frameworks
Early
enthusiasts
object
oriented
development
suggested
one
key
benefits
using
object
oriented
approach
objects
reused
different
systems
However
experience
shown
objects
often
fine
grained
often
specialized
particular
application
often
takes
longer
understand
adapt
object
reimplement
now
clear
object
oriented
reuse
best
supported
object
oriented
development
process
larger
grain
abstractions
called
frameworks
name
suggests
framework
generic
structure
extended
create
specific
subsystem
application
Schmidt
et
al
Schmidt
et
al
define
framework
integrated
set
software
artifacts
classes
objects
components
collaborate
provide
reusable
architecture
family
related
applications
Frameworks
provide
support
generic
features
likely
used
applications
similar
type
example
user
interface
framework
provide
support
Schmidt
D
C
Gokhale
B
Natarajan
Leveraging
Application
Frameworks
ACM
Queue
July
August
doi
@@@@@@@@@@
Chapter
Software
reuse
Model
methods
Controller
methods
User
inputs
view
modification
messages
Model
edits
Model
queries
updates
Controller
state
Model
state
Figure
Model
View
Controller
pattern
View
methods
View
state
interface
event
handling
include
set
widgets
used
construct
displays
left
developer
specialize
adding
specific
functionality
particular
application
example
user
interface
framework
developer
defines
display
layouts
appropriate
application
implemented
Frameworks
support
design
reuse
provide
skeleton
architecture
application
well
reuse
specific
classes
system
architecture
implemented
object
classes
interactions
Classes
reused
directly
extended
using
features
inheritance
polymorphism
Frameworks
implemented
collection
concrete
abstract
object
classes
object
oriented
programming
language
Therefore
frameworks
language
specific
Frameworks
available
commonly
used
object
oriented
programming
languages
Java
C
C
well
dynamic
languages
Ruby
Python
fact
framework
incorporate
frameworks
framework
designed
support
development
part
application
use
framework
create
complete
application
implement
part
application
graphical
user
interface
widely
used
application
frameworks
web
application
frameworks
WAFs
support
construction
dynamic
websites
architecture
WAF
usually
based
Model
View
Controller
MVC
Composite
pattern
shown
Figure
MVC
pattern
originally
proposed
s
approach
GUI
design
allowed
multiple
presentations
object
separate
styles
interaction
presentations
essence
separates
state
presentation
state
updated
presentation
MVC
framework
supports
presentation
data
different
ways
allows
interaction
presentations
data
modified
one
presentations
system
model
changed
controllers
associated
view
update
presentation
Frameworks
often
implementations
design
patterns
discussed
Chapter
example
MVC
framework
includes
Observer
pattern
Strategy
pattern
Composite
pattern
number
others
discussed
Gamma
et
al
Gamma
et
al
general
nature
patterns
use
abstract
concrete
classes
allow
extensibility
Without
patterns
frameworks
certainly
impractical
@@@@@@@@@@
Application
frameworks
Application
specific
classes
GUI
Database
Event
loop
Callbacks
Event
loop
Platform
Event
loop
CallbacksCallbacks
Figure
Inversion
control
frameworks
framework
includes
slightly
different
functionality
web
application
frameworks
usually
provide
components
classes
support
Security
WAFs
include
classes
help
implement
user
authentication
login
access
control
ensure
users
access
permitted
functionality
system
Dynamic
web
pages
Classes
provided
help
define
web
page
templates
populate
dynamically
specific
data
system
database
Database
integration
Frameworks
don
t
usually
include
database
assume
separate
database
MySQL
used
framework
include
classes
provide
abstract
interface
different
databases
Session
management
Classes
create
manage
sessions
number
interactions
system
user
usually
part
WAF
User
interaction
Web
frameworks
provide
AJAX
Holdener
HTML
support
Sarris
allows
interactive
web
pages
created
include
classes
allow
device
independent
interfaces
created
adapt
automatically
mobile
phones
tablets
implement
system
using
framework
add
concrete
classes
inherit
operations
abstract
classes
framework
addition
define
callbacks
methods
called
response
events
recognized
framework
framework
objects
rather
application
specific
objects
responsible
control
system
Schmidt
et
al
Schmidt
Gokhale
Natarajan
call
inversion
control
response
events
user
interface
database
framework
objects
invoke
hook
methods
linked
user
provided
functionality
user
provided
functionality
defines
application
respond
event
Figure
example
framework
method
handles
mouse
click
environment
method
called
hook
method
configure
call
appropriate
application
methods
handle
mouse
click
@@@@@@@@@@
Chapter
Software
reuse
Fayad
Schmidt
Fayad
Schmidt
discuss
three
classes
framework
System
infrastructure
frameworks
support
development
system
infrastructures
communications
user
interfaces
compilers
Middleware
integration
frameworks
consist
set
standards
associated
object
classes
support
component
communication
information
exchange
Examples
type
framework
include
Microsoft
s
NET
Enterprise
Java
Beans
EJB
frameworks
provide
support
standardized
component
models
discussed
Chapter
Enterprise
application
frameworks
concerned
specific
application
domains
telecommunications
financial
systems
Baumer
et
al
embed
application
domain
knowledge
support
development
end
user
applications
now
widely
used
largely
superseded
software
product
lines
Applications
constructed
using
frameworks
basis
reuse
concept
software
product
lines
application
families
applications
constructed
using
framework
modifying
family
members
create
instances
system
often
straightforward
process
involves
rewriting
concrete
classes
methods
added
framework
Frameworks
effective
approach
reuse
However
expensive
introduce
software
development
processes
inherently
complex
take
several
months
learn
use
difficult
expensive
evaluate
available
frameworks
choose
appropriate
one
Debugging
framework
based
applications
difficult
debugging
original
code
understand
framework
methods
interact
Debugging
tools
provide
information
reused
framework
components
developer
understand
Software
product
lines
company
support
number
similar
identical
systems
one
effective
approaches
reuse
create
software
product
line
Hardware
control
systems
often
developed
using
approach
reuse
domain
specific
applications
areas
logistics
medical
systems
example
printer
manufacturer
develop
printer
control
software
specific
version
product
type
printer
software
versions
much
common
makes
sense
create
core
product
product
line
adapt
printer
type
software
product
line
set
applications
common
architecture
shared
components
application
specialized
reflect
specific
customer
requirements
core
system
designed
configured
adapted
Fayad
M
E
D
C
Schmidt
Object
Oriented
Application
Frameworks
Comm
ACM
doi
@@@@@@@@@@
Software
product
lines
Specialized
application
components
Configurable
application
components
Core
components
Figure
organization
base
system
product
line
suit
needs
different
customers
equipment
involve
configuration
components
implementing
additional
components
modifying
components
reflect
new
requirements
Developing
applications
adapting
generic
version
application
means
high
proportion
application
code
reused
system
Testing
simplified
tests
large
parts
application
reused
thus
reducing
overall
application
development
time
Engineers
learn
application
domain
software
product
line
specialists
work
quickly
develop
new
applications
Software
product
lines
usually
emerge
existing
applications
organization
develops
application
similar
system
required
informally
reuses
code
new
application
process
used
similar
applications
developed
However
change
tends
corrupt
application
structure
new
instances
developed
becomes
increasingly
difficult
create
new
version
Consequently
decision
design
generic
product
line
made
involves
identifying
common
functionality
product
instances
developing
base
application
used
future
development
base
application
Figure
designed
simplify
reuse
reconfiguration
Generally
base
application
includes
Core
components
provide
infrastructure
support
usually
modified
developing
new
instance
product
line
Configurable
components
modified
configured
specialize
new
application
Sometimes
possible
reconfigure
components
without
changing
code
using
built
component
configuration
language
Specialized
domain
specific
components
replaced
new
instance
product
line
created
Application
frameworks
software
product
lines
much
common
support
common
architecture
components
require
new
development
create
specific
version
system
main
differences
approaches
follows
Application
frameworks
rely
object
oriented
features
inheritance
polymorphism
implement
extensions
framework
Generally
framework
@@@@@@@@@@
Chapter
Software
reuse
code
modified
possible
modifications
limited
whatever
supported
framework
Software
product
lines
necessarily
created
using
object
oriented
approach
Application
components
changed
deleted
rewritten
no
limits
principle
least
changes
made
application
frameworks
provide
general
support
rather
domain
specific
support
example
application
frameworks
create
web
based
applications
software
product
line
usually
embeds
detailed
domain
platform
information
example
software
product
line
concerned
web
based
applications
health
record
management
Software
product
lines
often
control
applications
equipment
example
software
product
line
family
printers
means
product
line
provide
support
hardware
interfacing
Application
frameworks
usually
software
oriented
usually
include
hardware
interaction
components
Software
product
lines
made
family
related
applications
owned
organization
create
new
application
starting
point
often
closest
member
application
family
generic
core
application
developing
software
product
line
using
object
oriented
programming
language
use
application
framework
basis
system
create
core
product
line
extending
framework
domain
specific
components
using
built
mechanisms
second
phase
development
versions
system
different
customers
created
example
use
web
based
framework
build
core
software
product
line
supports
web
based
help
desks
help
desk
product
line
specialized
provide
particular
types
help
desk
support
architecture
software
product
line
often
reflects
general
application
specific
architectural
style
pattern
example
consider
product
line
system
designed
handle
vehicle
dispatching
emergency
services
Operators
system
take
calls
incidents
find
appropriate
vehicle
respond
incident
dispatch
vehicle
incident
site
developers
system
market
versions
police
fire
ambulance
services
vehicle
dispatching
system
example
generic
resource
allocation
management
architecture
Figure
Resource
management
systems
use
database
available
resources
include
components
implement
resource
allocation
policy
decided
company
using
system
Users
interact
resource
management
system
request
release
resources
ask
questions
resources
availability
see
four
layer
structure
instantiated
Figure
shows
modules
included
vehicle
dispatching
system
product
line
components
level
product
line
system
follows
interaction
level
components
provide
operator
display
interface
interface
communications
systems
used
@@@@@@@@@@
Software
product
lines
Interaction
User
interface
O
management
User
authentication
Query
management
Resource
delivery
Resource
management
Resource
tracking
Resource
policy
control
Resource
allocation
Database
management
Figure
architecture
resource
management
system
Resource
database
Transaction
management
Interaction
O
managementOperator
interface
Comms
system
interface
O
management
Resource
managemOperator
authentication
entMap
route
planner
Report
generator
Query
manager
Resource
management
Vehicle
status
manager
Incident
logger
Vehicle
dispatcher
Equipment
manager
Vehicle
locator
Database
management
Equipment
database
Transaction
management
Vehicle
database
Incident
log
Map
database
Figure
product
line
architecture
vehicle
dispatcher
system
O
management
level
level
components
handle
operator
authentication
generate
reports
incidents
vehicles
dispatched
support
map
output
route
planning
provide
mechanism
operators
query
system
databases
resource
management
level
level
components
allow
vehicles
located
dispatched
update
status
vehicles
equipment
log
details
incidents
database
level
well
usual
transaction
management
support
separate
databases
vehicles
equipment
maps
@@@@@@@@@@
Chapter
Software
reuse
Elicit
stakeholder
requirements
Choose
closest
fit
system
instance
Deliver
new
system
instance
Renegotiate
requirements
Adapt
existing
system
Figure
Product
instance
development
create
new
instance
system
modify
individual
components
example
police
large
number
vehicles
relatively
small
number
vehicle
types
contrast
fire
service
many
types
specialized
vehicles
relatively
vehicles
Therefore
implementing
system
different
services
define
different
vehicle
database
structure
Various
types
specialization
software
product
line
developed
Platform
specialization
Versions
application
developed
different
platforms
example
versions
application
exist
Windows
Mac
OS
Linux
platforms
case
functionality
application
normally
unchanged
components
interface
hardware
operating
system
modified
Environment
specialization
Versions
application
created
handle
different
operating
environments
peripheral
devices
example
system
emergency
services
exist
different
versions
depending
communications
hardware
used
service
example
police
radios
built
encryption
used
product
line
components
changed
reflect
functionality
characteristics
equipment
used
Functional
specialization
Versions
application
created
specific
customers
different
requirements
example
library
automation
system
modified
depending
used
public
library
reference
library
university
library
case
components
implement
functionality
modified
new
components
added
system
Process
specialization
system
adapted
cope
specific
business
processes
example
ordering
system
adapted
cope
centralized
ordering
process
one
company
distributed
process
another
Figure
shows
process
extending
software
product
line
create
new
application
activities
process
Elicit
stakeholder
requirements
start
normal
requirements
engineering
process
However
system
already
exists
demonstrate
system
stakeholders
experiment
expressing
requirements
modifications
functions
provided
@@@@@@@@@@
Software
product
lines
Select
existing
system
closest
fit
requirements
creating
new
member
product
line
start
nearest
product
instance
requirements
analyzed
family
member
closest
fit
chosen
modification
Renegotiate
requirements
details
required
changes
emerge
project
planned
requirements
renegotiated
customer
minimize
changes
made
base
application
Adapt
existing
system
New
modules
developed
existing
system
existing
system
modules
adapted
meet
new
requirements
Deliver
new
product
family
member
new
instance
product
line
delivered
customer
deployment
time
configuration
required
reflect
particular
environments
system
used
stage
document
key
features
used
basis
system
developments
future
create
new
member
product
line
find
compromise
reusing
much
generic
application
possible
satisfying
detailed
stakeholder
requirements
detailed
system
requirements
less
likely
existing
components
meet
requirements
However
stakeholders
willing
flexible
limit
system
modifications
required
usually
deliver
system
quickly
lower
cost
Software
product
lines
designed
reconfigurable
reconfiguration
involve
adding
removing
components
system
defining
parameters
constraints
system
components
including
knowledge
business
processes
configuration
occur
different
stages
development
process
Design
time
configuration
organization
developing
software
modifies
common
product
line
core
developing
selecting
adapting
components
create
new
system
customer
Deployment
time
configuration
generic
system
designed
configuration
customer
consultants
working
customer
Knowledge
customer
s
specific
requirements
system
s
operating
environment
embedded
configuration
data
used
generic
system
system
configured
design
time
supplier
starts
generic
system
existing
product
instance
modifying
extending
modules
system
supplier
creates
specific
system
delivers
required
customer
functionality
usually
involves
changing
extending
source
code
system
greater
flexibility
possible
deployment
time
configuration
@@@@@@@@@@
Chapter
Software
reuse
Configuration
database
System
database
Generic
system
Configuration
planning
tool
Figure
Deployment
time
configuration
Design
time
configuration
used
impossible
use
existing
deployment
time
configuration
facilities
system
develop
new
system
version
However
time
created
several
family
members
comparable
functionality
decide
refactor
core
product
line
include
functionality
implemented
several
application
family
members
make
new
functionality
configurable
system
deployed
Deployment
time
configuration
involves
using
configuration
tool
create
specific
system
configuration
recorded
configuration
database
set
configuration
files
Figure
executing
system
run
server
stand
alone
system
PC
consults
database
executing
functionality
specialized
execution
context
Several
levels
deployment
time
configuration
provided
system
Component
selection
select
modules
system
provide
required
functionality
example
patient
information
system
select
image
management
component
allows
link
medical
images
X
rays
CT
scans
etc
patient
s
medical
record
Workflow
rule
definition
define
workflows
information
processed
stage
stage
validation
rules
apply
information
entered
users
generated
system
Parameter
definition
specify
values
specific
system
parameters
reflect
instance
application
creating
example
specify
maximum
length
fields
data
input
user
characteristics
hardware
attached
system
Deployment
time
configuration
complex
large
systems
take
several
months
configure
test
system
customer
Large
configurable
systems
support
configuration
process
providing
software
tools
planning
tools
support
configuration
process
discuss
deployment
time
configuration
Section
discussion
covers
reuse
application
systems
configured
work
different
operational
environments
@@@@@@@@@@
Application
system
reuse
Application
system
reuse
application
system
product
software
system
adapted
needs
different
customers
without
changing
source
code
system
Application
systems
developed
system
vendor
general
market
specially
developed
individual
customer
system
products
sometimes
known
COTS
Commercial
Off
Shelf
System
products
However
term
COTS
mostly
used
military
systems
prefer
call
system
products
application
systems
Virtually
desktop
software
business
many
server
based
systems
application
systems
software
designed
general
use
includes
many
features
functions
therefore
potential
reused
different
environments
part
different
applications
Torchiano
Morisio
Torchiano
Morisio
discovered
open
source
products
often
used
without
change
without
looking
source
code
Application
system
products
adapted
using
built
configuration
mechanisms
allow
functionality
system
tailored
specific
customer
needs
example
hospital
patient
record
system
separate
input
forms
output
reports
defined
different
types
patients
configuration
features
allow
system
accept
plug
ins
extend
functionality
check
user
inputs
ensure
valid
approach
software
reuse
widely
adopted
large
companies
since
late
s
offers
significant
benefits
customized
software
development
types
reuse
rapid
deployment
reliable
system
possible
possible
see
functionality
provided
applications
easier
judge
likely
suitable
companies
already
use
applications
experience
systems
available
development
risks
avoided
using
existing
software
However
approach
risks
discuss
Businesses
focus
core
activity
without
devote
lot
resources
systems
development
operating
platforms
evolve
technology
updates
simplified
responsibility
application
system
vendor
rather
customer
course
approach
software
engineering
problems
Requirements
usually
adapted
reflect
functionality
mode
operation
off
shelf
application
system
lead
disruptive
changes
existing
business
processes
@@@@@@@@@@
Chapter
Software
reuse
Configurable
application
systems
Application
system
integration
Single
product
provides
functionality
Several
different
application
systems
required
customer
integrated
provide
customized
functionality
Figure
application
system
based
assumptions
practically
impos
Individual
sible
change
customer
therefore
adapt
business
reflect
integrated
application
systems
assumptions
Based
generic
solution
standardized
processes
Flexible
solutions
developed
customer
processes
Development
focus
system
configuration
Development
focus
system
integration
System
vendor
responsible
maintenance
System
owner
responsible
maintenance
System
vendor
provides
platform
system
System
owner
provides
platform
system
Choosing
right
application
system
enterprise
difficult
process
especially
many
systems
well
documented
Making
wrong
choice
means
impossible
make
new
system
work
required
lack
local
expertise
support
systems
development
Consequently
customer
rely
vendor
external
consultants
development
advice
advice
geared
selling
products
services
insufficient
time
taken
understand
real
needs
customer
system
vendor
controls
system
support
evolution
go
business
taken
make
changes
cause
difficulties
customers
Application
systems
used
individual
systems
combination
two
systems
integrated
Individual
systems
consist
generic
application
single
vendor
configured
customer
requirements
Integrated
systems
involve
integrating
functionality
individual
systems
often
different
vendors
create
new
application
system
Figure
summarizes
differences
different
approaches
discuss
application
system
integration
Section
Configurable
application
systems
Configurable
application
systems
generic
application
systems
designed
support
particular
business
type
business
activity
sometimes
complete
business
enterprise
example
system
produced
dentists
handle
appointments
reminders
dental
records
patient
recall
billing
larger
scale
Enterprise
Resource
Planning
ERP
system
support
manufacturing
ordering
customer
relationship
management
processes
large
company
Domain
specific
application
systems
systems
support
business
function
e
g
document
management
provide
functionality
likely
required
range
potential
users
However
incorporate
built
assumptions
@@@@@@@@@@
Application
system
reuse
System
database
Business
rules
Purchasing
Supply
chain
Logistics
CRM
Processes
Processes
Processes
Processes
Figure
architecture
ERP
system
users
work
assumptions
cause
problems
specific
situations
example
system
support
student
registration
university
assume
students
registered
one
degree
one
university
However
universities
collaborate
offer
joint
degrees
practically
impossible
represent
detail
system
Enterprise
Resource
Planning
ERP
systems
produced
SAP
Oracle
large
scale
integrated
systems
designed
support
business
practices
ordering
invoicing
inventory
management
manufacturing
scheduling
Monk
Wagner
configuration
process
systems
involves
gathering
detailed
information
customer
s
business
business
processes
embedding
information
configuration
database
often
requires
detailed
knowledge
configuration
notations
tools
usually
carried
consultants
working
alongside
system
customers
generic
ERP
system
includes
number
modules
composed
different
ways
create
system
customer
configuration
process
involves
choosing
modules
included
configuring
individual
modules
defining
business
processes
business
rules
defining
structure
organization
system
database
model
overall
architecture
ERP
system
supports
range
business
functions
shown
Figure
key
features
architecture
follows
number
modules
support
different
business
functions
large
grain
modules
support
entire
departments
divisions
business
example
shown
Figure
modules
selected
inclusion
system
module
support
purchasing
module
support
supply
chain
management
logistics
module
support
delivery
goods
customer
relationship
management
CRM
module
maintain
customer
information
defined
set
business
process
models
associated
module
relate
activities
module
example
ordering
process
model
define
orders
created
approved
specify
roles
activities
involved
placing
order
common
database
maintains
information
related
business
functions
Thus
necessary
replicate
information
customer
details
different
parts
business
@@@@@@@@@@
Chapter
Software
reuse
set
business
rules
apply
data
database
Therefore
data
input
one
function
rules
ensure
consistent
data
required
functions
example
business
rule
require
expense
claims
approved
someone
senior
person
making
claim
ERP
systems
used
large
companies
support
functions
therefore
widely
used
form
software
reuse
obvious
limitation
approach
reuse
functionality
customer
s
application
restricted
functionality
ERP
system
s
built
modules
company
needs
additional
functionality
develop
separate
add
system
provide
functionality
Furthermore
buyer
company
s
processes
operations
defined
ERP
system
s
configuration
language
language
embeds
understanding
business
processes
seen
system
vendor
mismatch
assumptions
concepts
processes
used
customer
s
business
serious
mismatch
customer
s
business
model
system
model
used
ERP
system
makes
highly
probable
ERP
system
meet
customer
s
real
needs
Scott
example
ERP
system
sold
university
fundamental
system
concept
notion
customer
system
customer
external
agent
bought
goods
services
supplier
concept
caused
great
difficulties
configuring
system
Universities
really
customers
Rather
customer
type
relationships
range
people
organizations
students
research
funding
agencies
educational
charities
None
relationships
compatible
customer
relationship
person
business
buys
products
services
another
particular
case
took
several
months
resolve
mismatch
final
solution
partially
met
university
s
requirements
ERP
systems
usually
require
extensive
configuration
adapt
requirements
organization
installed
configuration
involve
Selecting
required
functionality
system
example
deciding
modules
included
Establishing
data
model
defines
organization
s
data
structured
system
database
Defining
business
rules
apply
data
Defining
expected
interactions
external
systems
Designing
input
forms
output
reports
generated
system
Designing
new
business
processes
conform
underlying
process
model
supported
system
Setting
parameters
define
system
deployed
underlying
platform
@@@@@@@@@@
Application
system
reuse
configuration
settings
completed
new
system
ready
testing
Testing
major
problem
systems
configured
rather
pro
grammed
using
conventional
language
two
reasons
Test
automation
difficult
impossible
no
easy
access
API
used
testing
frameworks
JUnit
system
tested
manually
testers
inputting
test
data
system
Furthermore
systems
often
specified
informally
defining
test
cases
difficult
without
lot
help
end
users
Systems
errors
often
subtle
specific
business
processes
application
system
ERP
system
reliable
platform
technical
system
failures
rare
problems
occur
often
due
misunderstandings
configuring
system
user
stakeholders
System
testers
without
detailed
knowledge
end
user
processes
cannot
detect
errors
Integrated
application
systems
Integrated
application
systems
include
two
application
systems
sometimes
legacy
systems
use
approach
no
single
application
system
meets
needs
wish
integrate
new
application
system
systems
already
using
component
systems
interact
APIs
service
interfaces
defined
Alternatively
composed
connecting
output
one
system
input
another
updating
databases
used
applications
develop
integrated
application
systems
make
number
design
choices
individual
application
systems
offer
appropriate
functionality
Typically
several
system
products
available
combined
different
ways
don
t
already
experience
particular
application
system
difficult
decide
product
suitable
data
exchanged
Different
systems
normally
use
unique
data
structures
formats
write
adaptors
convert
one
representation
another
adaptors
runtime
systems
operate
alongside
constituent
application
systems
features
product
used
Individual
application
systems
include
functionality
need
functionality
duplicated
across
different
products
decide
features
product
appropriate
requirements
possible
deny
access
unused
functionality
interfere
normal
system
operation
@@@@@@@@@@
Chapter
Software
reuse
Client
Web
browser
Email
system
ServerE
commerce
system
Ordering
invoicing
system
Email
system
Adaptor
Adaptor
Figure
integrated
procurement
system
Consider
following
scenario
illustration
application
system
integration
large
organization
intends
develop
procurement
system
allows
staff
place
orders
desk
introducing
system
across
organization
company
estimates
save
million
per
year
centralizing
buying
new
procurement
system
ensure
orders
made
suppliers
offer
best
prices
reduce
administration
associated
orders
manual
systems
system
involves
choosing
goods
available
supplier
creating
order
order
approved
sending
order
supplier
receiving
goods
confirming
payment
made
company
legacy
ordering
system
used
central
procurement
office
order
processing
software
integrated
existing
invoicing
delivery
system
create
new
ordering
system
legacy
system
integrated
web
based
e
commerce
platform
email
system
handles
communications
users
structure
final
procurement
system
shown
Figure
procurement
system
client
server
system
standard
web
browsing
email
systems
used
client
server
e
commerce
platform
integrate
existing
ordering
system
adaptor
e
commerce
system
format
orders
confirmations
delivery
forth
converted
format
used
ordering
system
e
commerce
system
uses
email
system
send
notifications
users
ordering
system
never
designed
purpose
Therefore
another
adaptor
written
convert
notifications
ordering
system
email
messages
Months
sometimes
years
implementation
effort
saved
time
develop
deploy
system
drastically
reduced
integrating
existing
application
systems
procurement
system
described
implemented
deployed
large
company
nine
months
originally
estimated
take
three
years
develop
procurement
system
Java
integrated
legacy
ordering
system
@@@@@@@@@@
Application
system
reuse
Service
wrapper
Application
system
Figure
Application
wrapping
Services
Services
Application
system
integration
simplified
service
oriented
approach
used
Essentially
service
oriented
approach
means
allowing
access
application
system
s
functionality
standard
service
interface
service
discrete
unit
functionality
applications
offer
service
interface
sometimes
service
interface
implemented
system
integrator
Essentially
program
wrapper
hides
application
provides
externally
visible
services
Figure
approach
particularly
valuable
legacy
systems
integrated
newer
application
systems
principle
integrating
application
systems
integrating
component
understand
system
interfaces
use
exclusively
communicate
software
trade
off
specific
requirements
rapid
development
reuse
design
system
architecture
allows
application
systems
operate
together
However
fact
products
usually
large
systems
right
often
sold
separate
standalone
systems
introduces
additional
problems
Boehm
Abts
Boehm
Abts
highlight
four
important
system
integration
problems
Lack
control
functionality
performance
published
interface
product
appear
offer
required
facilities
system
properly
implemented
perform
poorly
product
hidden
operations
interfere
use
specific
situation
Fixing
problems
priority
system
integrator
real
concern
product
vendor
Users
simply
find
workarounds
problems
wish
reuse
application
system
Problems
system
interoperability
sometimes
difficult
get
individual
application
systems
work
together
system
embeds
assumptions
used
Garlan
et
al
Garlan
Allen
Ockerbloom
reporting
experience
integrating
four
application
systems
found
three
products
event
based
used
different
model
events
system
assumed
exclusive
access
event
queue
consequence
integration
difficult
project
@@@@@@@@@@
Chapter
Software
reuse
required
five
times
much
effort
originally
predicted
schedule
extended
two
years
rather
predicted
six
months
retrospective
analysis
work
years
later
Garlan
et
al
Garlan
Allen
Ockerbloom
concluded
integration
problems
discovered
solved
Torchiano
Morisio
Torchiano
Morisio
found
lack
compliance
standards
many
application
systems
meant
integration
difficult
anticipated
No
control
system
evolution
Vendors
application
systems
make
decisions
system
changes
response
market
pressures
PC
products
particular
new
versions
often
produced
frequently
compatible
previous
versions
New
versions
additional
unwanted
functionality
previous
versions
unavailable
unsupported
Support
system
vendors
level
support
available
system
vendors
varies
widely
Vendor
support
particularly
important
problems
arise
developers
access
source
code
detailed
documentation
system
vendors
commit
providing
support
changing
market
economic
circumstances
make
difficult
deliver
commitment
example
system
vendor
decide
discontinue
product
limited
demand
taken
another
company
wish
support
products
acquired
Boehm
Abts
reckon
many
cases
cost
system
maintenance
evolution
greater
integrated
application
systems
difficulties
life
cycle
problems
don
t
affect
initial
development
system
removed
people
involved
system
maintenance
original
system
developers
likely
difficulties
arise
integrated
system
Key
Points
many
different
ways
reuse
software
range
reuse
classes
methods
libraries
reuse
complete
application
systems
advantages
software
reuse
lower
costs
faster
software
development
lower
risks
System
dependability
increased
Specialists
used
effectively
concentrating
expertise
design
reusable
components
Application
frameworks
collections
concrete
abstract
objects
designed
reuse
specialization
addition
new
objects
usually
incorporate
good
design
practice
design
patterns
@@@@@@@@@@
Chapter
Website
Software
product
lines
related
applications
developed
one
base
applications
generic
system
adapted
specialized
meet
specific
requirements
functionality
target
platform
operational
configuration
Application
system
reuse
concerned
reuse
large
scale
off
shelf
systems
provide
lot
functionality
reuse
radically
reduce
costs
development
time
Systems
developed
configuring
single
generic
application
system
integrating
two
application
systems
Potential
problems
application
system
reuse
include
lack
control
functionality
performance
system
evolution
need
support
external
vendors
difficulties
ensuring
systems
interoperate
reAding
Overlooked
Aspects
COTS
Based
Development
interesting
article
discusses
survey
developers
using
COTS
based
approach
problems
encountered
M
Torchiano
M
Morisio
IEEE
Software
March
April
http
dx
doi
org
MS
CRUISE
Component
Reuse
Software
Engineering
e
book
covers
wide
range
reuse
topics
including
case
studies
component
based
reuse
reuse
processes
However
coverage
application
system
reuse
limited
L
Nascimento
et
al
http
www
academia
edu
C
R
U
S
E
Component
Reuse
Software
Engineering
Construction
Configuration
New
Challenge
Software
Engineering
invited
paper
discuss
problems
difficulties
constructing
new
application
configuring
existing
systems
Sommerville
Proc
th
Australian
Software
Engineering
Conference
http
dx
doi
org
ASWEC
Architectural
Mismatch
Reuse
Still
Hard
article
looks
back
earlier
paper
discussed
problems
reusing
integrating
number
application
systems
authors
concluded
progress
made
still
problems
conflicting
assumptions
made
designers
individual
systems
D
Garlan
et
al
IEEE
Software
July
August
http
dx
doi
org
MS
WebSiTe
PowerPoint
slides
chapter
www
pearsonglobaleditions
com
Sommerville
Links
supporting
videos
http
software
engineering
book
com
videos
software
reuse
@@@@@@@@@@
Chapter
Software
reuse
exerCiSeS
major
technical
nontechnical
factors
hinder
software
reuse
personally
reuse
much
software
List
benefits
software
reuse
explain
expected
lifetime
software
considered
planning
reuse
base
application
s
design
product
line
simplify
reuse
reconfiguration
Explain
meant
inversion
control
application
frameworks
Explain
approach
cause
problems
integrated
two
separate
systems
originally
created
using
application
framework
Using
example
weather
station
system
described
Chapters
suggest
product
line
architecture
family
applications
concerned
remote
monitoring
data
collection
present
architecture
layered
model
showing
components
included
level
desktop
software
word
processing
software
configured
number
different
ways
Examine
software
regularly
use
list
configuration
options
software
Suggest
difficulties
users
configuring
software
Microsoft
Office
one
open
source
alternatives
good
example
use
exercise
many
large
companies
chosen
ERP
systems
basis
organizational
information
system
problems
arise
deploying
large
scale
ERP
system
organization
significant
benefits
offered
application
system
reuse
approach
compared
custom
software
development
approach
Explain
adaptors
usually
needed
systems
constructed
integrating
application
systems
Suggest
three
practical
problems
arise
writing
adaptor
software
link
two
application
systems
reuse
software
raises
number
copyright
intellectual
property
issues
customer
pays
software
contractor
develop
system
right
reuse
developed
code
software
contractor
right
use
code
basis
generic
component
payment
mechanisms
used
reimburse
providers
reusable
components
Discuss
issues
ethical
issues
associated
reuse
software
reFerenCeS
Baumer
D
G
Gryczan
R
Knoll
C
Lilienthal
D
Riehle
H
Zullighoven
Framework
Development
Large
Systems
Comm
ACM
doi
Boehm
B
C
Abts
COTS
Integration
Plug
Pray
Computer
doi
Fayad
M
E
D
C
Schmidt
Object
Oriented
Application
Frameworks
Comm
ACM
doi
@@@@@@@@@@
Chapter
References
Gamma
E
R
Helm
R
Johnson
J
Vlissides
Design
Patterns
Elements
Reusable
Object
Oriented
Software
Reading
MA
Addison
Wesley
Garlan
D
R
Allen
J
Ockerbloom
Architectural
Mismatch
Reuse
Hard
IEEE
Software
doi
Architectural
Mismatch
Reuse
Still
Hard
IEEE
Software
doi
MS
Holdener
T
Ajax
Definitive
Guide
Sebastopol
CA
O
Reilly
Associates
Jacobsen
M
Griss
P
Jonsson
Software
Reuse
Reading
MA
Addison
Wesley
Monk
E
B
Wagner
Concepts
Enterprise
Resource
Planning
th
ed
Independence
KY
CENGAGE
Learning
Sarris
S
HTML
Unleashed
Indianapolis
Sams
Publishing
Schmidt
D
C
Gokhale
B
Natarajan
Leveraging
Application
Frameworks
ACM
Queue
July
August
doi
Scott
J
E
FoxMeyer
Drug
s
Bankruptcy
Failure
ERP
Proc
Association
Information
Systems
th
Americas
Conf
Information
Systems
Milwaukee
WI
http
www
uta
edu
faculty
weltman
OPMA
TW
FoxMeyer
pdf
Torchiano
M
M
Morisio
Overlooked
Aspects
COTS
Based
Development
IEEE
Software
doi
MS
@@@@@@@@@@
Component
based
software
engineering
Objectives
objective
chapter
describe
approach
software
reuse
based
composition
standardized
reusable
components
read
chapter
understand
meant
software
component
included
program
executable
element
understand
key
elements
software
component
models
support
provided
middleware
models
aware
key
activities
component
based
software
engineering
CBSE
process
reuse
CBSE
process
reuse
understand
three
different
types
component
composition
problems
resolved
components
composed
create
new
components
systems
Contents
Components
component
models
CBSE
processes
Component
composition
@@@@@@@@@@
Chapter
Component
based
software
engineering
Component
based
software
engineering
CBSE
emerged
late
s
approach
software
systems
development
based
reusing
software
components
creation
motivated
frustration
object
oriented
development
led
extensive
reuse
originally
suggested
Single
object
classes
detailed
specific
often
bound
application
compile
time
detailed
knowledge
classes
use
usually
meant
component
source
code
Selling
distributing
objects
individual
reusable
components
therefore
practically
impossible
Components
higher
level
abstractions
objects
defined
interfaces
usually
larger
individual
objects
implementation
details
hidden
components
Component
based
software
engineering
process
defining
implementing
integrating
composing
loosely
coupled
independent
components
systems
CBSE
important
software
development
approach
large
scale
enterprise
systems
demanding
performance
security
requirements
Customers
demanding
secure
dependable
software
delivered
deployed
quickly
way
demands
met
build
software
reusing
existing
components
essentials
component
based
software
engineering
Independent
components
completely
specified
interfaces
clear
separation
component
interface
implementation
means
one
implementation
component
replaced
another
without
need
change
parts
system
Component
standards
define
interfaces
facilitate
integration
components
standards
embodied
component
model
define
minimum
component
interfaces
specified
components
communicate
models
go
much
define
interfaces
implemented
conformant
components
components
conform
standards
operation
independent
programming
language
Components
written
different
languages
integrated
system
Middleware
provides
software
support
component
integration
make
independent
distributed
components
work
together
need
middleware
support
handles
component
communications
Middleware
component
support
handles
low
level
issues
efficiently
allows
focus
application
related
problems
addition
middleware
component
support
provide
support
resource
allocation
transaction
management
security
concurrency
development
process
geared
component
based
software
engineering
need
development
process
allows
requirements
evolve
depending
functionality
available
components
Component
based
development
embodies
good
software
engineering
practice
often
makes
sense
design
system
using
components
even
develop
@@@@@@@@@@
Chapter
Component
based
software
engineering
Problems
CBSE
CBSE
now
mainstream
approach
software
engineering
widely
used
creating
new
systems
However
used
approach
reuse
problems
include
component
trustworthiness
component
certification
requirements
compromises
prediction
properties
components
especially
integrated
components
http
software
engineering
book
com
web
cbse
problems
rather
reuse
components
Underlying
CBSE
sound
design
principles
support
construction
understandable
maintainable
software
Components
independent
interfere
s
operation
Implementation
details
hidden
component
s
implementation
changed
without
affecting
rest
system
Components
communicate
well
defined
interfaces
interfaces
maintained
one
component
replaced
another
component
providing
additional
enhanced
functionality
Component
infrastructures
offer
range
standard
services
used
application
systems
reduces
amount
new
code
developed
initial
motivation
CBSE
need
support
reuse
distributed
software
engineering
component
seen
element
software
system
accessed
using
remote
procedure
call
mechanism
components
running
separate
computers
system
reused
component
incorporate
copy
component
idea
component
extended
notion
distributed
objects
defined
distributed
systems
models
CORBA
specification
Pope
Several
different
protocols
technology
specific
standards
introduced
support
view
component
including
Sun
s
Enterprise
Java
Beans
EJB
Microsoft
s
COM
NET
CORBA
s
CCM
Lau
Wang
Unfortunately
companies
involved
proposing
standards
agree
single
standard
components
thereby
limiting
impact
approach
software
reuse
impossible
components
developed
using
different
approaches
work
together
Components
developed
different
platforms
NET
J
EE
cannot
interoperate
Furthermore
standards
protocols
proposed
complex
difficult
understand
barrier
adoption
response
problems
notion
component
service
developed
standards
proposed
support
service
oriented
software
engineering
significant
difference
component
service
original
notion
component
services
stand
alone
entities
external
program
using
build
service
oriented
system
reference
external
service
rather
including
copy
service
system
Service
oriented
software
engineering
type
component
based
software
engineering
uses
simpler
notion
component
originally
proposed
CBSE
@@@@@@@@@@
Components
component
models
components
executable
routines
included
larger
systems
system
used
component
embedded
version
component
Service
oriented
approaches
gradually
replacing
CBSE
embedded
components
approach
systems
development
chapter
discuss
use
CBSE
embedded
components
service
oriented
software
engineering
covered
Chapter
Components
component
models
software
reuse
community
generally
agrees
component
independent
software
unit
composed
components
create
software
system
Beyond
however
people
proposed
varying
definitions
software
component
Councill
Heineman
Councill
Heineman
define
component
software
element
conforms
standard
component
model
independently
deployed
composed
without
modification
according
composition
standard
definition
standards
based
software
unit
conforms
standards
component
Szyperski
Szyperski
however
mention
standards
definition
component
focuses
instead
key
characteristics
components
software
component
unit
composition
contractually
specified
interfaces
explicit
context
dependencies
software
component
deployed
independently
subject
composition
third
parties
definitions
developed
around
idea
component
element
embedded
system
rather
service
referenced
system
However
equally
applicable
service
components
Szyperski
states
component
no
externally
observable
state
copies
components
indistinguishable
However
component
models
Enterprise
Java
Beans
model
allow
stateful
components
correspond
Szyperski
s
definition
stateless
components
certainly
simpler
use
systems
stateful
components
convenient
reduce
system
complexity
definitions
common
agree
components
independent
fundamental
unit
composition
system
think
combine
proposals
get
rounded
description
reusable
component
Figure
shows
consider
essential
characteristics
component
used
CBSE
Councill
W
T
G
T
Heineman
Definition
Software
Component
Elements
Component
Based
Software
Engineering
edited
G
T
Heineman
W
T
Councill
Boston
Addison
Wesley
Szyperski
C
Component
Software
Beyond
Object
Oriented
Programming
nd
Ed
Harlow
UK
Addison
Wesley
@@@@@@@@@@
Component
characteristic
Description
Component
characteristic
Description
Composable
Figure
Component
characteristics
Deployable
Documented
Independent
Standardized
component
composable
external
interactions
take
place
publicly
defined
interfaces
addition
provide
external
access
information
methods
attributes
deployable
component
self
contained
able
operate
stand
alone
entity
component
platform
provides
implementation
component
model
usually
means
component
binary
compiled
deployed
component
implemented
service
deployed
user
component
Rather
deployed
service
provider
Components
fully
documented
potential
users
decide
components
meet
needs
syntax
ideally
semantics
component
interfaces
specified
component
independent
possible
compose
deploy
without
use
specific
components
situations
component
needs
externally
provided
services
explicitly
set
requires
interface
specification
Component
standardization
means
component
used
CBSE
process
conform
standard
component
model
model
define
component
interfaces
component
metadata
documentation
composition
deployment
useful
way
thinking
component
provider
one
services
even
component
embedded
rather
implemented
service
system
needs
something
done
calls
component
provide
service
without
caring
component
executing
programming
language
used
develop
component
example
component
system
used
public
library
provide
search
service
allows
users
search
library
catalog
component
converts
one
graphical
format
another
e
g
TIFF
JPEG
provides
data
conversion
service
Viewing
component
service
provider
emphasizes
two
critical
characteristics
reusable
component
component
independent
executable
entity
defined
interfaces
don
t
need
knowledge
source
code
use
referenced
external
service
included
directly
program
services
offered
component
made
available
interface
interactions
interface
component
interface
expressed
terms
parameterized
operations
internal
state
never
exposed
principle
components
two
related
interfaces
shown
Figure
interfaces
reflect
services
component
provides
services
component
requires
operate
correctly
provides
interface
defines
services
provided
component
interface
component
API
defines
methods
called
user
@@@@@@@@@@
Figure
Component
interfaces
Figure
model
data
collector
component
Requires
interface
Component
Provides
interface
Defines
services
Defines
services
needed
provided
provided
component
components
components
component
UML
component
diagram
provides
interface
component
indicated
circle
end
line
component
icon
requires
interface
specifies
services
components
system
provide
component
operate
correctly
services
available
component
work
compromise
independence
deployability
component
requires
interface
define
services
provided
UML
symbol
requires
interface
semicircle
end
line
component
icon
Notice
provides
requires
interface
icons
fit
together
like
ball
socket
illustrate
interfaces
Figure
shows
model
component
designed
collect
collate
information
array
sensors
runs
autonomously
collect
data
period
time
request
provides
collated
data
calling
component
provides
interface
includes
methods
add
remove
start
stop
test
sensors
report
method
returns
sensor
data
collected
listAll
method
provides
information
attached
sensors
shown
methods
associated
parameters
specifying
sensor
identifiers
locations
requires
interface
used
connect
component
sensors
assumes
sensors
data
interface
accessed
sensorData
management
interface
accessed
sensorManagement
interface
designed
connect
different
types
sensors
include
specific
sensor
operations
Test
provideReading
Instead
commands
used
specific
type
sensor
embedded
string
parameter
operations
requires
interface
Adaptor
components
parse
parameter
string
translate
embedded
commands
specific
control
interface
type
sensor
discuss
use
adaptors
later
chapter
show
data
collector
component
connected
sensor
Figure
Requires
interface
Provides
interface
Data
collector
addSensor
removeSensor
sensorManagement
startSensor
stopSensor
sensorData
testSensor
initialize
report
listAll
@@@@@@@@@@
Components
objects
Components
often
implemented
object
oriented
languages
cases
accessing
provides
interface
component
done
method
calls
However
components
object
classes
thing
Unlike
object
classes
components
independently
deployable
define
types
language
independent
based
standard
component
model
http
software
engineering
book
com
web
components
objects
Components
accessed
using
remote
procedure
calls
RPCs
component
unique
identifier
using
name
called
another
computer
called
component
uses
mechanism
access
required
components
defined
interface
important
difference
component
external
service
component
program
element
accessed
using
remote
procedure
call
services
completely
independent
entities
explicit
requires
interface
course
require
components
support
operation
provided
internally
programs
use
services
without
need
implement
additional
support
required
service
Component
models
component
model
definition
standards
component
implementation
documentation
deployment
standards
component
developers
ensure
components
interoperate
providers
component
execution
infrastructures
provide
middleware
support
component
operation
service
components
important
component
model
Web
Service
models
embedded
components
widely
used
models
include
Enterprise
Java
Beans
EJB
model
Microsoft
s
NET
model
Lau
Wang
basic
elements
ideal
component
model
discussed
Weinreich
Sametinger
Weinreich
Sametinger
summarize
model
elements
Figure
diagram
shows
elements
component
model
define
component
interfaces
information
need
use
component
program
component
deployed
Interfaces
Components
defined
specifying
interfaces
component
model
specifies
interfaces
defined
elements
operation
names
parameters
exceptions
included
interface
definition
model
specify
language
used
define
component
interfaces
web
services
interface
specification
uses
XML
based
languages
discussed
Chapter
EJB
Java
specific
Java
used
interface
definition
language
NET
interfaces
defined
using
Microsoft
s
Common
@@@@@@@@@@
Customization
Component
model
Interfaces
Usage
information
Deployment
use
Interface
definition
Specific
interfaces
Composition
Naming
convention
Meta
data
access
Packaging
Documentation
Evolution
support
Figure
Basic
elements
component
model
Intermediate
Language
CIL
component
models
require
specific
interfaces
defined
component
used
compose
component
component
model
infrastructure
provides
standardized
services
security
transaction
management
Usage
order
components
distributed
accessed
remotely
via
RPCs
need
unique
name
handle
associated
globally
unique
example
EJB
hierarchical
name
generated
root
based
Internet
domain
name
Services
unique
URI
Uniform
Resource
Identifier
Component
meta
data
data
component
information
interfaces
attributes
meta
data
important
allows
users
component
find
services
provided
required
Component
model
implementations
normally
include
specific
ways
use
reflection
interface
Java
access
component
meta
data
Components
generic
entities
deployed
configured
fit
application
system
example
configure
Data
collector
component
Figure
defining
maximum
number
sensors
sensor
array
component
model
therefore
specify
binary
components
customized
particular
deployment
environment
Deployment
component
model
includes
specification
components
packaged
deployment
independent
executable
routines
components
independent
entities
packaged
supporting
software
provided
component
infrastructure
defined
requires
interface
Deployment
information
includes
information
contents
package
binary
organization
Inevitably
new
requirements
emerge
components
changed
replaced
component
model
therefore
include
rules
governing
component
replacement
allowed
Finally
component
model
define
component
documentation
produced
used
find
component
decide
appropriate
@@@@@@@@@@
Support
services
Security
Transaction
management
Concurrency
Component
management
Persistence
Resource
management
Support
services
Security
Transaction
management
Concurrency
Component
management
Persistence
Resource
management
Platform
services
Figure
Middleware
services
defined
Addressing
Interface
definition
Exception
management
Component
communications
component
model
components
executable
routines
rather
external
services
component
model
defines
services
provided
middleware
supports
executing
components
Weinreich
Sametinger
use
analogy
operating
system
explain
component
models
operating
system
provides
set
generic
services
used
applications
component
model
implementation
provides
comparable
shared
services
components
Figure
shows
services
provided
implementation
component
model
services
provided
component
model
implementation
fall
two
categories
Platform
services
enable
components
communicate
interoperate
distributed
environment
fundamental
services
available
component
based
systems
Support
services
common
services
many
different
components
likely
require
example
many
components
require
authentication
ensure
user
component
services
authorized
makes
sense
provide
standard
set
middleware
services
use
components
reduces
costs
component
development
potential
component
incompatibilities
avoided
Middleware
implements
common
component
services
provides
interfaces
make
use
services
provided
component
model
infrastructure
think
components
deployed
container
container
implementation
support
services
plus
definition
interfaces
component
provide
integrate
container
Conceptually
add
component
container
component
access
support
services
container
access
component
interfaces
use
component
interfaces
accessed
directly
components
accessed
container
interface
invokes
code
access
interface
embedded
component
Containers
large
complex
deploy
component
container
get
access
middleware
services
However
simple
components
@@@@@@@@@@
need
facilities
offered
supporting
middleware
approach
taken
web
services
common
service
provision
therefore
rather
different
web
services
standards
defined
common
services
transaction
management
security
standards
implemented
program
libraries
implementing
service
component
use
common
services
need
services
associated
component
model
much
common
facilities
provided
object
oriented
frameworks
discussed
Chapter
services
provided
comprehensive
framework
services
often
efficient
container
based
services
consequence
people
think
best
use
frameworks
SPRING
Wheeler
White
Java
development
rather
fully
featured
component
model
EJB
CBSE
processes
CBSE
processes
software
processes
support
component
based
software
engineering
take
account
possibilities
reuse
different
process
activities
involved
developing
using
reusable
components
Figure
Kotonya
presents
overview
processes
CBSE
highest
level
two
types
CBSE
processes
Development
reuse
process
concerned
developing
components
services
reused
applications
usually
involves
generalizing
existing
components
Development
reuse
process
process
developing
new
applications
using
existing
components
services
processes
different
objectives
therefore
include
different
activities
development
reuse
process
objective
produce
one
reusable
components
know
components
working
access
source
code
generalize
development
reuse
don
t
know
components
available
need
discover
components
design
system
make
effective
use
access
component
source
code
see
Figure
basic
processes
CBSE
reuse
supporting
processes
concerned
component
acquisition
component
management
component
certification
Component
acquisition
process
acquiring
components
reuse
development
reusable
component
involve
accessing
locally
developed
components
services
finding
components
external
source
@@@@@@@@@@
CBSE
processes
CBSE
reuse
CBSE
reuse
Component
acquisition
Component
certification
Component
repository
Specifier
Designer
Integrator
Maintainer
Librarian
Vendor
Broker
Component
management
Librarian
Local
external
certifier
External
source
Domain
analyst
Designer
Implementor
Maintainer
Market
analyst
Figure
CBSE
processes
Component
management
concerned
managing
company
s
reusable
components
ensuring
properly
catalogued
stored
made
available
reuse
Component
certification
process
checking
component
certifying
meets
specification
Components
maintained
organization
stored
component
repository
includes
components
information
use
CBSE
reuse
CBSE
reuse
process
developing
reusable
components
making
available
reuse
component
management
system
vision
early
supporters
CBSE
Szyperski
thriving
component
marketplace
develop
specialist
component
providers
component
vendors
organize
sale
components
different
developers
Software
developers
buy
components
include
system
pay
services
used
However
vision
realized
relatively
component
suppliers
buying
off
shelf
components
uncommon
Consequently
CBSE
reuse
mostly
used
organizations
made
commitment
reuse
driven
software
engineering
companies
base
internally
developed
components
reused
However
internally
developed
components
reusable
without
change
often
include
application
specific
features
interfaces
unlikely
required
programs
component
reused
@@@@@@@@@@
make
components
reusable
adapt
extend
application
specific
components
create
generic
therefore
reusable
versions
Obviously
adaptation
associated
cost
decide
first
component
likely
reused
second
cost
savings
future
reuse
justify
costs
making
component
reusable
answer
first
questions
decide
component
implements
one
stable
domain
abstractions
Stable
domain
abstractions
fundamental
elements
application
domain
change
slowly
example
banking
system
domain
abstractions
include
accounts
account
holders
statements
hospital
management
system
domain
abstractions
include
patients
treatments
nurses
domain
abstractions
sometimes
called
business
objects
component
implementation
commonly
used
domain
abstraction
group
related
business
objects
probably
reused
answer
question
cost
effectiveness
assess
costs
changes
required
make
component
reusable
costs
costs
component
documentation
component
validation
making
component
generic
Changes
make
component
make
reusable
include
removing
application
specific
methods
changing
names
make
general
adding
methods
provide
complete
functional
coverage
making
exception
handling
consistent
methods
adding
configuration
interface
allow
component
adapted
different
situations
use
integrating
required
components
increase
independence
problem
exception
handling
difficult
one
principle
components
handle
exceptions
application
requirements
exception
management
Rather
component
define
exceptions
arise
publish
exceptions
part
interface
example
simple
component
implementing
stack
data
structure
detect
publish
stack
overflow
stack
underflow
exceptions
practice
however
two
problems
process
Publishing
exceptions
leads
bloated
interfaces
harder
understand
put
off
potential
users
component
operation
component
depend
local
exception
handling
changing
serious
implications
functionality
component
therefore
take
pragmatic
approach
component
exception
handling
Common
technical
exceptions
recovery
important
functioning
component
handled
locally
exceptions
handled
@@@@@@@@@@
documented
component
exceptions
related
business
function
component
passed
calling
component
handling
Mili
et
al
Mili
et
al
discuss
ways
estimating
costs
making
component
reusable
returns
investment
benefits
reusing
rather
redeveloping
component
simply
productivity
gains
quality
gains
reused
component
dependable
time
market
gains
increased
returns
accrue
deploying
software
quickly
Mili
et
al
present
various
formulas
estimating
gains
COCOMO
model
discussed
Chapter
However
parameters
formulas
difficult
estimate
accurately
formulas
adapted
local
circumstances
making
difficult
use
suspect
software
project
managers
use
models
estimate
return
investment
component
reusability
component
reusable
depends
application
domain
functionality
generality
domain
general
one
component
implements
standard
functionality
domain
likely
reusable
add
generality
component
increase
reusability
applied
wider
range
environments
Unfortunately
normally
means
component
operations
complex
makes
component
harder
understand
use
therefore
trade
off
reusability
understandability
component
make
component
reusable
provide
set
generic
interfaces
operations
cater
ways
component
used
Reusability
adds
complexity
reduces
component
understandability
makes
difficult
time
consuming
decide
component
suitable
reuse
time
involved
understanding
reusable
component
sometimes
cost
effective
reimplement
simpler
component
specific
functionality
required
potential
source
components
legacy
systems
discussed
Chapter
legacy
systems
systems
fulfill
important
business
function
written
using
obsolete
software
technologies
result
difficult
use
new
systems
However
convert
old
systems
components
functionality
reused
new
applications
course
legacy
systems
normally
clearly
defined
requires
provides
interfaces
make
components
reusable
create
wrapper
defines
component
interfaces
wrapper
hides
complexity
underlying
code
provides
interface
external
components
access
services
provided
wrapper
fairly
complex
piece
software
cost
wrapper
development
significantly
less
cost
reimplementing
legacy
system
developed
tested
reusable
component
service
managed
future
reuse
Management
involves
deciding
classify
component
discovered
making
component
available
repository
service
maintaining
information
use
component
keeping
track
different
component
versions
component
open
source
make
available
public
repository
GitHub
Sourceforge
intended
use
company
use
internal
repository
system
@@@@@@@@@@
Identify
candidate
components
Outline
system
requirements
Modify
requirements
according
discovered
components
Architectural
design
Compose
components
create
system
Identify
candidate
componentsFigure
CBSE
reuse
Identify
candidate
components
Outline
system
requirements
Modify
requirements
according
discovered
components
Architectural
design
Compose
components
create
system
Identify
candidate
componentsFigure
CBSE
reuse
company
reuse
program
carry
form
component
certification
component
made
available
reuse
Certification
means
someone
apart
developer
checks
quality
component
test
component
certify
reached
acceptable
quality
standard
made
available
reuse
However
process
expensive
many
companies
simply
leave
testing
quality
checking
component
developers
CBSE
reuse
successful
reuse
components
requires
development
process
tailored
including
reusable
components
software
developed
CBSE
reuse
process
include
activities
find
integrate
reusable
components
structure
process
discussed
Chapter
Figure
shows
principal
activities
process
activities
initial
discovery
user
requirements
carried
way
software
processes
However
essential
differences
CBSE
reuse
software
processes
original
software
development
follows
user
requirements
initially
developed
outline
rather
detail
stakeholders
encouraged
flexible
possible
defining
requirements
Requirements
specific
limit
number
components
meet
requirements
However
unlike
incremental
development
need
complete
description
requirements
identify
many
components
possible
reuse
Requirements
refined
modified
early
process
depending
components
available
user
requirements
cannot
satisfied
available
components
discuss
related
requirements
supported
reusable
components
Users
willing
change
minds
means
cheaper
quicker
system
delivery
component
search
design
refinement
activity
system
architecture
designed
Apparently
usable
components
turn
@@@@@@@@@@
Figure
component
identification
process
ComponentselectionComponentsearchComponentvalidation
unsuitable
work
properly
chosen
components
find
alternatives
components
requirements
changes
therefore
necessary
depending
functionality
components
Development
composition
process
discovered
components
integrated
involves
integrating
components
component
model
infrastructure
often
developing
adaptors
reconcile
interfaces
incompatible
components
course
additional
functionality
required
provided
reused
components
architectural
design
stage
particularly
important
Jacobsen
et
al
Jacobsen
Griss
Jonsson
found
defining
robust
architecture
critical
successful
reuse
architectural
design
activity
choose
component
model
implementation
platform
However
many
companies
standard
development
platform
e
g
NET
component
model
predetermined
discussed
Chapter
establish
high
level
architecture
system
stage
make
decisions
system
distribution
control
activity
unique
CBSE
process
identifying
candidate
components
services
reuse
involves
number
subactivities
shown
Figure
Initially
focus
search
selection
need
convince
components
available
meet
requirements
Obviously
initial
checking
component
suitable
detailed
testing
required
later
stage
system
architecture
designed
spend
time
component
validation
need
confident
identified
components
really
suited
application
repeat
search
selection
processes
first
step
identifying
components
look
components
available
company
trusted
suppliers
component
vendors
likely
looking
components
developed
organization
repositories
open
source
software
available
Software
development
companies
build
database
reusable
components
without
risks
inherent
using
components
external
suppliers
Alternatively
decide
search
code
libraries
available
web
Sourceforge
GitHub
Google
Code
see
source
code
component
need
available
component
search
process
identified
possible
components
select
candidate
components
assessment
cases
straightforward
task
Components
list
directly
implement
user
requirements
competing
components
match
requirements
cases
however
selection
process
complex
clear
mapping
requirements
onto
components
find
several
components
integrated
meet
@@@@@@@@@@
Ariane
launcher
failure
developing
Ariane
space
launcher
designers
decided
reuse
inertial
reference
software
performed
successfully
Ariane
launcher
inertial
reference
software
maintains
stability
rocket
designers
decided
reuse
without
change
components
included
additional
functionality
required
Ariane
first
launch
Ariane
inertial
navigation
software
failed
rocket
controlled
rocket
payload
destroyed
cause
problem
unhandled
exception
conversion
fixed
point
number
integer
resulted
numeric
overflow
caused
runtime
system
shut
inertial
reference
system
launcher
stability
maintained
fault
never
occurred
Ariane
less
powerful
engines
value
converted
large
enough
conversion
overflow
illustrates
important
problem
software
reuse
Software
based
assumptions
context
system
used
assumptions
valid
different
situation
information
failure
available
http
software
engineering
book
com
case
studies
ariane
Figure
example
validation
failure
reused
software
specific
requirement
group
requirements
therefore
decide
component
compositions
provide
best
coverage
requirements
selected
components
possible
inclusion
system
validate
check
behave
advertised
extent
validation
required
depends
source
components
using
component
developed
known
trusted
source
decide
component
testing
unnecessary
simply
test
component
integrated
components
hand
using
component
unknown
source
check
test
component
including
system
Component
validation
involves
developing
set
test
cases
component
possibly
extending
test
cases
supplied
component
developing
test
harness
run
component
tests
major
problem
component
validation
component
specification
sufficiently
detailed
allow
develop
complete
set
component
tests
Components
usually
specified
informally
formal
documentation
interface
specification
include
enough
information
develop
complete
set
tests
convince
component
s
advertised
interface
require
well
testing
component
reuse
require
check
component
include
malicious
code
functionality
don
t
need
Professional
developers
rarely
use
components
untrusted
sources
especially
sources
provide
source
code
Therefore
malicious
code
problem
usually
arise
However
reused
components
often
contain
functionality
don
t
need
check
functionality
interfere
use
component
problem
unnecessary
functionality
activated
component
no
effect
application
reusing
component
slow
component
cause
produce
surprising
results
exceptional
cases
cause
serious
system
failures
Figure
summarizes
situation
failure
reused
software
system
unnecessary
functionality
led
catastrophic
system
failure
@@@@@@@@@@
problem
Ariane
launcher
arose
assumptions
made
software
Ariane
invalid
Ariane
general
problem
reusable
components
originally
implemented
specific
application
environment
naturally
embed
assumptions
environment
assumptions
rarely
documented
component
reused
impossible
develop
tests
check
assumptions
still
valid
reusing
component
new
environment
discover
embedded
environmental
assumptions
use
component
operational
system
Component
composition
Component
composition
process
integrating
components
specially
written
glue
code
create
system
another
component
compose
components
several
different
ways
shown
Figure
left
right
diagrams
illustrate
sequential
composition
hierarchical
composition
additive
composition
discussion
assume
composing
two
components
B
create
new
component
Sequential
composition
sequential
composition
create
new
component
two
existing
components
calling
existing
components
sequence
think
composition
composition
provides
interfaces
services
offered
component
called
results
returned
used
call
services
offered
component
B
components
call
sequential
composition
called
external
application
type
composition
used
embedded
service
components
extra
glue
code
required
call
component
services
right
order
ensure
results
delivered
component
compatible
inputs
expected
component
B
glue
code
transforms
outputs
form
expected
component
B
Hierarchical
composition
type
composition
occurs
one
component
calls
directly
services
provided
another
component
component
calls
component
B
called
component
provides
services
required
calling
component
Therefore
provides
interface
called
component
compatible
requires
interface
calling
component
Component
calls
component
B
directly
interfaces
match
no
need
additional
code
However
mismatch
requires
interface
provides
interface
B
conversion
code
required
services
requires
interface
mode
composition
used
components
implemented
services
accessed
web
@@@@@@@@@@
AABBAB
AABBAB
Figure
Types
component
composition
Additive
composition
occurs
two
components
put
together
added
create
new
component
combines
functionality
provides
interface
requires
interface
new
component
combination
corresponding
interfaces
components
B
components
called
separately
external
interface
composed
component
called
order
B
dependent
call
type
composition
used
embedded
service
components
use
forms
component
composition
creating
system
cases
write
glue
code
links
components
example
sequential
composition
output
component
typically
becomes
input
component
B
need
intermediate
statements
call
component
collect
result
call
component
B
result
parameter
one
component
calls
another
need
introduce
intermediate
component
ensures
provides
interface
requires
interface
compatible
write
new
components
especially
composition
design
interfaces
components
compatible
components
system
therefore
easily
compose
components
single
unit
However
components
developed
independently
reuse
often
faced
interface
incompatibilities
means
interfaces
components
wish
compose
Three
types
incompatibility
occur
Parameter
incompatibility
operations
side
interface
name
parameter
types
number
parameters
different
Figure
location
parameter
returned
addressFinder
incompatible
parameters
required
displayMap
printMap
methods
mapDB
Operation
incompatibility
names
operations
provides
requires
interfaces
different
incompatibility
components
shown
Figure
Operation
incompleteness
provides
interface
component
subset
requires
interface
another
component
vice
versa
@@@@@@@@@@
Figure
Components
incompatible
interfaces
string
location
string
pn
phoneDatabase
string
command
string
owner
string
pn
addressFinder
string
propertyType
string
pn
displayMap
string
postCode
scale
printMap
string
postCode
scale
mapper
mapDB
string
command
cases
tackle
problem
incompatibility
writing
adaptor
reconciles
interfaces
two
components
reused
adaptor
component
converts
one
interface
another
precise
form
adaptor
depends
type
composition
Sometimes
next
example
adaptor
takes
result
one
component
converts
form
used
input
another
cases
adaptor
called
component
proxy
component
B
situation
occurs
wishes
call
B
details
requires
interface
match
details
provides
interface
B
adaptor
reconciles
differences
converting
input
parameters
required
input
parameters
B
calls
B
deliver
services
required
illustrate
adaptors
consider
two
simple
components
shown
Figure
interfaces
incompatible
part
system
used
emergency
services
emergency
operator
takes
call
phone
number
input
addressFinder
component
locate
address
using
mapper
component
operator
prints
map
sent
vehicle
dispatched
emergency
first
component
addressFinder
finds
address
matches
phone
number
return
owner
property
associated
phone
number
type
property
mapper
component
takes
post
code
United
States
standard
ZIP
code
additional
four
digits
identifying
property
location
displays
prints
street
map
area
around
code
specified
scale
components
composable
principle
property
location
includes
post
ZIP
code
However
write
adaptor
component
called
postCodeStripper
takes
location
data
addressFinder
strips
post
code
post
code
used
input
mapper
street
map
displayed
scale
following
code
example
sequential
composition
illustrates
sequence
calls
required
implement
process
address
addressFinder
location
phonenumber
postCode
postCodeStripper
getPostCode
address
mapper
displayMap
postCode
Another
case
adaptor
component
used
hierarchical
composition
one
component
wishes
make
use
another
incompatibility
@@@@@@@@@@
Figure
adaptor
linking
data
collector
sensor
Figure
Photo
library
composition
Data
collector
sensorManagement
sensorData
Adaptorsensor
stop
addSensor
start
removeSensor
startSensor
stopSensor
testSensor
getdata
initialize
report
listAll
provides
interface
requires
interface
components
composition
illustrated
use
adaptor
Figure
adaptor
used
link
data
collector
sensor
component
used
implementation
wilderness
weather
station
system
discussed
Chapter
sensor
data
collector
components
composed
using
adaptor
reconciles
requires
interface
data
collection
component
provides
interface
sensor
component
data
collector
component
designed
generic
requires
interface
supports
sensor
data
collection
sensor
management
operations
parameter
text
string
representing
specific
sensor
commands
example
issue
collect
command
say
sensorData
collect
shown
Figure
sensor
separate
operations
start
stop
getdata
adaptor
parses
input
string
identifies
command
e
g
collect
calls
Sensor
getdata
collect
sensor
value
returns
result
character
string
data
collector
component
interface
style
means
data
collector
interact
different
types
sensor
separate
adaptor
converts
sensor
commands
Data
collector
sensor
interface
implemented
type
sensor
discussion
component
composition
assumes
tell
component
documentation
interfaces
compatible
course
interface
definition
includes
operation
name
parameter
types
make
assessment
compatibility
However
depend
component
documentation
decide
interfaces
semantically
compatible
illustrate
problem
consider
composition
shown
Figure
components
used
implement
system
downloads
images
camera
stores
photograph
library
system
user
provide
additional
information
describe
catalog
photograph
avoid
clutter
shown
interface
addItem
Photo
retrieve
Library
catEntry
getCatalogEntry
adaptorImageManagergetImageUserInterface
@@@@@@@@@@
context
keyword
names
component
conditions
apply
context
addItem
preconditions
specify
true
execution
addItem
pre
PhotoLibrary
libSize
PhotoLibrary
retrieve
pid
null
postconditions
specify
true
execution
post
libSize
libSize
@pre
PhotoLibrary
retrieve
pid
p
PhotoLibrary
catEntry
pid
photodesc
context
delete
pre
PhotoLibrary
retrieve
pid
null
post
PhotoLibrary
retrieve
pid
null
PhotoLibrary
catEntry
pid
PhotoLibrary
catEntry
pid
@pre
PhotoLibrary
libSize
libSize
@pre
Figure
OCL
description
methods
Rather
simply
show
methods
needed
illustrate
com
Photo
Library
ponent
documentation
problem
methods
interface
Photo
Library
interface
public
void
addItem
Identifier
pid
Photograph
p
CatalogEntry
photodesc
public
Photograph
retrieve
Identifier
pid
public
CatalogEntry
catEntry
Identifier
pid
Assume
documentation
addItem
method
Photo
Library
method
adds
photograph
library
associates
photograph
identifier
catalog
descriptor
photograph
description
appears
explain
component
consider
following
questions
happens
photograph
identifier
already
associated
photograph
library
photograph
descriptor
associated
catalog
entry
well
photograph
delete
photograph
delete
catalog
information
enough
information
informal
description
addItem
answer
questions
course
possible
add
information
natural
language
description
method
general
best
way
resolve
ambiguities
use
formal
language
describe
interface
specification
shown
Figure
part
description
interface
Photo
Library
adds
information
informal
description
@@@@@@@@@@
Figure
shows
pre
postconditions
defined
notation
based
object
constraint
language
OCL
part
UML
Warmer
Kleppe
OCL
designed
describe
constraints
UML
object
models
allows
express
predicates
true
true
method
executed
true
method
executed
invariants
preconditions
postconditions
access
value
variable
operation
add
@pre
name
Therefore
using
age
example
age
age@pre
statement
means
value
age
operation
one
operation
OCL
based
approaches
primarily
used
model
based
software
engineering
add
semantic
information
UML
models
OCL
descriptions
used
drive
code
generators
model
driven
engineering
general
approach
derived
Meyer
s
Design
Contract
approach
Meyer
interfaces
obligations
communicating
objects
formally
specified
enforced
runtime
system
Meyer
suggests
using
Design
Contract
essential
develop
trusted
components
Meyer
Figure
shows
specification
addItem
delete
methods
Photo
Library
method
specified
indicated
keyword
context
pre
postconditions
keywords
pre
post
preconditions
addItem
state
photograph
library
identifier
photograph
entered
library
exist
assume
creating
library
adds
single
item
size
library
greater
zero
postconditions
addItem
state
size
library
increased
single
entry
made
retrieve
using
identifier
get
back
photograph
added
look
catalog
using
identifier
get
back
catalog
entry
made
specification
delete
provides
information
precondition
states
delete
item
library
deletion
photo
no
longer
retrieved
size
library
reduced
However
delete
delete
catalog
entry
still
retrieve
photo
deleted
reason
wish
maintain
information
catalog
photo
deleted
new
location
create
system
composing
components
find
potential
conflicts
functional
non
functional
requirements
need
deliver
system
quickly
possible
need
create
system
@@@@@@@@@@
Chapter
Component
based
software
engineering
Datacollection
b
DatamanagementReportgeneratorDatacollectionDatabaseReportReportFigure
Data
collection
report
generation
components
evolve
requirements
change
take
trade
offs
account
component
decisions
composition
components
effective
delivering
functional
requirements
system
composition
components
make
easier
adapt
composite
component
requirements
change
emergent
properties
composed
system
properties
include
performance
dependability
assess
properties
complete
system
implemented
Unfortunately
many
situations
solutions
composition
problems
conflict
example
consider
situation
illustrated
Figure
system
created
two
alternative
compositions
system
data
collection
reporting
system
data
collected
different
sources
stored
database
different
reports
summarizing
data
produced
potential
conflict
adaptability
performance
Composition
adaptable
composition
b
likely
faster
reliable
advantages
composition
reporting
data
management
separate
flexibility
future
change
data
management
system
replaced
reports
required
current
reporting
component
cannot
produce
component
replaced
without
change
data
management
component
composition
b
database
component
built
reporting
facilities
e
g
Microsoft
Access
used
key
advantage
composition
b
fewer
components
faster
implementation
no
component
communication
overheads
Furthermore
data
integrity
rules
apply
database
apply
reports
reports
able
combine
data
incorrect
ways
composition
no
constraints
errors
reports
occur
general
good
composition
principle
follow
principle
separation
concerns
try
design
system
component
clearly
defined
role
Ideally
component
roles
overlap
However
cheaper
buy
one
multifunctional
component
rather
two
three
separate
components
Furthermore
dependability
performance
penalties
incurred
multiple
components
used
@@@@@@@@@@
Chapter
reading
Key
Points
Component
based
software
engineering
reuse
based
approach
defining
implementing
composing
loosely
coupled
independent
components
systems
component
software
unit
functionality
dependencies
completely
defined
set
public
interfaces
Components
composed
components
without
knowledge
implementation
deployed
executable
unit
Components
implemented
executable
routines
included
system
external
services
referenced
system
component
model
defines
set
standards
components
including
interface
standards
usage
standards
deployment
standards
implementation
component
model
provides
set
common
services
used
components
CBSE
process
interleave
processes
requirements
engineering
system
design
trade
off
desirable
requirements
services
available
existing
reusable
components
Component
composition
process
wiring
components
together
create
system
Types
composition
include
sequential
composition
hierarchical
composition
additive
composition
composing
reusable
components
written
application
need
write
adaptors
glue
code
reconcile
different
component
interfaces
choosing
compositions
consider
required
functionality
system
non
functional
requirements
ease
one
component
replaced
system
changed
rEading
Component
Software
Beyond
Object
Oriented
Programming
nd
ed
updated
edition
first
book
CBSE
covers
technical
nontechnical
issues
CBSE
detail
specific
technologies
Heineman
Councill
s
book
includes
thorough
discussion
market
issues
C
Szyperski
Addison
Wesley
Specification
Implementation
Deployment
Components
good
introduction
fundamentals
CBSE
issue
CACM
includes
articles
components
component
based
development
Crnkovic
B
Hnich
T
Jonsson
Z
Kiziltan
Comm
ACM
October
http
dx
doi
org
Software
Component
Models
comprehensive
discussion
commercial
research
component
models
classifies
models
explains
differences
K
K
Lau
Z
Wang
IEEE
Transactions
Software
Engineering
October
http
dx
doi
org
TSE
@@@@@@@@@@
Chapter
Component
based
software
engineering
Software
Components
Beyond
Programming
Routines
Services
opening
article
special
issue
magazine
includes
several
articles
software
components
article
discusses
evolution
components
service
oriented
components
replacing
executable
program
routines
Crnkovic
J
Stafford
C
Szyperski
IEEE
Software
June
http
dx
doi
org
MS
Object
Constraint
Language
OCL
Tutorial
good
introduction
use
object
constraint
language
J
Cabot
http
modeling
languages
com
ocl
tutorial
WEBSitE
PowerPoint
slides
chapter
www
pearsonglobaleditions
com
Sommerville
Links
supporting
videos
http
software
engineering
book
com
videos
software
reuse
detailed
discussion
Ariane
accident
http
software
engineering
book
com
case
studies
ariane
ExErCiSES
design
principles
underlying
CBSE
support
construction
understandable
maintainable
software
principle
component
independence
means
possible
replace
one
component
another
implemented
completely
different
way
Using
example
explain
component
replacement
undesired
consequences
lead
system
failure
reusable
component
critical
characteristics
emphasized
component
viewed
service
important
components
based
standard
component
model
Using
example
component
implements
abstract
data
type
stack
list
show
usually
necessary
extend
adapt
components
reuse
essential
differences
CBSE
reuse
software
processes
original
software
development
Design
provides
interface
requires
interface
reusable
component
used
represent
patient
Mentcare
system
introduced
Chapter
@@@@@@@@@@
Chapter
References
Using
examples
illustrate
different
types
adaptor
needed
support
sequential
composition
hierarchical
composition
additive
composition
Design
interfaces
components
used
system
emergency
control
room
design
interfaces
call
logging
component
records
calls
made
vehicle
discovery
component
given
post
code
zip
code
incident
type
finds
nearest
suitable
vehicle
dispatched
incident
suggested
independent
certification
authority
established
Vendors
submit
components
authority
validate
component
trustworthy
advantages
disadvantages
certification
authority
rEFErEnCES
Councill
W
T
G
T
Heineman
Definition
Software
Component
Elements
Component
Based
Software
Engineering
edited
G
T
Heineman
W
T
Councill
Boston
Addison
Wesley
Jacobsen
M
Griss
P
Jonsson
Software
Reuse
Reading
MA
Addison
Wesley
Kotonya
G
CBSE
Process
Issues
Future
Visions
nd
CBSEnet
Workshop
Budapest
Hungary
http
miro
sztaki
hu
projects
cbsenet
budapest
presentations
Gerald
CBSEProcess
ppt
Lau
K
K
Z
Wang
Software
Component
Models
IEEE
Trans
Software
Eng
doi
TSE
Meyer
B
Applying
Design
Contract
IEEE
Computer
doi
Grand
Challenge
Trusted
Components
Proc
th
Int
Conf
Software
Engineering
Portland
IEEE
Press
doi
ICSE
Mili
H
Mili
S
Yacoub
E
Addy
Reuse
Based
Software
Engineering
New
York
John
Wiley
Sons
Pope
CORBA
Reference
Guide
Understanding
Common
Object
Request
Broker
Architecture
Harlow
UK
Addison
Wesley
Szyperski
C
Component
Software
Beyond
Object
Oriented
Programming
nd
ed
Harlow
UK
Addison
Wesley
Warmer
J
Kleppe
Object
Constraint
Language
Getting
Models
Ready
MDA
Boston
Addison
Wesley
Weinreich
R
J
Sametinger
Component
Models
Component
Services
Concepts
Principles
Component
Based
Software
Engineering
edited
G
T
Heineman
W
T
Councill
Boston
Addison
Wesley
Wheeler
W
J
White
Spring
Practice
Greenwich
CT
Manning
Publications
@@@@@@@@@@
Distributed
software
engineering
Objectives
objective
chapter
introduce
distributed
systems
engineering
distributed
systems
architectures
read
chapter
know
key
issues
considered
designing
implementing
distributed
software
systems
understand
client
server
computing
model
layered
architecture
client
server
systems
introduced
commonly
used
patterns
distributed
systems
architectures
know
types
system
architectural
pattern
applicable
understand
notion
software
service
providing
web
based
access
remotely
deployed
application
systems
Contents
Distributed
systems
Client
server
computing
Architectural
patterns
distributed
systems
Software
service
@@@@@@@@@@
Chapter
Distributed
software
engineering
computer
based
systems
now
distributed
systems
distributed
system
one
involving
several
computers
rather
single
application
running
single
machine
Even
apparently
self
contained
applications
PC
laptop
image
editors
distributed
systems
execute
single
computer
system
often
rely
remote
cloud
systems
update
storage
services
Tanenbaum
Van
Steen
Tanenbaum
Van
Steen
define
distributed
system
collection
independent
computers
appears
user
single
coherent
system
designing
distributed
system
specific
issues
taken
account
simply
system
distributed
issues
arise
different
parts
system
running
independently
managed
computers
characteristics
network
latency
reliability
considered
design
Coulouris
et
al
Coulouris
et
al
identify
five
benefits
developing
systems
distributed
systems
Resource
sharing
distributed
system
allows
sharing
hardware
software
resources
disks
printers
files
compilers
associated
computers
network
Openness
Distributed
systems
normally
open
systems
systems
designed
around
standard
Internet
protocols
equipment
software
different
vendors
combined
Concurrency
distributed
system
several
processes
operate
time
separate
computers
network
processes
need
communicate
normal
operation
Scalability
principle
least
distributed
systems
scalable
capabilities
system
increased
adding
new
resources
cope
new
demands
system
practice
network
linking
individual
computers
system
limit
system
scalability
Fault
tolerance
availability
several
computers
potential
replicating
information
means
distributed
systems
tolerant
hardware
software
failures
see
Chapter
distributed
systems
degraded
service
provided
failures
occur
complete
loss
service
occurs
network
failure
Distributed
systems
inherently
complex
centralized
systems
makes
difficult
design
implement
test
harder
understand
emergent
properties
distributed
systems
complexity
interactions
system
components
system
infrastructure
example
rather
dependent
execution
speed
one
processor
system
performance
Tanenbaum
S
M
Van
Steen
Distributed
Systems
Principles
Paradigms
nd
Ed
Upper
Saddle
River
NJ
Prentice
Hall
Coulouris
G
J
Dollimore
T
Kindberg
G
Blair
Distributed
Systems
Concepts
Design
th
Edition
Harlow
UK
Addison
Wesley
@@@@@@@@@@
Chapter
Distributed
software
engineering
depends
network
bandwidth
network
load
speed
computers
part
system
Moving
resources
one
part
system
another
significantly
affect
system
s
performance
Furthermore
users
WWW
know
distributed
systems
unpredictable
response
Response
time
depends
overall
load
system
architecture
network
load
factors
change
short
time
time
taken
respond
user
request
change
significantly
one
request
another
important
developments
affected
distributed
software
systems
past
years
service
oriented
systems
advent
cloud
computing
delivering
infrastructure
platforms
software
service
chapter
focus
general
issues
distributed
systems
Section
cover
idea
software
service
Chapter
discuss
aspects
service
oriented
software
engineering
Distributed
systems
discussed
introduction
chapter
distributed
systems
complex
systems
run
single
processor
complexity
arises
practically
impossible
top
model
control
systems
nodes
system
deliver
functionality
often
independent
systems
managed
controlled
owners
no
single
authority
charge
entire
distributed
system
network
connecting
nodes
separately
managed
system
complex
system
right
cannot
controlled
owners
systems
using
network
therefore
inherent
unpredictability
operation
distributed
systems
taken
account
designing
system
important
design
issues
considered
distributed
systems
engineering
Transparency
extent
distributed
system
appear
user
single
system
useful
users
understand
system
distributed
Openness
system
designed
using
standard
protocols
support
interoperability
specialized
protocols
used
standard
network
protocols
now
universally
used
case
higher
levels
interaction
service
communication
Scalability
system
constructed
scalable
overall
system
designed
capacity
increased
response
increasing
demands
made
system
Security
usable
security
policies
defined
implemented
apply
across
set
independently
managed
systems
Quality
service
quality
service
delivered
system
users
specified
system
implemented
deliver
acceptable
quality
service
users
Failure
management
system
failures
detected
contained
minimal
effects
components
system
repaired
@@@@@@@@@@
CORBA
Common
Object
Request
Broker
Architecture
CORBA
proposed
specification
middleware
system
s
Object
Management
Group
intended
open
standard
allow
development
middleware
support
distributed
component
communications
execution
well
provide
set
standard
services
used
components
Several
implementations
CORBA
produced
system
widely
adopted
Users
preferred
proprietary
systems
Microsoft
Oracle
moved
service
oriented
architectures
http
software
engineering
book
com
web
corba
ideal
world
fact
system
distributed
transparent
users
Users
see
system
single
system
behavior
affected
way
system
distributed
practice
impossible
achieve
no
central
control
system
whole
result
individual
computers
system
behave
differently
different
times
Furthermore
takes
finite
length
time
signals
travel
across
network
network
delays
unavoidable
length
delays
depends
location
resources
system
quality
user
s
network
connection
network
load
make
distributed
system
transparent
e
conceal
distributed
nature
hide
underlying
distribution
create
abstractions
hide
system
resources
location
implementation
resources
changed
without
change
distributed
application
Middleware
discussed
Section
used
map
logical
resources
referenced
program
onto
actual
physical
resources
manage
resource
interactions
practice
impossible
make
system
completely
transparent
users
generally
aware
dealing
distributed
system
therefore
decide
best
expose
distribution
users
prepared
consequences
distribution
network
delays
remote
node
failures
Open
distributed
systems
built
according
generally
accepted
standards
Components
supplier
therefore
integrated
system
interoperate
system
components
networking
level
openness
now
taken
granted
systems
conforming
Internet
protocols
component
level
openness
still
universal
Openness
implies
system
components
independently
developed
programming
language
conform
standards
work
components
CORBA
standard
Pope
developed
s
intended
universal
standard
open
distributed
systems
However
CORBA
standard
never
achieved
critical
mass
adopters
Rather
many
companies
preferred
develop
systems
using
proprietary
standards
components
companies
Sun
now
Oracle
Microsoft
provided
better
implementations
support
software
better
long
term
support
industrial
protocols
Web
service
standards
discussed
Chapter
service
oriented
architectures
developed
open
standards
However
standards
met
significant
resistance
perceived
inefficiency
Many
developers
service
based
systems
opted
instead
called
RESTful
protocols
@@@@@@@@@@
inherently
lower
overhead
web
service
protocols
use
RESTful
protocols
standardized
scalability
system
reflects
ability
deliver
high
quality
service
demands
system
increase
three
dimensions
scalability
size
distribution
manageability
Size
possible
add
resources
system
cope
increasing
numbers
users
Ideally
number
users
increases
system
increase
size
automatically
handle
increased
number
users
Distribution
possible
geographically
disperse
components
system
without
degrading
performance
new
components
added
matter
located
Large
companies
often
make
use
computing
resources
different
facilities
around
world
Manageability
possible
manage
system
increases
size
even
parts
system
located
independent
organizations
one
difficult
challenges
scale
involves
managers
communicating
agreeing
management
policies
practice
manageability
system
often
factor
limits
extent
scaled
Changing
size
system
involve
scaling
scaling
Scaling
means
replacing
resources
system
powerful
resources
example
increase
memory
server
Gb
Gb
Scaling
means
adding
resources
system
e
g
extra
web
server
work
alongside
existing
server
Scaling
often
cost
effective
scaling
especially
now
cloud
computing
makes
easy
add
remove
servers
system
However
provides
performance
improvements
concurrent
processing
possible
discussed
general
security
issues
issues
security
engineering
Part
book
system
distributed
attackers
target
individual
system
components
network
part
system
successfully
attacked
attacker
able
use
back
door
parts
system
distributed
system
defend
following
types
attack
Interception
attacker
intercepts
communications
parts
system
loss
confidentiality
Interruption
system
services
attacked
cannot
delivered
expected
Denial
service
attacks
involve
bombarding
node
illegitimate
service
requests
cannot
deal
valid
requests
Modification
attacker
gains
access
system
changes
data
system
services
Fabrication
attacker
generates
information
exist
uses
information
gain
privileges
example
attacker
generate
false
password
entry
use
gain
access
system
@@@@@@@@@@
major
difficulty
distributed
systems
establishing
security
policy
reliably
applied
components
system
discussed
Chapter
security
policy
sets
level
security
achieved
system
Security
mechanisms
encryption
authentication
used
enforce
security
policy
difficulties
distributed
system
arise
different
organizations
parts
system
organizations
mutually
incompatible
security
policies
security
mechanisms
Security
compromises
made
order
allow
systems
work
together
quality
service
QoS
offered
distributed
system
reflects
system
s
ability
deliver
services
dependably
response
time
throughput
acceptable
users
Ideally
QoS
requirements
specified
advance
system
designed
configured
deliver
QoS
Unfortunately
practicable
two
reasons
cost
effective
design
configure
system
deliver
high
quality
service
peak
load
peak
demands
mean
need
many
extra
servers
normal
ensure
response
times
maintained
problem
lessened
advent
cloud
computing
cloud
servers
rented
cloud
provider
long
required
demand
increases
extra
servers
automatically
added
quality
service
parameters
mutually
contradictory
example
increased
reliability
mean
reduced
throughput
checking
procedures
introduced
ensure
system
inputs
valid
Quality
service
particularly
important
system
dealing
time
critical
data
sound
video
streams
circumstances
quality
service
falls
threshold
value
sound
video
degraded
impossible
understand
Systems
dealing
sound
video
include
quality
service
negotiation
management
components
evaluate
QoS
requirements
available
resources
insufficient
negotiate
resources
reduced
QoS
target
distributed
system
inevitable
failures
occur
system
designed
resilient
failures
Failure
ubiquitous
one
flippant
definition
distributed
system
suggested
Leslie
Lamport
prominent
distributed
systems
researcher
know
distributed
system
crash
system
ve
never
heard
stops
getting
work
done
even
truer
now
systems
executing
cloud
Failure
management
involves
applying
fault
tolerance
techniques
discussed
Chapter
Distributed
systems
therefore
include
mechanisms
discovering
component
system
failed
continue
deliver
many
services
possible
spite
failure
far
possible
automatically
Leslie
Lamport
Ross
J
Anderson
Security
Engineering
Guide
Building
Dependable
Distributed
Systems
nd
ed
Wiley
April
@@@@@@@@@@
Waiter
Diner
Diner
like
Tomato
soup
please
follow
Fillet
steak
like
cooked
Rare
please
salad
french
fries
Salad
please
etc
Figure
Procedural
interaction
diner
waiter
recover
failure
One
important
benefit
cloud
computing
dramatically
reduced
cost
providing
redundant
system
components
Models
interaction
Two
fundamental
types
interaction
take
place
computers
distributed
computing
system
procedural
interaction
message
based
interaction
Procedural
interaction
involves
one
computer
calling
known
service
offered
computer
waiting
service
delivered
Message
based
interaction
involves
sending
computer
defining
information
required
message
sent
another
computer
Messages
usually
transmit
information
single
interaction
procedure
call
another
machine
illustrate
difference
procedural
message
based
interaction
consider
situation
ordering
meal
restaurant
conversation
waiter
involved
series
synchronous
procedural
interactions
define
order
make
request
waiter
acknowledges
request
make
another
request
acknowledged
comparable
components
interacting
software
system
one
component
calls
methods
components
waiter
writes
order
along
order
people
passes
order
includes
details
everything
ordered
kitchen
prepare
food
Essentially
waiter
passing
message
kitchen
staff
defining
food
prepared
message
based
interaction
illustrated
kind
interaction
Figure
shows
synchronous
ordering
process
series
calls
Figure
shows
hypothetical
XML
message
defines
order
made
table
three
people
difference
forms
information
exchange
clear
waiter
takes
order
series
@@@@@@@@@@
Figure
Message
based
interaction
waiter
kitchen
staff
starter
dish
name
soup
type
tomato
dish
name
soup
type
fish
dish
name
pigeon
salad
starter
main
course
dish
name
steak
type
sirloin
cooking
medium
dish
name
steak
type
fillet
cooking
rare
dish
name
sea
bass
main
accompaniment
dish
name
french
fries
portions
dish
name
salad
portions
accompaniment
interactions
interaction
defining
part
order
However
waiter
single
interaction
kitchen
message
defines
complete
order
Procedural
communication
distributed
system
usually
implemented
using
remote
procedure
calls
RPCs
RPC
components
globally
unique
names
URL
Using
name
component
call
services
offered
another
component
local
procedure
method
System
middleware
intercepts
call
passes
remote
component
carries
required
computation
via
middleware
returns
result
calling
component
Java
remote
method
invocations
RMIs
remote
procedure
calls
Remote
procedure
calls
require
stub
called
procedure
accessible
computer
initiating
call
stub
defines
interface
remote
procedure
stub
called
translates
procedure
parameters
standard
representation
transmission
remote
procedure
middleware
sends
request
execution
remote
procedure
remote
procedure
uses
library
functions
convert
parameters
required
format
carries
computation
returns
results
via
stub
representing
caller
Message
based
interaction
normally
involves
one
component
creating
message
details
services
required
another
component
message
sent
receiving
component
via
system
middleware
receiver
parses
message
carries
computations
creates
message
sending
component
required
results
passed
middleware
transmission
sending
component
problem
RPC
approach
interaction
caller
callee
need
available
time
communication
know
refer
essence
RPC
requirements
local
procedure
method
call
contrast
message
based
approach
unavailability
tolerated
system
component
processing
message
unavailable
message
simply
stays
queue
receiver
comes
back
online
Furthermore
necessary
sender
know
name
message
receiver
vice
versa
simply
communicate
middleware
responsible
ensuring
messages
passed
appropriate
system
@@@@@@@@@@
Application
components
Operating
system
Middleware
Networking
Application
components
Operating
system
Middleware
Networking
Logical
interaction
Information
exchange
common
services
Coordinated
operation
Physical
connectivity
System
System
Application
components
Operating
system
Middleware
Networking
Application
components
Operating
system
Middleware
Networking
Logical
interaction
Information
exchange
common
services
Coordinated
operation
Physical
connectivity
System
System
Figure
Middleware
distributed
system
Middleware
components
distributed
system
implemented
different
programming
languages
execute
different
types
processors
Models
data
information
representation
protocols
communication
different
distributed
system
therefore
requires
software
manage
diverse
parts
ensure
communicate
exchange
data
term
middleware
used
refer
software
sits
middle
distributed
components
system
concept
illustrated
Figure
shows
middleware
layer
operating
system
application
programs
Middleware
normally
implemented
set
libraries
installed
distributed
computer
plus
runtime
system
manage
communications
Bernstein
Bernstein
describes
types
middleware
available
support
distributed
computing
Middleware
general
purpose
software
usually
bought
off
shelf
rather
written
specially
application
developers
Examples
middleware
include
software
managing
communications
databases
transaction
managers
data
converters
communication
controllers
distributed
system
middleware
provides
two
distinct
types
support
Interaction
support
middleware
coordinates
interactions
different
components
system
middleware
provides
location
transparency
isn
t
necessary
components
know
physical
locations
components
support
parameter
conversion
different
programming
languages
used
implement
components
event
detection
communication
provision
common
services
middleware
provides
reusable
implementations
services
required
several
components
distributed
system
using
common
services
components
easily
interoperate
provide
user
services
consistent
way
already
given
examples
interaction
support
middleware
provide
Section
use
middleware
support
remote
procedure
remote
method
calls
message
exchange
forth
@@@@@@@@@@
Common
services
services
required
different
components
irrespective
functionality
components
discussed
Chapter
include
security
services
authentication
authorization
notification
naming
services
transaction
management
services
distributed
components
think
common
services
provided
middleware
container
services
provided
shared
libraries
deploy
component
access
use
common
services
Client
server
computing
Distributed
systems
accessed
Internet
organized
client
server
systems
client
server
system
user
interacts
program
running
local
computer
web
browser
app
mobile
device
interacts
another
program
running
remote
computer
web
server
remote
computer
provides
services
access
web
pages
available
external
clients
client
server
model
discussed
Chapter
general
architectural
model
application
restricted
applications
distributed
across
several
machines
use
logical
interaction
model
client
server
run
computer
client
server
architecture
application
modeled
set
services
provided
servers
Clients
access
services
present
results
end
users
Clients
need
aware
servers
available
don
t
know
anything
clients
Clients
servers
separate
processes
shown
Figure
figure
illustrates
situation
four
servers
s
s
deliver
different
services
service
set
associated
clients
access
services
Figure
shows
client
server
processes
rather
processors
normal
several
client
processes
run
single
processor
example
PC
run
mail
client
downloads
mail
remote
mail
server
run
web
browser
interacts
remote
web
server
print
client
sends
documents
remote
printer
Figure
shows
possible
arrangement
logical
clients
shown
Figure
running
six
computers
four
server
processes
mapped
onto
two
physical
server
computers
Several
different
server
processes
run
processor
often
servers
implemented
multiprocessor
systems
separate
instance
server
process
runs
machine
Load
balancing
software
distributes
requests
service
clients
different
servers
server
amount
work
allows
higher
volume
transactions
clients
handled
without
degrading
response
individual
clients
Client
server
systems
depend
clear
separation
presentation
information
computations
create
process
information
Consequently
design
architecture
distributed
client
server
systems
structured
several
logical
layers
clear
interfaces
@@@@@@@@@@
s
s
s
s
c
c
c
c
c
c
c
c
c
c
c
c
s
s
s
s
c
c
c
c
c
c
c
c
c
c
c
c
Server
process
Client
process
Figure
Client
server
interaction
layers
allows
layer
distributed
different
computer
Figure
illustrates
model
showing
application
structured
four
layers
presentation
layer
concerned
presenting
information
user
managing
user
interaction
data
handling
layer
manages
data
passed
client
layer
implement
checks
data
generate
web
pages
application
processing
layer
concerned
implementing
logic
application
providing
required
functionality
end
users
database
layer
stores
data
provides
transaction
management
query
services
following
section
explains
different
client
server
architectures
distribute
logical
layers
different
ways
client
server
model
underlies
notion
software
service
SaaS
important
way
deploying
software
accessing
Internet
cover
topic
Section
s
s
NetworkSC
SC
CC
CC
CC
CC
CC
CC
s
s
c
c
c
c
c
c
c
c
c
Server
computer
c
c
c
Client
computer
Figure
Mapping
clients
servers
networked
computers
@@@@@@@@@@
Presentation
Application
processing
Data
handling
Database
Presentation
Application
processing
Data
handling
Database
Figure
Layered
architectural
model
client
server
application
Architectural
patterns
distributed
systems
explained
introduction
chapter
designers
distributed
systems
organize
system
designs
find
balance
performance
dependability
security
manageability
system
no
universal
model
system
organization
appropriate
circumstances
various
distributed
architectural
styles
emerged
designing
distributed
application
choose
architectural
style
supports
critical
non
functional
requirements
system
section
discuss
five
architectural
styles
Master
slave
architecture
used
real
time
systems
guaranteed
interaction
response
times
required
Two
tier
client
server
architecture
used
simple
client
server
systems
situations
important
centralize
system
security
reasons
Multi
tier
client
server
architecture
used
server
process
high
volume
transactions
Distributed
component
architecture
used
resources
different
systems
databases
need
combined
implementation
model
multi
tier
client
server
systems
Peer
peer
architecture
used
clients
exchange
locally
stored
information
role
server
introduce
clients
used
large
number
independent
computations
made
Master
slave
architectures
Master
slave
architectures
distributed
systems
commonly
used
real
time
systems
systems
separate
processors
associated
data
acquisition
system
s
environment
data
processing
computation
@@@@@@@@@@
Control
room
Light
control
process
Traffic
light
control
processor
processor
Operator
consoles
Traffic
flow
sensors
cameras
Sensor
processor
Sensor
control
process
Coordination
display
process
Slave
Slave
Master
Figure
traffic
management
system
master
slave
architecture
Traffic
lights
actuator
management
Actuators
discuss
Chapter
devices
controlled
software
system
act
change
system
s
environment
example
actuator
control
valve
change
state
open
closed
master
process
usually
responsible
computation
coordination
communications
controls
slave
processes
Slave
processes
dedicated
specific
actions
acquisition
data
array
sensors
Figure
shows
example
architectural
model
traffic
control
system
city
three
logical
processes
run
separate
processors
master
process
control
room
process
communicates
separate
slave
processes
responsible
collecting
traffic
data
managing
operation
traffic
lights
set
distributed
sensors
collects
information
traffic
flow
sensor
control
process
polls
sensors
periodically
capture
traffic
flow
information
collates
information
processing
sensor
processor
polled
periodically
information
master
process
concerned
displaying
traffic
status
operators
computing
traffic
light
sequences
accepting
operator
commands
modify
sequences
control
room
system
sends
commands
traffic
light
control
process
converts
signals
control
traffic
light
hardware
master
control
room
system
organized
client
server
system
client
processes
running
operator
s
consoles
use
master
slave
model
distributed
system
situations
predict
distributed
processing
required
processing
easily
localized
slave
processors
situation
common
real
time
systems
important
meet
processing
deadlines
Slave
processors
used
computationally
intensive
operations
signal
processing
management
equipment
controlled
system
@@@@@@@@@@
Presentation
Thin
clientmodelClient
Server
Database
Data
management
Application
processing
Presentation
Application
processing
Fat
client
model
Figure
Thin
fat
client
architectural
models
Client
Server
Database
Data
management
Two
tier
client
server
architectures
Section
explained
general
organization
client
server
systems
part
application
system
runs
user
s
computer
client
part
runs
remote
computer
server
presented
layered
application
model
Figure
different
layers
system
execute
different
computers
two
tier
client
server
architecture
simplest
form
client
server
architecture
system
implemented
single
logical
server
plus
indefinite
number
clients
use
server
illustrated
Figure
shows
two
forms
architectural
model
thin
client
model
presentation
layer
implemented
client
layers
data
handling
application
processing
database
implemented
server
client
presentation
software
usually
web
browser
apps
mobile
devices
available
fat
client
model
application
processing
carried
client
Data
management
database
functions
implemented
server
case
client
software
specially
written
program
tightly
integrated
server
application
advantage
thin
client
model
simple
manage
clients
becomes
major
issue
large
number
clients
difficult
expensive
install
new
software
web
browser
used
client
no
need
install
software
disadvantage
thin
client
approach
however
places
heavy
processing
load
server
network
server
responsible
computation
lead
generation
significant
network
traffic
client
server
Implementing
system
using
model
therefore
require
additional
investment
network
server
capacity
fat
client
model
makes
use
available
processing
power
computer
running
client
software
distributes
application
processing
@@@@@@@@@@
Account
server
Customer
account
database
Tele
processing
monitor
ATM
ATM
ATM
ATM
Account
server
Customer
account
database
Tele
processing
monitor
ATM
ATM
ATM
ATM
Figure
fat
client
architecture
ATM
system
presentation
client
server
essentially
transaction
server
manages
database
transactions
Data
handling
straightforward
no
need
manage
interaction
client
application
processing
system
fat
client
model
requires
system
management
deploy
maintain
software
client
computer
example
situation
fat
client
architecture
used
bank
ATM
system
delivers
cash
banking
services
users
ATM
client
computer
server
typically
mainframe
running
customer
account
database
mainframe
computer
powerful
machine
designed
transaction
processing
therefore
handle
large
volume
transactions
generated
ATMs
teller
systems
online
banking
software
teller
machine
carries
lot
customer
related
processing
associated
transaction
Figure
shows
simplified
version
ATM
system
organization
ATMs
connect
directly
customer
database
rather
teleprocessing
TP
monitor
TP
monitor
middleware
system
organizes
communications
remote
clients
serializes
client
transactions
processing
database
ensures
transactions
independent
interfere
one
Using
serial
transactions
means
system
recover
faults
without
corrupting
system
data
fat
client
model
distributes
processing
effectively
thin
client
model
system
management
complex
special
purpose
client
rather
browser
used
Application
functionality
spread
across
many
computers
application
software
changed
involves
software
reinstallation
every
client
computer
major
cost
hundreds
clients
system
Auto
update
client
software
reduce
costs
introduces
problems
client
functionality
changed
new
functionality
mean
businesses
change
ways
use
system
extensive
use
mobile
devices
means
important
mimimize
network
traffic
possible
devices
now
include
powerful
computers
carry
local
processing
consequence
distinction
thin
client
fat
client
architectures
blurred
Apps
inbuilt
functionality
carries
local
processing
web
pages
include
Javascript
components
@@@@@@@@@@
Tier
Presentation
Database
server
Customer
account
database
Web
server
Client
Client
Account
service
provision
SQL
SQL
query
HTTPS
interaction
Client
Client
Tier
Application
processing
data
handling
Tier
Database
processingFigure
Three
tier
architecture
Internet
banking
system
execute
user
s
local
computer
update
problem
apps
remains
issue
addressed
extent
automatically
updating
apps
without
explicit
user
intervention
Consequently
sometimes
helpful
use
models
general
basis
architecture
distributed
system
practice
web
based
applications
implement
processing
remote
server
Multi
tier
client
server
architectures
fundamental
problem
two
tier
client
server
approach
logical
layers
system
presentation
application
processing
data
management
database
mapped
onto
two
computer
systems
client
server
lead
problems
scalability
performance
thin
client
model
chosen
problems
system
management
fat
client
model
used
avoid
problems
multi
tier
client
server
architecture
used
architecture
different
layers
system
namely
presentation
data
management
application
processing
database
separate
processes
execute
different
processors
Internet
banking
system
Figure
example
multi
tier
client
server
architecture
three
tiers
system
bank
s
customer
database
usually
hosted
mainframe
computer
discussed
provides
database
services
web
server
provides
data
management
services
web
page
generation
application
services
Application
services
facilities
transfer
cash
generate
statements
pay
bills
implemented
web
server
scripts
executed
client
user
s
computer
Internet
browser
client
system
scalable
relatively
easy
add
servers
scale
number
customers
increase
case
use
three
tier
architecture
allows
information
transfer
web
server
database
server
optimized
Efficient
middle
ware
supports
database
queries
SQL
Structured
Query
Language
used
handle
information
retrieval
database
@@@@@@@@@@
Architecture
Applications
Architecture
Applications
Two
tier
client
server
architecture
thin
clients
three
tier
client
server
model
extended
multi
tier
variant
additional
servers
added
system
involve
using
web
server
data
management
separate
servers
application
processing
database
services
Multi
tier
systems
used
applications
need
access
use
data
different
databases
case
need
add
integration
server
system
integration
server
collects
distributed
data
presents
application
server
single
database
discuss
following
section
distributed
component
architectures
used
implement
multi
tier
client
server
systems
Figure
Use
client
server
architectural
patterns
Two
tier
client
server
architecture
fat
clients
Multi
tier
client
server
architecture
Multi
tier
client
server
systems
distribute
application
processing
across
several
servers
scalable
two
tier
architectures
tiers
system
independently
managed
additional
servers
added
load
increases
Processing
distributed
application
logic
data
handling
servers
thus
leading
rapid
response
client
requests
Designers
client
server
architectures
take
number
factors
account
choosing
appropriate
distribution
architecture
Situations
client
server
architectures
discussed
used
described
Figure
Legacy
system
applications
used
separating
application
processing
data
handling
impractical
Clients
access
services
discussed
Section
Computationally
intensive
applications
compilers
little
no
requirements
data
handling
Data
intensive
applications
browsing
querying
non
intensive
application
processing
Simple
web
browsing
common
example
situation
architecture
used
Applications
application
processing
provided
off
shelf
software
e
g
Microsoft
Excel
client
Applications
computationally
intensive
processing
data
e
g
data
visualization
required
Mobile
applications
internet
connectivity
cannot
guaranteed
Local
processing
using
cached
information
database
therefore
possible
Large
scale
applications
hundreds
thousands
clients
Applications
data
application
volatile
Applications
data
multiple
sources
integrated
Distributed
component
architectures
organizing
processing
layers
shown
Figure
layer
system
implemented
separate
logical
server
model
works
well
many
types
application
However
limits
flexibility
system
designers
@@@@@@@@@@
Communication
middleware
Client
Client
Client
Client
Client
Comp
Common
services
Comp
Common
services
Comp
Common
services
Comp
Common
services
Communication
middleware
Client
Client
Client
Client
Client
Comp
Common
services
Comp
Common
services
Comp
Common
services
Comp
Common
services
Figure
distributed
component
architecture
decide
services
included
layer
practice
however
clear
service
data
management
service
application
service
database
service
Designers
plan
scalability
provide
means
servers
replicated
clients
added
system
general
approach
distributed
system
design
design
system
set
services
without
attempting
allocate
services
layers
system
service
group
related
services
implemented
using
separate
object
component
distributed
component
architecture
Figure
system
organized
set
interacting
components
discussed
Chapter
components
provide
interface
set
services
provide
components
call
services
middleware
using
remote
procedure
method
calls
Distributed
component
systems
reliant
middleware
manages
component
interactions
reconciles
differences
types
parameters
passed
components
provides
set
common
services
application
components
use
CORBA
standard
Orfali
Harkey
Edwards
defined
middleware
distributed
component
systems
CORBA
implementations
never
widely
adopted
Enterprises
preferred
use
proprietary
software
Enterprise
Java
Beans
EJB
NET
Using
distributed
component
model
implementing
distributed
systems
number
benefits
allows
system
designer
delay
decisions
services
provided
Service
providing
components
execute
node
network
no
need
decide
advance
service
part
data
management
layer
application
layer
user
interface
layer
open
system
architecture
allows
new
resources
added
required
New
system
services
added
easily
without
major
disruption
existing
system
system
flexible
scalable
New
objects
replicated
objects
added
load
system
increases
without
disrupting
parts
system
@@@@@@@@@@
Database
Database
Database
Integrator
Integrator
Display
Clients
Database
Database
Database
Integrator
Integrator
Display
Clients
Report
gen
Figure
distributed
component
architecture
data
mining
system
Visualizer
possible
reconfigure
system
dynamically
components
migrating
across
network
required
important
fluctuating
patterns
demand
services
service
providing
component
migrate
processor
service
requesting
objects
thus
improving
performance
system
distributed
component
architecture
used
logical
model
allows
structure
organize
system
case
think
provide
application
functionality
solely
terms
services
combinations
services
work
implement
services
example
retail
application
application
components
concerned
stock
control
customer
communications
goods
ordering
Data
mining
systems
good
example
type
system
implemented
using
distributed
component
architecture
Data
mining
systems
look
relationships
data
distributed
across
databases
Figure
systems
pull
information
several
separate
databases
carry
computationally
intensive
processing
present
easy
understand
visualizations
relationships
discovered
example
data
mining
application
system
retail
business
sells
food
books
Retail
businesses
maintain
separate
databases
detailed
information
food
products
books
use
loyalty
card
system
keep
track
customers
purchases
large
database
linking
bar
codes
products
customer
information
marketing
department
wants
find
relationships
customer
s
food
book
purchases
instance
relatively
high
proportion
people
buy
pizzas
buy
crime
novels
knowledge
business
specifically
target
customers
make
specific
food
purchases
information
new
novels
published
@@@@@@@@@@
example
sales
database
encapsulated
distributed
component
interface
provides
read
access
data
Integrator
components
concerned
specific
types
relationships
collect
information
databases
try
deduce
relationships
integrator
component
concerned
seasonal
variations
goods
sold
another
integrator
concerned
relationships
different
types
goods
Visualizer
components
interact
integrator
components
create
visualization
report
relationships
discovered
large
volumes
data
handled
visualizer
components
normally
present
results
graphically
Finally
display
component
responsible
delivering
graphical
models
clients
final
presentation
web
browser
distributed
component
architecture
rather
layered
architecture
appropriate
type
application
add
new
databases
system
without
major
disruption
new
database
simply
accessed
adding
another
distributed
component
database
access
components
provide
simplified
interface
controls
access
data
databases
accessed
reside
different
machines
architecture
makes
easy
new
types
relationships
adding
new
integrator
objects
Distributed
component
architectures
suffer
two
major
disadvantages
complex
design
client
server
systems
Multilayer
client
server
systems
appear
fairly
intuitive
way
think
systems
reflect
many
human
transactions
people
request
receive
services
people
specialize
providing
services
complexity
distributed
component
architectures
increases
costs
implementation
no
universal
standards
distributed
component
models
middle
ware
Rather
different
vendors
Microsoft
Sun
developed
different
incompatible
middleware
middleware
complex
reliance
significantly
increases
complexity
distributed
component
systems
result
problems
distributed
component
architectures
replaced
service
oriented
systems
discussed
Chapter
However
distributed
component
systems
performance
benefits
service
oriented
systems
RPC
communications
usually
faster
message
based
interaction
used
service
oriented
systems
Distributed
component
architectures
therefore
still
used
high
throughput
systems
large
numbers
transactions
processed
quickly
Peer
peer
architectures
client
server
model
computing
discussed
previous
sections
chapter
makes
clear
distinction
servers
providers
services
clients
receivers
services
model
usually
leads
uneven
distribution
load
system
servers
work
clients
lead
organizations
spending
lot
server
capacity
unused
processing
capacity
hundreds
thousands
PCs
mobile
devices
used
access
system
servers
@@@@@@@@@@
Peer
peer
p
p
systems
Oram
decentralized
systems
computations
carried
node
network
principle
least
no
distinctions
made
clients
servers
peer
peer
applications
overall
system
designed
take
advantage
computational
power
storage
available
across
potentially
huge
network
computers
standards
protocols
enable
communications
across
nodes
embedded
application
node
run
copy
application
Peer
peer
technologies
mostly
used
personal
rather
business
systems
fact
no
central
servers
means
systems
harder
monitor
therefore
higher
level
communication
privacy
possible
example
file
sharing
systems
based
BitTorrent
protocol
widely
used
exchange
files
users
PCs
Private
instant
messaging
systems
ICQ
Jabber
provide
direct
communications
users
without
intermediate
server
Bitcoin
peer
peer
payments
system
using
Bitcoin
electronic
currency
Freenet
decentralized
database
designed
make
easier
publish
information
anonymously
make
difficult
authorities
suppress
information
p
p
systems
developed
privacy
principal
requirement
Voice
IP
VoIP
phone
services
Viber
rely
peer
topeer
communication
parties
involved
phone
call
conference
SETI@home
long
running
project
processes
data
radio
telescopes
home
PCs
order
search
indications
extraterrestrial
life
systems
advantage
p
p
model
central
server
processing
bottleneck
Peer
peer
systems
used
businesses
harness
power
PC
networks
McDougall
Intel
Boeing
implemented
p
p
systems
computationally
intensive
applications
systems
take
advantage
unused
processing
capacity
local
computers
Instead
buying
expensive
high
performance
hardware
engineering
computations
run
overnight
desktop
computers
unused
Businesses
make
extensive
use
commercial
p
p
systems
messaging
VoIP
systems
principle
every
node
p
p
network
aware
every
node
Nodes
connect
exchange
data
directly
node
network
practice
impossible
unless
network
members
Consequently
nodes
usually
organized
localities
nodes
acting
bridges
node
localities
Figure
shows
decentralized
p
p
architecture
decentralized
architecture
nodes
network
simply
functional
elements
communications
switches
route
data
control
signals
one
node
another
example
assume
Figure
represents
decentralized
document
management
system
consortium
researchers
uses
system
share
documents
member
consortium
maintains
document
store
However
document
retrieved
node
retrieving
document
makes
available
nodes
someone
needs
document
stored
somewhere
network
issue
search
command
sent
nodes
locality
nodes
check
document
return
requestor
route
search
nodes
Therefore
n
issues
search
@@@@@@@@@@
n
n
n
n
n
n
n
n
n
n
n
n
n
n
n
n
n
n
n
n
n
n
n
n
n
n
n
n
Figure
decentralized
p
p
architecture
document
stored
n
search
routed
nodes
n
n
n
n
document
finally
discovered
node
holding
document
sends
requesting
node
directly
making
peer
peer
connection
decentralized
architecture
advantage
highly
redundant
fault
tolerant
tolerant
nodes
disconnecting
network
However
disadvantages
many
different
nodes
process
search
significant
overhead
replicated
peer
communications
alternative
p
p
architectural
model
departs
pure
p
p
architecture
semicentralized
architecture
network
one
nodes
act
servers
facilitate
node
communications
reduces
amount
traffic
nodes
Figure
illustrates
semicentralized
architectural
model
differs
completely
decentralized
model
shown
Figure
semicentralized
architecture
role
server
sometimes
called
super
peer
help
establish
contact
peers
network
coordinate
results
computation
example
Figure
represents
instant
messaging
system
network
nodes
communicate
server
indicated
dashed
lines
find
nodes
available
nodes
discovered
direct
communications
established
connection
server
becomes
unnecessary
Therefore
nodes
n
n
n
n
direct
communication
computational
p
p
system
processor
intensive
computation
distributed
across
large
number
nodes
normal
nodes
superpeers
role
distribute
work
nodes
collate
check
results
computation
peer
peer
architectural
model
best
model
distributed
system
two
circumstances
system
computationally
intensive
possible
separate
processing
required
large
number
independent
computations
example
peer
peer
system
supports
computational
drug
discovery
distributes
computations
look
potential
cancer
treatments
analyzing
huge
number
molecules
see
characteristics
required
suppress
growth
cancers
molecule
considered
separately
no
need
peers
system
communicate
@@@@@@@@@@
Figure
semicentralized
p
p
architecture
n
n
n
n
n
n
Discovery
server
Super
peer
system
primarily
involves
exchange
information
individual
computers
network
no
need
information
centrally
stored
managed
Examples
applications
include
file
sharing
systems
allow
peers
exchange
local
files
music
video
files
phone
systems
support
voice
video
communications
computers
Peer
peer
architectures
allow
efficient
use
capacity
across
network
However
security
concerns
principal
reason
systems
widely
used
especially
business
Wallach
lack
centralized
management
means
attackers
set
malicious
nodes
deliver
spam
malware
legitimate
p
p
system
users
Peer
peer
communications
involve
opening
computer
direct
interactions
peers
means
systems
potentially
access
resources
counter
possibility
need
organize
system
resources
protected
done
incorrectly
system
insecure
vulnerable
external
corruption
Software
service
previous
sections
discussed
client
server
models
functionality
distributed
client
server
implement
client
server
system
install
program
app
client
computer
communicates
server
implements
client
side
functionality
manages
user
interface
example
mail
client
Outlook
Mac
Mail
provides
mail
management
features
computer
avoids
problem
server
overload
thin
client
systems
processing
carried
server
problems
server
overload
significantly
reduced
using
web
technologies
AJAX
Holdener
HTML
Sarris
technologies
support
efficient
management
web
page
presentation
local
computation
executing
scripts
part
web
page
means
browser
configured
used
client
significant
local
processing
application
software
@@@@@@@@@@
thought
remote
service
accessed
device
run
standard
browser
Widely
used
examples
SaaS
include
web
based
mail
systems
Yahoo
Gmail
office
applications
Google
Docs
Office
idea
software
service
SaaS
involves
hosting
software
remotely
providing
access
Internet
key
elements
SaaS
follows
Software
deployed
server
commonly
cloud
accessed
web
browser
deployed
local
PC
software
owned
managed
software
provider
rather
organizations
using
software
Users
pay
software
according
much
use
make
annual
monthly
subscription
Sometimes
software
free
anyone
use
users
agree
accept
advertisements
fund
software
service
development
SaaS
accelerated
past
years
cloud
computing
widely
used
service
deployed
cloud
number
servers
quickly
change
match
user
demands
service
no
need
service
providers
provision
peak
loads
result
costs
providers
dramatically
reduced
software
purchasers
benefit
SaaS
costs
management
software
transferred
provider
provider
responsible
fixing
bugs
installing
software
upgrades
dealing
changes
operating
system
platform
ensuring
hardware
capacity
meet
demand
Software
license
management
costs
zero
someone
several
computers
no
need
license
software
software
application
used
occasionally
pay
per
use
model
cheaper
buying
application
software
accessed
mobile
devices
smartphones
anywhere
world
main
problem
inhibits
use
SaaS
data
transfer
remote
service
Data
transfer
takes
place
network
speeds
transferring
large
amount
data
video
high
quality
images
takes
lot
time
pay
service
provider
according
amount
transferred
problems
lack
control
software
evolution
provider
change
software
wishes
problems
laws
regulations
Many
countries
laws
governing
storage
management
preservation
accessibility
data
moving
data
remote
service
breach
laws
notion
software
service
service
oriented
architectures
SOA
discussed
Chapter
related
Software
service
way
providing
functionality
remote
server
client
access
web
browser
server
maintains
user
s
data
state
interaction
session
Transactions
usually
long
transactions
example
editing
document
@@@@@@@@@@
Service
oriented
architecture
approach
structuring
software
system
set
separate
stateless
services
services
provided
multiple
providers
distributed
Typically
transactions
short
transactions
service
called
something
returns
result
SaaS
way
delivering
application
functionality
users
SOA
implementation
technology
application
systems
Systems
implemented
using
SOA
accessed
users
web
services
SaaS
applications
business
implemented
using
components
rather
services
However
SaaS
implemented
using
SOA
becomes
possible
applications
use
service
APIs
access
functionality
applications
integrated
complex
systems
systems
called
mashups
another
approach
software
reuse
rapid
software
development
software
development
perspective
process
service
development
much
common
types
software
development
However
service
construction
usually
driven
user
requirements
service
provider
s
assumptions
users
need
Accordingly
software
needs
able
evolve
quickly
provider
gets
feedback
users
requirements
Agile
development
incremental
delivery
therefore
effective
approach
software
deployed
service
software
implemented
service
Google
Docs
web
users
offers
generic
experience
users
However
businesses
wish
specific
services
tailored
requirements
implementing
SaaS
business
base
software
service
generic
service
tailored
needs
business
customer
Three
important
factors
considered
Configurability
configure
software
specific
requirements
organization
Multi
tenancy
present
user
software
impression
working
copy
system
time
making
efficient
use
system
resources
Scalability
design
system
scaled
accommodate
unpredictably
large
number
users
notion
product
line
architectures
discussed
Chapter
one
way
configuring
software
users
overlapping
identical
requirements
start
generic
system
adapt
according
specific
requirements
user
work
SaaS
however
mean
deploying
different
copy
service
organization
uses
software
Rather
need
design
configurability
system
provide
configuration
interface
allows
users
specify
preferences
use
preferences
adjust
behavior
software
dynamically
used
Configuration
facilities
allow
Branding
users
organization
presented
interface
reflects
organization
@@@@@@@@@@
User
User
User
User
User
User
Application
service
Profile
C
Profile
C
Profile
C
User
User
User
User
User
User
Application
service
Profile
C
Profile
C
Profile
C
Figure
Configuration
software
system
offered
service
Business
rules
workflows
organization
defines
rules
govern
use
service
data
Database
extensions
organization
defines
generic
service
data
model
extended
meet
specific
needs
Access
control
service
customers
create
individual
accounts
staff
define
resources
functions
accessible
users
Figure
illustrates
situation
diagram
shows
five
users
application
service
work
three
different
customers
service
provider
Users
interact
service
customer
profile
defines
service
configuration
employer
Multi
tenancy
situation
many
different
users
access
system
system
architecture
defined
allow
efficient
sharing
system
resources
However
appear
users
sole
use
system
Multi
tenancy
involves
designing
system
absolute
separation
system
functionality
system
data
operations
therefore
stateless
shared
Data
provided
client
available
storage
system
database
accessed
system
instance
particular
problem
multi
tenant
systems
data
management
simplest
way
provide
data
management
customers
database
use
configure
wish
However
requires
service
provider
maintain
many
different
database
instances
one
per
customer
make
databases
available
demand
alternative
service
provider
use
single
database
different
users
virtually
isolated
database
illustrated
Figure
see
database
entries
tenant
identifier
links
entries
specific
users
using
database
views
extract
entries
service
customer
present
users
customer
virtual
personal
database
process
extended
meet
specific
customer
needs
using
configuration
features
discussed
Scalability
ability
system
cope
increasing
numbers
users
without
reducing
overall
quality
service
delivered
user
Generally
@@@@@@@@@@
Chapter
Distributed
software
engineering
Tenant
Key
Name
Address
C
XYZ
Corp
Anystreet
Sometown
C
BigCorp
Main
St
Motown
X
J
Bowie
Mill
St
Starville
PP
R
Burns
Alloway
Ayrshire
Figure
multi
tenant
database
considering
scalability
context
SaaS
considering
scaling
rather
scaling
Recall
scaling
means
adding
additional
servers
increasing
number
transactions
processed
parallel
Scalability
complex
topic
cannot
cover
detail
following
general
guidelines
implementing
scalable
software
Develop
applications
component
implemented
simple
stateless
service
run
server
course
single
transaction
user
therefore
interact
instances
service
running
several
different
servers
Design
system
using
asynchronous
interaction
application
wait
result
interaction
read
request
allows
application
carry
useful
work
waiting
interaction
finish
Manage
resources
network
database
connections
pool
no
single
server
likely
run
resources
Design
database
allow
fine
grain
locking
lock
whole
records
database
part
record
use
Use
cloud
PaaS
platform
Google
App
Engine
Sanderson
PaaS
platform
system
implementation
include
mechanisms
automatically
scale
system
load
increases
notion
software
service
major
paradigm
shift
distributed
computing
already
seen
consumer
software
professional
applications
Photoshop
move
model
delivery
Increasingly
businesses
replacing
systems
CRM
inventory
systems
cloud
based
SaaS
systems
external
providers
Salesforce
Specialized
software
companies
implement
business
applications
prefer
provide
SaaS
simplifies
software
update
management
SaaS
represents
new
way
think
engineering
enterprise
systems
helpful
think
systems
delivering
services
users
SaaS
function
involved
using
different
abstractions
objects
implementing
system
closer
match
user
system
abstractions
resultant
systems
easier
understand
maintain
evolve
@@@@@@@@@@
Chapter
reading
Key
Points
benefits
distributed
systems
scaled
cope
increasing
demand
continue
provide
user
services
even
parts
system
fail
enable
resources
shared
Issues
considered
design
distributed
systems
include
transparency
openness
scalability
security
quality
service
failure
management
Client
server
systems
distributed
systems
system
structured
layers
presentation
layer
implemented
client
computer
Servers
provide
data
management
application
database
services
Client
server
systems
several
tiers
different
layers
system
distributed
different
computers
Architectural
patterns
distributed
systems
include
master
slave
architectures
two
tier
multi
tier
client
server
architectures
distributed
component
architectures
peer
peer
architectures
Distributed
component
systems
require
middleware
handle
component
communications
allow
objects
added
removed
system
Peer
peer
architectures
decentralized
architectures
no
distinguished
clients
servers
Computations
distributed
many
systems
different
organizations
Software
service
way
deploying
applications
thin
client
server
systems
client
web
browser
reADing
Peer
Peer
Harnessing
Power
Disruptive
Technologies
book
lot
information
p
p
architectures
excellent
introduction
p
p
computing
discusses
organization
approach
used
number
p
p
systems
Oram
ed
O
Reilly
Associates
Inc
Turning
Software
Service
good
overview
paper
discusses
principles
service
oriented
computing
Unlike
many
papers
topic
conceal
principles
behind
discussion
standards
involved
M
Turner
D
Budgen
P
Brereton
IEEE
Computer
October
http
dx
doi
org
MC
Distributed
Systems
th
ed
comprehensive
textbook
discusses
aspects
distributed
systems
design
implementation
includes
coverage
peer
peer
systems
mobile
systems
G
Coulouris
J
Dollimore
T
Kindberg
G
Blair
Addison
Wesley
Engineering
Software
Service
Agile
Approach
Using
Cloud
Computing
book
accompanies
authors
online
course
topic
good
practical
book
aimed
people
new
type
development
Fox
D
Patterson
Strawberry
Canyon
LLC
http
www
saasbook
info
@@@@@@@@@@
Chapter
Distributed
software
engineering
WebSite
PowerPoint
slides
chapter
www
pearsonglobaleditions
com
Sommerville
Links
supporting
videos
http
software
engineering
book
com
videos
requirements
design
exerCiSeS
understand
scalability
Discuss
differences
scaling
scaling
explain
different
approaches
scalability
used
Explain
distributed
software
systems
complex
centralized
software
systems
system
functionality
implemented
single
computer
Using
example
remote
procedure
call
explain
middleware
coordinates
interaction
computers
distributed
system
different
logical
layers
application
distributed
client
server
architecture
asked
design
secure
system
requires
strong
authentication
authorization
system
designed
communications
parts
system
cannot
intercepted
read
attacker
Suggest
appropriate
client
server
architecture
system
giving
reasons
answer
propose
functionality
distributed
client
server
systems
customer
wants
develop
system
stock
information
dealers
access
information
companies
evaluate
various
investment
scenarios
using
simulation
system
dealer
uses
simulation
different
way
according
experience
type
stocks
question
Suggest
client
server
architecture
system
shows
functionality
located
Justify
client
server
system
model
chosen
Using
distributed
component
approach
propose
architecture
national
theater
booking
system
Users
check
seat
availability
book
seats
group
theaters
system
support
ticket
returns
people
return
tickets
last
minute
resale
customers
fundamental
problem
two
tier
client
server
approach
Define
multi
tier
client
server
approach
overcomes
List
benefits
distributed
component
model
used
implementing
distributed
systems
company
wishes
move
using
desktop
applications
accessing
functionality
remotely
services
Identify
three
risks
arise
suggest
risks
reduced
@@@@@@@@@@
Chapter
References
reFerenCeS
Bernstein
P
Middleware
Model
Distributed
System
Services
Comm
ACM
doi
Coulouris
G
J
Dollimore
T
Kindberg
G
Blair
Distributed
Systems
Concepts
Design
th
ed
Harlow
UK
Addison
Wesley
Holdener
T
Ajax
Definitive
Guide
Sebastopol
CA
O
Reilly
Associates
McDougall
P
Power
Peer
Peer
Information
Week
August
http
www
informationweek
com
peer
htm
Oram
Peer
Peer
Harnessing
Benefits
Disruptive
Technology
Sebastopol
CA
O
Reilly
Associates
Orfali
R
D
Harkey
J
Edwards
Instant
CORBA
Chichester
UK
John
Wiley
Sons
Pope
CORBA
Reference
Guide
Understanding
Common
Object
Request
Broker
Architecture
Harlow
UK
Addison
Wesley
Sanderson
D
Programming
Google
App
Engine
Sebastopol
CA
O
Reilly
Media
Inc
Sarris
S
HTML
Unleashed
Indianapolis
Sams
Publishing
Tanenbaum
S
M
Van
Steen
Distributed
Systems
Principles
Paradigms
nd
ed
Upper
Saddle
River
NJ
Prentice
Hall
Wallach
D
S
Survey
Peer
Peer
Security
Issues
Software
Security
Theories
Systems
edited
M
Okada
B
C
Pierce
Scedrov
H
Tokuda
Yonezawa
Heidelberg
Springer
Verlag
doi
X
@@@@@@@@@@
Service
oriented
software
engineering
Objectives
objective
chapter
introduce
service
oriented
software
engineering
way
building
distributed
applications
using
web
services
read
chapter
understand
basic
notions
web
service
web
service
standards
service
oriented
architecture
understand
idea
RESTful
services
important
differences
RESTful
SOAP
based
services
understand
service
engineering
process
intended
produce
reusable
web
services
understand
workflow
based
service
composition
used
create
service
oriented
software
supports
business
processes
Contents
Service
oriented
architecture
RESTful
services
Service
engineering
Service
composition
@@@@@@@@@@
Chapter
Service
oriented
software
engineering
development
Web
s
revolutionized
organizational
information
exchange
Client
computers
gain
access
information
remote
servers
outside
organizations
However
access
solely
web
browser
direct
access
information
programs
practical
meant
opportunistic
connections
servers
example
program
query
number
catalogs
different
suppliers
possible
get
around
problem
web
services
developed
allowed
programs
access
update
resources
available
web
Using
web
service
organizations
wish
make
information
accessible
programs
defining
publishing
programmatic
web
service
interface
interface
defines
data
available
accessed
used
generally
web
service
standard
representation
computational
information
resource
used
programs
information
resources
parts
catalog
computer
resources
specialized
processor
storage
resources
example
archive
service
implemented
permanently
reliably
stores
organizational
data
law
maintained
many
years
web
service
instance
general
notion
service
Lovelock
et
al
Lovelock
et
al
defined
act
performance
offered
one
party
another
process
tied
physical
product
performance
essentially
intangible
normally
result
ownership
factors
production
Services
natural
development
software
components
component
model
essence
set
standards
associated
web
services
web
service
therefore
defined
loosely
coupled
reusable
software
component
encapsulates
discrete
func
tionality
distributed
programmatically
accessed
web
service
service
accessed
using
standard
Internet
XML
based
protocols
critical
distinction
service
software
component
defined
component
based
software
engineering
services
independent
loosely
coupled
operate
way
irrespective
execution
environment
rely
external
components
different
functional
non
functional
behavior
Therefore
web
services
requires
interface
CBSE
defines
system
components
present
web
service
interface
simply
provides
interface
defines
service
functionality
parameters
Service
oriented
systems
way
developing
distributed
systems
system
components
stand
alone
services
executing
geographically
distributed
computers
Services
platform
implementation
language
independent
Software
systems
constructed
composing
local
services
external
services
different
providers
seamless
interaction
services
system
Lovelock
C
Vandermerwe
S
Lewis
B
Services
Marketing
Englewood
Cliffs
NJ
Prentice
Hall
@@@@@@@@@@
discussed
Chapter
ideas
software
service
serviceoriented
systems
thing
Software
service
means
offering
software
functionality
users
remotely
web
rather
applications
installed
user
s
computer
Service
oriented
systems
systems
implemented
using
reusable
service
components
accessed
programs
rather
directly
users
Software
offered
service
implemented
using
service
oriented
system
However
don
t
implement
software
way
offer
user
service
Adopting
service
oriented
approach
software
engineering
number
important
benefits
Services
offered
service
provider
inside
outside
organization
Assuming
services
conform
certain
standards
organizations
create
applications
integrating
services
range
providers
example
manufacturing
company
link
directly
services
provided
suppliers
service
provider
makes
information
service
public
authorized
user
use
service
service
provider
service
user
need
negotiate
service
incorporated
application
program
Applications
delay
binding
services
deployed
execution
Therefore
application
using
stock
price
service
say
principle
dynamically
change
service
providers
system
executing
means
applications
reactive
adapt
operation
cope
changes
execution
environment
Opportunistic
construction
new
services
possible
service
provider
recognize
new
services
created
linking
existing
services
innovative
ways
Service
users
pay
services
according
use
rather
provision
Therefore
instead
buying
expensive
component
rarely
used
application
writer
use
external
service
paid
required
Applications
made
smaller
particularly
important
mobile
devices
limited
processing
memory
capabilities
computationally
intensive
processing
exception
handling
offloaded
external
services
Service
oriented
systems
loosely
coupled
architectures
service
bindings
change
system
execution
different
equivalent
version
service
therefore
executed
different
times
systems
solely
built
using
web
services
others
mix
web
services
locally
developed
components
illustrate
applications
use
mixture
services
components
organized
consider
following
scenario
car
information
system
provides
drivers
information
weather
road
traffic
conditions
local
information
forth
linked
car
@@@@@@@@@@
Chapter
Service
oriented
software
engineering
User
interface
Locator
Discovers
car
position
Weather
info
Receives
request
user
Receiver
Receives
information
stream
services
Transmitter
Sends
position
information
request
services
Radio
Translates
digital
info
stream
radio
signal
car
software
system
Mobile
Info
Service
Facilities
info
Translator
Road
locator
Traffic
info
Collates
information
Road
traffic
info
command
gps
coord
gps
coord
gps
coordgps
coord
Language
infoInfo
stream
Service
discovery
Finds
available
services
Figure
service
based
car
information
system
radio
information
delivered
signal
specific
radio
channel
car
equipped
GPS
receiver
discover
position
based
position
system
accesses
range
information
services
Information
delivered
driver
s
specified
language
Figure
illustrates
possible
organization
system
car
software
includes
five
modules
handle
communications
driver
GPS
receiver
reports
car
s
position
car
radio
Transmitter
Receiver
modules
handle
communications
external
services
car
communicates
external
mobile
information
service
aggregates
information
range
services
providing
information
weather
traffic
local
facilities
Different
providers
different
places
offer
services
car
system
accesses
external
discovery
service
find
services
available
local
area
mobile
information
service
uses
discovery
service
bind
appropriate
weather
traffic
facilities
services
aggregated
information
sent
car
service
translates
information
driver
s
preferred
language
example
illustrates
one
key
advantages
service
oriented
approach
system
programmed
deployed
don
t
decide
service
@@@@@@@@@@
Chapter
Service
oriented
software
engineering
provider
used
specific
services
accessed
car
moves
around
car
software
uses
service
discovery
service
find
useful
local
information
service
use
translation
service
move
across
borders
make
local
information
available
people
don
t
speak
local
language
think
service
oriented
approach
software
engineering
important
development
object
oriented
software
engineering
Service
oriented
systems
essential
cloud
mobile
systems
Newcomer
Lomow
Newcomer
Lomow
book
SOA
summarize
potential
service
oriented
approaches
now
realized
Driven
convergence
key
technologies
universal
adoption
Web
services
service
oriented
enterprise
promises
significantly
improve
corporate
agility
speed
time
market
new
products
services
reduce
costs
improve
operational
efficiency
Building
applications
based
services
allows
companies
organizations
cooperate
make
use
s
business
functions
Thus
systems
involve
extensive
information
exchange
across
company
boundaries
supply
chain
systems
one
company
orders
goods
another
easily
automated
Service
based
applications
constructed
linking
services
various
providers
using
standard
programming
language
specialized
workflow
language
discussed
Section
Initial
work
service
provision
implementation
heavily
influenced
failure
software
industry
agree
component
standards
therefore
standards
driven
main
industrial
companies
involved
standards
development
led
whole
range
standards
WS
standards
notion
service
oriented
architectures
proposed
architectures
service
based
systems
service
communication
standards
based
However
standards
proposed
complex
significant
execution
overhead
problem
led
many
companies
adopt
alternative
architectural
approach
based
called
RESTful
services
RESTful
approach
simpler
approach
service
oriented
architecture
less
suited
services
offer
complex
functionality
discuss
architectural
approaches
chapter
Service
oriented
architecture
Service
oriented
architecture
SOA
architectural
style
based
idea
executable
services
included
applications
Services
well
defined
published
interfaces
applications
choose
appropriate
important
idea
underlying
SOA
service
available
different
providers
applications
make
runtime
decision
service
provider
use
Newcomer
E
Lomow
G
Understanding
SOA
Web
Services
Boston
Addison
Wesley
@@@@@@@@@@
Service
oriented
architecture
Figure
Service
oriented
architecture
Service
registry
Service
requestor
Service
provider
Service
Find
Publish
Bind
SOAP
WSDL
XML
technologies
XML
XSD
XSLT
Support
WS
Security
WS
Addressing
Process
WS
BPEL
Service
definition
UDDI
WSDL
Figure
Web
service
standards
Messaging
SOAP
Transport
HTTP
HTTPS
SMTP
Figure
illustrates
structure
service
oriented
architecture
Service
providers
design
implement
services
specify
interface
services
publish
information
services
accessible
registry
Service
requestors
sometimes
called
service
clients
wish
make
use
service
discover
specification
service
locate
service
provider
bind
application
specific
service
communicate
using
standard
service
protocols
development
use
internationally
agreed
standards
fundamental
SOA
result
service
oriented
architectures
suffered
incompatibilities
normally
arise
technical
innovations
different
suppliers
maintain
proprietary
version
technology
Figure
shows
stack
key
standards
established
support
web
services
Web
service
protocols
cover
aspects
service
oriented
architectures
basic
mechanisms
service
information
exchange
SOAP
programming
language
standards
WS
BPEL
standards
based
XML
human
machine
readable
notation
allows
definition
structured
data
text
tagged
meaningful
identifier
XML
range
supporting
technologies
XSD
schema
definition
used
extend
manipulate
XML
descriptions
Erl
Erl
provides
good
summary
XML
technologies
role
web
services
Briefly
fundamental
standards
service
oriented
architectures
SOAP
message
interchange
standard
supports
communication
services
defines
essential
optional
components
messages
@@@@@@@@@@
passed
services
Services
service
oriented
architecture
sometimes
called
SOAP
based
services
WSDL
Web
Service
Description
Language
WSDL
standard
service
interface
definition
sets
service
operations
operation
names
parameters
types
service
bindings
defined
WS
BPEL
standard
workflow
language
used
define
process
programs
involving
several
different
services
explain
process
programs
Section
UDDI
Universal
Description
Discovery
Integration
discovery
standard
defines
components
service
specification
intended
help
potential
users
discover
existence
service
standard
meant
allow
companies
set
registries
UDDI
descriptions
defining
services
offered
companies
set
UDDI
registries
early
years
st
century
users
preferred
standard
search
engines
find
services
public
UDDI
registries
now
closed
principal
SOA
standards
supported
range
supporting
standards
focus
specialized
aspects
SOA
many
supporting
standards
intended
support
SOA
different
types
enterprise
application
examples
standards
include
WS
Reliable
Messaging
standard
message
exchange
ensures
messages
delivered
WS
Security
set
standards
supporting
web
service
security
including
standards
specify
definition
security
policies
standards
cover
use
digital
signatures
WS
Addressing
defines
address
information
represented
SOAP
message
WS
Transactions
defines
transactions
across
distributed
services
coordinated
Web
service
standards
huge
topic
don
t
space
discuss
detail
recommend
Erl
s
books
Erl
overview
standards
detailed
descriptions
available
public
documents
Web
W
C
Service
components
SOA
Message
exchange
explained
Section
important
mechanism
coordinating
actions
distributed
computing
system
Services
SOA
communicate
exchanging
messages
expressed
XML
messages
distributed
using
standard
Internet
transport
protocols
HTTP
TCP
IP
service
defines
needs
another
service
setting
requirements
message
sent
service
receiving
service
parses
@@@@@@@@@@
Service
oriented
architecture
WSDL
service
definition
Intro
XML
namespace
declarations
Type
declarations
Abstract
interface
Interface
declarations
Message
declarations
Concrete
Binding
declarations
Organization
WSDL
implementation
Endpoint
declarations
specification
Figure
message
carries
computation
upon
completion
sends
reply
message
requesting
service
service
parses
reply
extract
required
information
Unlike
software
components
services
use
remote
procedure
method
calls
access
functionality
associated
services
intend
use
web
service
need
know
service
located
Uniform
Resource
Identifier
URI
details
interface
details
provided
service
description
written
XML
based
language
called
WSDL
Web
Service
Description
Language
WSDL
specification
defines
three
aspects
Web
service
service
communicates
find
part
WSDL
document
called
interface
specifies
operations
service
supports
defines
format
messages
sent
received
service
part
WSDL
document
called
binding
maps
abstract
interface
concrete
set
protocols
binding
specifies
technical
details
communicate
Web
service
part
WSDL
document
describes
location
specific
Web
service
implementation
endpoint
WSDL
conceptual
model
Figure
shows
elements
service
description
element
expressed
XML
provided
separate
files
elements
introductory
part
usually
defines
XML
namespaces
used
include
documentation
section
providing
additional
information
service
optional
description
types
used
messages
exchanged
service
description
service
interface
operations
service
provides
services
users
description
input
output
messages
processed
service
description
binding
used
service
messaging
protocol
used
send
receive
messages
default
SOAP
@@@@@@@@@@
Define
types
used
Assume
namespace
prefixes
ws
refers
namespace
URI
XML
schemas
namespace
prefix
associated
definition
weathns
types
xs
schema
targetNameSpace
http
weathns
xmlns
weathns
http
weathns
xs
element
name
PlaceAndDate
type
pdrec
xs
element
name
MaxMinTemp
type
mmtrec
xs
element
name
InDataFault
type
errmess
xs
complexType
name
pdrec
xs
sequence
xs
element
name
town
type
xs
string
xs
element
name
country
type
xs
string
xs
element
name
day
type
xs
date
xs
complexType
Definitions
MaxMinType
InDataFault
schema
types
Now
define
interface
operations
case
single
operation
return
maximum
minimum
temperatures
interface
name
weatherInfo
operation
name
getMaxMinTemps
pattern
wsdlns
input
messageLabel
element
weathns
PlaceAndDate
output
messageLabel
element
weathns
MaxMinTemp
outfault
messageLabel
element
weathns
InDataFault
operation
interface
Figure
Part
bindings
specified
binding
sets
input
output
WSDL
description
messages
associated
service
packaged
message
web
service
specifies
communication
protocols
used
binding
specify
supporting
information
security
credentials
transaction
identifiers
included
messages
service
endpoint
specification
physical
location
service
expressed
URI
address
resource
accessed
Internet
Figure
shows
part
interface
simple
service
given
date
place
specified
town
country
returns
maximum
minimum
temperature
recorded
place
date
input
message
specifies
temperatures
returned
degrees
Celsius
degrees
Fahrenheit
XML
based
service
descriptions
include
definitions
XML
namespaces
names
pace
identifier
precede
identifier
used
XML
description
making
possible
distinguish
identifiers
name
defined
different
parts
XML
description
don
t
understand
details
namespaces
@@@@@@@@@@
RESTful
services
understand
examples
need
know
names
prefixed
namespace
identifier
namespace
name
pair
unique
Figure
first
part
description
shows
part
element
type
definition
used
service
specification
defines
elements
PlaceAndDate
MaxMinTemp
InDataFault
included
specification
PlaceAndDate
think
record
three
fields
town
country
date
similar
approach
used
define
MaxMinTemp
InDataFault
second
part
description
shows
service
interface
defined
example
service
weatherInfo
single
operation
no
restrictions
number
operations
defined
weatherInfo
operation
associated
pattern
meaning
takes
one
input
message
generates
one
output
message
WSDL
specification
allows
number
message
exchange
patterns
optional
input
output
messages
refer
definitions
made
earlier
types
section
defined
service
interface
defined
WSDL
simply
description
service
signature
operations
parameters
include
information
semantics
service
non
functional
characteristics
performance
dependability
plan
use
service
work
service
meaning
input
output
messages
experiment
discover
service
s
performance
dependability
meaningful
names
documentation
help
understanding
service
functionality
still
possible
misunderstand
service
XML
based
service
descriptions
long
detailed
tedious
read
WSDL
specifications
normally
written
hand
information
specification
automatically
generated
RESTful
services
initial
developments
web
services
service
oriented
software
engineering
standards
based
XML
based
messages
exchanged
services
general
approach
allows
development
complex
services
dynamic
service
binding
control
quality
service
service
dependability
However
services
developed
emerged
single
function
services
relatively
simple
input
output
interfaces
Service
users
really
interested
dynamic
binding
use
multiple
service
providers
rarely
use
web
service
standards
quality
service
reliability
forth
problem
web
services
standards
heavyweight
standards
sometimes
overly
general
inefficient
Implementing
standards
requires
considerable
amount
processing
create
transmit
interpret
associated
XML
messages
slows
communications
services
high
throughput
systems
additional
hardware
required
deliver
quality
service
required
response
situation
alternative
lightweight
approach
web
service
architecture
developed
approach
based
REST
architectural
@@@@@@@@@@
CREATE
POST
POST
URL
DELETE
Figure
Resources
actions
Resource
R
Web
accessible
READ
DELETE
GET
resource
R
UPDATE
PUT
b
Web
resources
General
resource
actions
style
REST
stands
Representational
State
Transfer
Fielding
REST
architectural
style
based
transferring
representations
resources
server
client
style
underlies
web
whole
used
much
simpler
method
SOAP
WSDL
implementing
web
service
interfaces
fundamental
element
RESTful
architecture
resource
Essentially
resource
simply
data
element
catalog
medical
record
document
book
chapter
general
resources
multiple
representations
exist
different
formats
example
book
chapter
three
representations
MS
Word
representation
used
editing
PDF
representation
used
web
display
InDesign
representation
used
publishing
underlying
logical
resource
made
text
images
representations
RESTful
architecture
everything
represented
resource
Resources
unique
identifier
URL
Resources
bit
like
objects
four
fundamental
polymorphic
operations
associated
shown
Figure
Create
bring
resource
existence
Read
return
representation
resource
Update
change
value
resource
Delete
make
resource
inaccessible
Web
example
system
RESTful
architecture
Web
pages
resources
unique
identifier
web
page
URL
web
protocols
http
https
based
four
actions
namely
POST
GET
PUT
DELETE
map
onto
basic
resource
operations
shown
Figure
b
POST
used
create
resource
associated
data
defines
resource
GET
used
read
value
resource
return
requestor
specified
representation
XHTML
rendered
web
browser
@@@@@@@@@@
RESTful
services
PUT
used
update
value
resource
DELETE
used
delete
resource
services
way
operate
data
example
service
described
Section
returns
maximum
minimum
temperatures
location
given
data
uses
weather
information
database
SOAP
based
services
execute
actions
database
return
particular
values
RESTful
services
Richardson
Ruby
access
data
directly
RESTful
approach
used
data
exposed
accessed
using
URL
RESTful
services
use
http
https
protocols
allowed
actions
POST
GET
PUT
DELETE
Therefore
weather
data
place
database
accessed
using
URLs
http
weather
info
example
net
temperatures
boston
http
weather
info
example
net
temperatures
edinburgh
invoke
GET
operation
return
list
maximum
minimum
temperatures
request
temperatures
specific
date
URL
query
used
http
weather
info
example
net
temperatures
edinburgh
date
URL
queries
used
disambiguate
request
given
several
places
world
name
http
weather
info
example
net
temperatures
boston
date
country
USA
state
Mass
important
difference
RESTful
services
SOAP
based
services
RESTful
services
exclusively
XML
based
resource
requested
created
changed
representation
specified
important
RESTful
services
representations
JSON
Javascript
Object
Notation
well
XML
used
processed
efficiently
XML
based
notations
thus
reducing
overhead
involved
service
call
Therefore
request
maximum
minimum
temperatures
Boston
return
following
information
place
Boston
country
USA
state
Mass
date
Feb
units
Fahrenheit
max
temp
min
temp
response
GET
request
RESTful
service
include
URLs
Therefore
response
request
set
resources
URL
@@@@@@@@@@
Figure
RESTful
SOAP
based
APIs
Service
requestor
Resource
R
Restful
API
SOAP
based
Service
API
requestor
services
included
requesting
service
process
requests
way
Therefore
request
weather
information
given
place
name
unique
return
URLs
places
match
request
example
http
weather
info
example
net
temperatures
edinburgh
scotland
http
weather
info
example
net
temperatures
edinburgh
australia
http
weather
info
example
net
temperatures
edinburgh
maryland
fundamental
design
principle
RESTful
services
stateless
interaction
session
resource
include
state
information
time
last
request
Instead
necessary
state
information
returned
requestor
state
information
required
later
requests
returned
server
requestor
RESTful
services
widely
used
past
years
widespread
use
mobile
devices
devices
limited
processing
capabilities
lower
overhead
RESTful
services
allows
better
system
performance
easy
use
existing
websites
implementing
RESTful
API
website
usually
fairly
straightforward
However
problems
RESTful
approach
service
complex
interface
simple
resource
difficult
design
set
RESTful
services
represent
interface
no
standards
RESTful
interface
description
service
users
rely
informal
documentation
understand
interface
use
RESTful
services
implement
infrastructure
monitoring
managing
quality
service
service
reliability
SOAP
based
services
additional
infrastructure
support
standards
WS
Reliability
WS
Transactions
Pautasso
et
al
Pautasso
Zimmermann
Leymann
discuss
RESTful
SOAP
based
used
However
often
possible
provide
SOAP
based
RESTful
interfaces
service
resource
Figure
dual
approach
now
common
cloud
services
providers
Microsoft
Google
Amazon
Service
clients
choose
service
access
method
best
suited
applications
@@@@@@@@@@
Service
engineering
Figure
service
engineering
process
Service
design
Service
candidate
identification
Service
Service
interface
requirements
specification
Service
implementation
deployment
Validated
deployed
service
Service
engineering
Service
engineering
process
developing
services
reuse
service
oriented
applications
much
common
component
engineering
Service
engineers
ensure
service
represents
reusable
abstraction
useful
different
systems
design
develop
generally
useful
functionality
associated
abstraction
ensure
service
robust
reliable
document
service
discovered
understood
potential
users
shown
Figure
three
logical
stages
service
engineering
process
Service
candidate
identification
identify
possible
services
implemented
define
service
requirements
Service
design
design
logical
service
interface
implementation
interfaces
SOAP
based
RESTful
Service
implementation
deployment
implement
test
service
make
available
use
discussed
Chapter
development
reusable
component
start
existing
component
already
implemented
used
application
true
services
starting
point
process
often
existing
service
component
converted
service
situation
design
process
involves
generalizing
existing
component
application
specific
features
removed
Implementation
means
adapting
component
adding
service
interfaces
implementing
required
generalizations
Service
candidate
identification
basic
idea
service
oriented
computing
services
support
business
processes
every
organization
wide
range
processes
many
possible
services
implemented
Service
candidate
identification
therefore
involves
@@@@@@@@@@
Utility
Business
Coordination
Utility
Business
Coordination
Task
Currency
converter
Validate
claim
form
Process
expense
claim
Employee
locator
Check
credit
rating
Pay
external
supplier
Entity
Document
translator
Web
form
XML
converter
Expenses
form
Student
application
form
Figure
Service
understanding
analyzing
organization
s
business
processes
decide
classification
reusable
services
implemented
support
processes
Erl
Erl
suggests
three
fundamental
types
service
Utility
services
services
implement
general
functionality
used
different
business
processes
example
utility
service
currency
conversion
service
accessed
compute
conversion
one
currency
e
g
dollars
another
e
g
euros
Business
services
services
associated
specific
business
function
example
business
function
university
registration
students
course
Coordination
process
services
services
support
general
business
process
usually
involves
different
actors
activities
example
coordination
service
company
ordering
service
allows
orders
placed
suppliers
goods
accepted
payments
made
Erl
suggests
services
thought
task
oriented
entity
oriented
Task
oriented
services
associated
activity
entity
oriented
services
associated
system
resource
resource
business
entity
job
application
form
Figure
shows
examples
services
task
oriented
entity
oriented
Utility
business
services
entity
oriented
task
oriented
Coordination
services
task
oriented
goal
service
candidate
identification
identify
services
logically
coherent
independent
reusable
Erl
s
classification
helpful
respect
suggests
discover
reusable
services
looking
business
entities
resources
business
activities
However
identifying
service
candidates
sometimes
difficult
envisage
services
used
think
possible
candidates
ask
series
questions
see
likely
useful
services
Possible
questions
ask
identify
potentially
reusable
services
entity
oriented
service
service
associated
single
logical
resource
used
different
business
processes
operations
normally
performed
entity
supported
fit
RESTful
service
operations
PUT
CREATE
POST
DELETE
task
oriented
service
task
one
carried
different
people
organization
willing
accept
inevitable
standardization
@@@@@@@@@@
Service
engineering
occurs
single
support
service
provided
fit
RESTful
model
redesigned
entity
oriented
service
service
independent
extent
rely
availability
services
service
maintain
state
state
information
required
maintained
database
passed
parameter
service
Using
database
affects
service
reusability
dependency
service
required
database
general
services
state
passed
service
easier
reuse
no
database
binding
required
service
used
external
clients
example
entity
oriented
service
associated
catalog
made
available
internal
external
users
different
users
service
likely
different
non
functional
requirements
one
version
service
perhaps
implemented
answers
questions
help
select
refine
abstractions
implemented
services
However
no
formulaic
way
deciding
best
services
need
use
experience
business
knowledge
decide
appropriate
services
output
service
selection
process
set
identified
services
associated
requirements
services
functional
service
requirements
define
service
non
functional
requirements
define
security
performance
availability
requirements
service
help
understand
process
service
candidate
identification
implementation
consider
following
example
company
sells
computer
equipment
arranged
special
prices
approved
configurations
large
customers
facilitate
automated
ordering
company
wishes
produce
catalog
service
allow
customers
select
equipment
need
Unlike
consumer
catalog
orders
placed
directly
catalog
interface
Instead
goods
ordered
web
based
procurement
system
company
accesses
catalog
web
service
reason
large
companies
usually
budgeting
approval
procedures
orders
followed
order
placed
catalog
service
example
entity
oriented
service
underlying
resource
catalog
functional
catalog
service
requirements
follows
specific
version
catalog
shall
provided
user
company
shall
include
approved
configurations
equipment
ordered
@@@@@@@@@@
employees
customer
company
equipment
prices
agreed
company
catalog
shall
allow
customer
employee
download
version
catalog
offline
browsing
catalog
shall
allow
users
compare
specifications
prices
six
catalog
items
catalog
shall
provide
browsing
search
facilities
users
Users
catalog
shall
able
discover
predicted
delivery
date
given
number
specific
catalog
items
Users
catalog
shall
able
place
virtual
orders
items
required
reserved
hours
Virtual
orders
confirmed
real
order
placed
procurement
system
real
order
received
hours
virtual
order
addition
functional
requirements
catalog
number
nonfunctional
requirements
Access
catalog
service
shall
restricted
employees
accredited
organizations
prices
configurations
offered
customer
shall
confidential
access
shall
provided
employees
customer
catalog
shall
available
without
disruption
service
GMT
GMT
catalog
service
shall
able
process
requests
per
second
peak
load
no
non
functional
requirement
related
response
time
catalog
service
depends
size
catalog
expected
number
simultaneous
users
time
critical
service
no
need
specify
required
performance
stage
Service
interface
design
identified
candidate
services
next
stage
service
engineering
process
design
service
interfaces
involves
defining
operations
associated
service
parameters
SOAP
based
services
used
design
input
output
messages
RESTful
services
used
think
resources
required
standard
operations
used
implement
service
operations
starting
point
service
interface
design
abstract
interface
design
identify
entities
operations
associated
service
inputs
@@@@@@@@@@
Service
engineering
Operation
Description
MakeCatalog
Creates
version
catalog
tailored
specific
customer
Includes
optional
parameter
create
downloadable
PDF
version
catalog
Lookup
Displays
data
associated
specified
catalog
item
Search
Takes
logical
expression
searches
catalog
according
expression
displays
list
items
match
search
expression
Compare
Provides
comparison
six
characteristics
e
g
price
dimensions
processor
speed
etc
four
catalog
items
CheckDelivery
Returns
predicted
delivery
date
item
ordered
day
MakeVirtualOrder
Reserves
number
items
ordered
customer
provides
item
information
customer
s
procurement
system
Figure
Catalog
operations
outputs
exceptions
associated
operations
need
think
abstract
interface
realized
SOAP
based
RESTful
services
choose
SOAP
based
approach
design
structure
XML
messages
sent
received
service
operations
messages
basis
interface
description
written
WSDL
choose
RESTful
approach
design
service
operations
map
onto
RESTful
operations
Abstract
interface
design
starts
service
requirements
defines
operation
names
parameters
stage
define
exceptions
arise
service
operation
invoked
Figure
shows
catalog
operations
implement
requirements
no
need
specified
detail
add
detail
next
stage
design
process
established
informal
description
service
next
stage
add
detail
service
inputs
outputs
shown
catalog
service
Figure
extends
functional
description
Figure
Defining
exceptions
exceptions
communicated
service
users
particularly
important
Service
engineers
know
services
used
usually
unwise
make
assumptions
service
users
completely
understood
service
specification
Input
messages
incorrect
define
exceptions
report
incorrect
inputs
service
client
generally
good
practice
reusable
component
development
leave
exception
handling
user
component
Service
developers
impose
views
exceptions
handled
cases
textual
description
operations
inputs
outputs
required
detailed
realization
service
left
implementation
decision
Sometimes
however
need
detailed
design
detailed
interface
description
specified
graphical
notation
UML
readable
description
format
JSON
Figure
describes
inputs
outputs
getDelivery
operation
shows
use
UML
describe
interface
detail
@@@@@@@@@@
Operation
Inputs
Outputs
Exceptions
Operation
Inputs
Outputs
Exceptions
MakeCatalog
mcIn
mcOut
mcFault
Company
id
URL
catalog
Invalid
company
id
PDF
flag
company
Lookup
lookIn
Catalog
URL
Catalog
number
lookOut
URL
page
item
information
lookFault
Invalid
catalog
number
Search
searchIn
Catalog
URL
Search
string
searchOut
URL
web
page
search
results
searchFault
Badly
formed
search
string
Compare
compIn
Catalog
URL
Entry
attribute
Catalog
number
compOut
URL
page
showing
comparison
table
compFault
Invalid
company
id
Invalid
catalog
number
Unknown
attribute
CheckDelivery
cdIn
Company
id
Catalog
number
Number
items
required
cdOut
Expected
delivery
date
cdFault
Invalid
company
id
No
availability
Zero
items
requested
MakeVirtualOrder
voIn
Company
id
Catalog
number
Number
items
required
voOut
Catalog
number
Number
items
required
Predicted
delivery
date
Unit
price
estimate
Total
price
estimate
voFault
Invalid
company
id
Invalid
catalog
number
Zero
items
requested
Figure
Catalog
interface
design
cdIn
cID
string
catNum
string
numItems
integer
size
cID
size
catNum
numItems
cdOut
catNum
string
delivDate
date
size
catNum
delivDate
Today
cdFault
errCode
integer
Invalid
company
id
errCode
Invalid
catalog
number
errCode
No
availability
errCode
Zero
items
requested
errCode
Figure
UML
definition
input
output
messages
@@@@@@@@@@
Service
engineering
Notice
added
detail
description
annotating
UML
diagram
constraints
details
define
length
strings
representing
company
catalog
item
specify
number
items
greater
zero
delivery
current
date
annotations
show
error
codes
associated
possible
fault
catalog
service
example
practical
service
illustrates
straightforward
choose
RESTful
SOAP
based
approach
service
implementation
entity
based
service
catalog
represented
resource
suggests
RESTful
model
right
one
use
However
operations
catalog
simple
GET
operations
need
maintain
state
interaction
session
catalog
suggests
use
SOAP
based
approach
dilemmas
common
service
engineering
usually
local
circumstances
e
g
availability
expertise
major
factor
decision
approach
use
implement
set
RESTful
services
decide
set
resources
used
represent
catalog
fundamental
GET
POST
PUT
operations
operate
resources
design
decisions
straightforward
resource
representing
company
specific
catalog
URL
form
base
catalog
company
name
created
using
POST
operation
catalog
item
URL
form
base
catalog
company
name
item
identifier
use
GET
operation
retrieve
items
Lookup
implemented
using
URL
item
catalog
GET
parameter
Search
implemented
using
GET
company
catalog
URL
search
string
query
parameter
GET
operation
returns
list
URLs
items
matching
search
However
Compare
CheckDelivery
MakeVirtualOrder
operations
complex
Compare
operation
implemented
sequence
GET
operations
retrieve
individual
items
followed
POST
operation
create
comparison
table
final
GET
operation
return
user
CheckDelivery
MakeVirtualOrder
operations
require
additional
resource
representing
virtual
order
POST
operation
used
create
resource
number
items
required
company
id
used
automatically
fill
order
form
delivery
date
calculated
resource
retrieved
using
GET
operation
need
think
carefully
exceptions
mapped
onto
standard
http
response
codes
code
meaning
URL
cannot
retrieved
don
t
space
go
issue
adds
level
complexity
service
interface
design
@@@@@@@@@@
Legacy
system
services
Legacy
systems
old
software
systems
used
organization
cost
effective
rewrite
replace
systems
many
organizations
like
use
conjunction
modern
systems
One
important
uses
services
implement
wrappers
legacy
systems
provide
access
system
s
functions
data
systems
accessed
web
integrated
applications
http
software
engineering
book
com
web
legacy
services
SOAP
based
services
realization
process
case
simpler
logical
interface
design
translated
automatically
WSDL
programming
environments
support
service
oriented
development
e
g
ECLIPSE
environment
include
tools
translate
logical
interface
description
corresponding
WSDL
representation
Service
implementation
deployment
identified
candidate
services
designed
interfaces
final
stage
service
engineering
process
service
implementation
implementation
involve
programming
service
using
language
Java
C
languages
include
libraries
extensive
support
developing
SOAP
based
RESTful
services
Alternatively
implement
services
creating
service
interfaces
existing
components
legacy
systems
Software
assets
already
proved
useful
therefore
made
available
reuse
case
legacy
systems
mean
system
functionality
accessed
new
applications
develop
new
services
defining
compositions
existing
services
explain
Section
service
implemented
tested
deployed
involves
examining
partitioning
service
inputs
explained
Chapter
creating
input
messages
reflect
input
combinations
checking
outputs
expected
try
generate
exceptions
test
check
service
cope
invalid
inputs
SOAP
based
services
testing
tools
available
allow
services
examined
tested
generate
tests
WSDL
specification
However
tools
test
conformity
service
interface
WSDL
cannot
test
service
s
functional
behavior
Service
deployment
final
stage
process
involves
making
service
available
use
web
server
server
software
makes
operation
straightforward
install
file
containing
executable
service
specific
directory
automatically
becomes
available
use
service
intended
available
large
organization
publicly
available
service
provide
documentation
external
service
users
Potential
users
decide
service
likely
meet
needs
@@@@@@@@@@
Service
composition
trust
service
provider
deliver
service
reliably
securely
Information
include
service
description
Information
business
contact
details
important
trust
reasons
External
users
service
confident
behave
maliciously
Information
service
provider
allows
users
check
credentials
business
information
agencies
informal
description
functionality
provided
service
helps
potential
users
decide
service
want
description
use
service
simple
services
informal
textual
description
explains
input
output
parameters
complex
SOAP
based
services
WSDL
description
published
Subscription
information
allows
users
register
information
updates
service
general
difficulty
service
specifications
functional
behavior
service
usually
specified
informally
natural
language
description
Natural
language
descriptions
easy
read
subject
misinterpretation
address
problem
extensive
research
using
ontologies
ontology
languages
specifying
service
semantics
marking
service
ontology
information
W
C
However
ontology
based
specification
complex
widely
understood
Consequently
widely
used
Service
composition
underlying
principle
service
oriented
software
engineering
compose
configure
services
create
new
composite
services
integrated
user
interface
implemented
browser
create
web
application
used
components
service
composition
services
involved
composition
specially
developed
application
business
services
developed
company
services
external
provider
RESTful
SOAP
based
services
composed
create
services
extended
functionality
Many
companies
converted
enterprise
applications
service
oriented
systems
basic
application
building
block
service
rather
component
allows
widespread
reuse
company
now
seeing
emergence
interorganizational
applications
trusted
suppliers
use
s
services
final
realization
long
term
vision
service
oriented
systems
rely
development
services
market
services
bought
trusted
external
suppliers
Service
composition
used
integrate
separate
business
processes
provide
integrated
process
offering
extensive
functionality
Say
airline
wishes
develop
travel
aggregation
service
provides
complete
vacation
package
@@@@@@@@@@
Figure
Vacation
package
workflow
Book
flights
Book
hotel
Arrange
car
taxi
Browse
attractions
Book
attractions
Dates
preferences
Arrival
departure
dates
times
Hotel
location
travelers
addition
booking
flights
travelers
book
hotels
preferred
location
arrange
car
rental
book
taxi
airport
browse
travel
guide
make
reservations
visit
local
attractions
create
application
airline
composes
booking
service
services
offered
hotel
booking
agency
rental
car
taxi
companies
reservation
services
offered
owners
local
attractions
end
result
single
service
integrates
services
different
providers
think
process
sequence
separate
steps
shown
Figure
Information
passed
one
step
next
example
rental
car
company
informed
time
flight
scheduled
arrive
sequence
steps
called
workflow
set
activities
ordered
time
activity
carrying
part
work
workflow
model
business
process
sets
steps
involved
reaching
particular
goal
important
business
case
business
process
vacation
booking
service
offered
airline
Workflow
simple
idea
scenario
booking
vacation
seems
straightforward
practice
service
composition
usually
complex
simple
model
implies
consider
possibility
service
failure
include
exception
management
handle
failures
take
account
nonstandard
demands
made
users
application
example
say
traveler
disabled
required
wheelchair
rented
delivered
airport
require
extra
services
implemented
composed
additional
steps
added
workflow
designing
travel
aggregation
service
able
cope
situations
normal
execution
one
services
results
incompatibility
service
execution
example
say
flight
booked
leave
June
return
June
workflow
proceeds
hotel
booking
stage
However
resort
hosting
major
convention
June
no
hotel
rooms
available
hotel
booking
service
reports
lack
availability
failure
lack
availability
common
situation
therefore
undo
flight
booking
pass
information
lack
availability
back
user
decide
change
dates
resort
workflow
terminology
called
compensation
action
Compensation
actions
used
undo
actions
already
completed
changed
result
later
workflow
activities
process
designing
new
services
reusing
existing
services
process
software
design
reuse
Figure
Design
reuse
inevitably
involves
requirements
compromises
ideal
requirements
system
modified
reflect
services
available
costs
fall
budget
quality
service
acceptable
@@@@@@@@@@
Service
composition
Formulate
outline
workflow
Discover
services
Workflow
design
Service
list
Service
specifications
Select
services
Refine
workflow
Create
workflow
program
Test
service
Workflow
design
Executable
workflow
Deployable
service
Figure
Service
construction
shown
six
key
stages
process
system
construction
composicomposition
tion
Figure
Formulate
outline
workflow
initial
stage
service
design
use
requirements
composite
service
basis
creating
ideal
service
design
create
fairly
abstract
design
stage
intention
adding
details
know
available
services
Discover
services
stage
process
look
existing
services
include
composition
service
reuse
enterprises
involve
searching
local
service
catalogs
Alternatively
search
services
offered
trusted
service
providers
Oracle
Microsoft
Select
possible
services
set
possible
service
candidates
discovered
select
possible
services
implement
workflow
activities
selection
criteria
obviously
include
functionality
services
offered
include
cost
services
quality
service
responsiveness
availability
etc
offered
Refine
workflow
basis
information
services
selected
refine
workflow
involves
adding
detail
abstract
description
perhaps
adding
removing
workflow
activities
repeat
service
discovery
selection
stages
stable
set
services
chosen
final
workflow
design
established
move
next
stage
process
Create
workflow
program
stage
abstract
workflow
design
transformed
executable
program
service
interface
defined
implement
workflow
programs
using
programming
language
Java
C
using
workflow
language
BPMN
explained
stage
involve
creation
web
based
user
interfaces
allow
new
service
accessed
web
browser
Test
completed
service
application
process
testing
completed
composite
service
complex
component
testing
situations
external
services
used
discuss
testing
issues
Section
process
assumes
existing
services
available
composition
rely
external
information
available
service
interface
implement
services
usually
involves
screen
@@@@@@@@@@
scraping
process
program
extracts
information
HTML
text
web
pages
sent
browser
rendering
Workflow
design
implementation
Workflow
design
involves
analyzing
existing
planned
business
processes
understand
tasks
involved
tasks
exchange
information
define
new
business
process
workflow
design
notation
sets
stages
involved
enacting
process
information
passed
different
process
stages
However
existing
processes
informal
dependent
skills
ability
people
involved
no
normal
way
working
process
definition
cases
use
knowledge
current
process
design
workflow
achieves
goals
Workflows
represent
business
process
models
graphical
models
written
using
UML
activity
diagrams
BPMN
Business
Process
Modeling
Notation
White
Miers
OMG
use
BPMN
examples
chapter
use
SOAP
based
services
possible
convert
BPMN
workflows
automatically
WS
BPEL
XML
based
workflow
language
conformant
web
service
standards
SOAP
WSDL
RESTful
services
composed
program
standard
programming
language
Java
Alternatively
composition
language
used
service
mashups
used
Rosenberg
et
al
Figure
example
simple
BPMN
model
part
vacation
package
scenario
shown
Figure
model
shows
simplified
workflow
hotel
booking
assumes
existence
Hotels
service
associated
operations
called
GetRequirements
CheckAvailability
ReserveRooms
NoAvailability
ConfirmReservation
CancelReservation
process
involves
getting
requirements
customer
checking
room
availability
rooms
available
making
booking
required
dates
model
introduces
core
concepts
BPMN
used
create
workflow
models
Rectangles
rounded
corners
represent
activities
activity
executed
human
automated
service
Circles
represent
discrete
events
event
something
happens
business
process
simple
circle
used
represent
starting
event
darker
circle
represent
end
event
double
circle
shown
used
represent
intermediate
event
Events
clock
events
thus
allowing
workflows
executed
periodically
timed
diamond
used
represent
gateway
gateway
stage
process
choice
made
example
Figure
choice
made
basis
rooms
available
solid
arrow
shows
sequence
activities
dashed
arrow
represents
message
flow
activities
Figure
messages
passed
hotel
booking
service
customer
@@@@@@@@@@
Service
composition
Hotels
GetRequirements
Customer
Hotels
CheckAvailability
Hotels
NoAvailability
Hotels
ReserveRooms
Hotels
ConfirmReservation
Retry
Cancel
Rooms
No
rooms
Figure
fragment
hotel
booking
workflow
key
features
enough
describe
workflows
However
BPMN
includes
many
additional
features
don
t
space
describe
add
information
business
process
description
allows
automatically
translated
executable
service
Figure
shows
process
enacted
single
organization
company
provides
booking
service
However
key
benefit
service
oriented
approach
supports
interorganizational
computing
means
computation
involves
processes
services
different
companies
process
represented
BPMN
developing
separate
workflows
organizations
involved
interactions
illustrate
multiple
workflow
processes
use
different
example
drawn
high
performance
computing
hardware
offered
service
Services
created
provide
access
high
performance
computers
geographically
distributed
user
community
example
vector
processing
computer
machine
carry
parallel
computations
arrays
values
offered
service
VectorProcService
research
laboratory
accessed
another
service
called
SetupComputation
services
interactions
shown
Figure
example
workflow
SetupComputation
service
asks
access
vector
processor
processor
available
establishes
computation
required
downloads
data
processing
service
computation
complete
results
stored
local
computer
workflow
VectorProcService
includes
following
steps
Check
processor
available
Allocate
resources
computation
Initialize
system
@@@@@@@@@@
Chapter
Service
oriented
software
engineering
Request
processor
Set
job
parameters
Download
data
Start
computation
Store
results
Report
completion
Restart
Fail
SetupComputation
Check
Availability
Allocate
resources
Initialize
Compute
Return
results
No
processor
VectorProcService
Figure
Interacting
workflows
Carry
computation
Return
results
client
service
BPMN
terms
workflow
organization
represented
separate
pool
shown
graphically
enclosing
workflow
participant
process
rectangle
name
written
vertically
left
edge
workflows
pool
coordinated
exchanging
messages
situations
different
parts
organization
involved
workflow
pools
divided
named
lanes
lane
shows
activities
part
organization
business
process
model
designed
refined
depending
services
discovered
suggested
discussion
Figure
model
go
number
iterations
design
allows
maximum
possible
reuse
available
services
created
final
design
available
develop
final
service
oriented
system
involves
implementing
services
available
reuse
converting
workflow
model
executable
program
services
implementation
language
independent
new
services
written
language
workflow
model
automatically
processed
create
executable
WS
BPEL
model
SOAP
based
services
used
Alternatively
RESTful
services
used
workflow
manually
programmed
model
acting
program
specification
Testing
service
compositions
Testing
important
system
development
processes
demonstrates
system
meets
functional
non
functional
requirements
detects
defects
@@@@@@@@@@
Service
composition
introduced
development
process
Many
testing
techniques
program
inspections
coverage
testing
rely
analysis
software
source
code
However
use
services
external
provider
access
source
code
service
implementations
cannot
therefore
use
white
box
testing
techniques
rely
source
code
system
well
problems
understanding
implementation
service
testers
face
difficulties
testing
service
compositions
External
services
control
service
provider
rather
user
service
service
provider
withdraw
services
time
make
changes
invalidates
previous
application
testing
problems
handled
software
components
maintaining
different
versions
component
service
versions
normally
supported
services
dynamically
bound
application
use
service
time
executed
Therefore
tests
successful
application
bound
particular
service
cannot
guaranteed
service
used
actual
execution
system
problem
one
reason
dynamic
binding
widely
used
non
functional
behavior
service
simply
dependent
used
application
tested
service
perform
well
testing
operating
heavy
load
practice
observed
service
behavior
different
demands
made
service
users
payment
model
services
make
service
testing
expensive
different
possible
payment
models
services
freely
available
paid
subscription
others
paid
per
use
basis
services
free
service
provider
wish
loaded
applications
tested
subscription
required
service
user
reluctant
enter
subscription
agreement
testing
service
Similarly
usage
based
payment
use
service
users
find
cost
testing
prohibitive
discussed
notion
compensation
actions
invoked
exception
occurs
previous
commitments
made
flight
reservation
revoked
problem
testing
actions
depend
failure
services
Simulating
failure
services
testing
process
usually
difficult
problems
particularly
acute
external
services
used
less
serious
services
used
company
cooperating
companies
trust
services
offered
partners
cases
source
code
available
guide
testing
process
payment
services
unlikely
problem
Resolving
testing
problems
producing
guidelines
tools
techniques
testing
service
oriented
applications
remains
important
research
issue
@@@@@@@@@@
Chapter
Service
oriented
software
engineering
Key
Points
Service
oriented
architecture
approach
software
engineering
reusable
standardized
services
basic
building
blocks
application
systems
Services
implemented
service
oriented
architecture
using
set
XML
based
web
service
standards
include
standards
service
communication
interface
definition
service
enactment
workflows
Alternatively
RESTful
architecture
used
based
resources
standard
operations
resources
RESTful
approach
uses
http
https
protocols
service
communication
maps
operations
standard
http
verbs
POST
GET
PUT
DELETE
Services
classified
utility
services
provide
general
purpose
functionality
business
services
implement
part
business
process
coordination
services
coordinate
execution
services
service
engineering
process
involves
identifying
candidate
services
implementation
defining
service
interface
implementing
testing
deploying
service
development
software
using
services
based
idea
programs
created
composing
configuring
services
create
new
composite
services
systems
Graphical
workflow
languages
BPMN
used
describe
business
process
services
used
process
languages
describe
interactions
organizations
involved
REading
immense
amount
tutorial
material
web
covering
aspects
web
services
However
found
book
Thomas
Erl
best
overview
description
services
service
standards
Erl
includes
discussion
software
engineering
issues
service
oriented
computing
written
recent
books
RESTful
services
Service
Oriented
Architecture
Concepts
Technology
Design
Erl
written
number
books
service
oriented
systems
covering
SOA
RESTful
architectures
book
Erl
discusses
SOA
web
service
standards
mostly
concentrates
discussing
service
oriented
approach
used
stages
software
process
T
Erl
Prentice
Hall
Service
oriented
architecture
good
readable
introduction
SOA
Various
authors
http
msdn
microsoft
com
en
us
library
bb
aspx
RESTful
Web
Services
Basics
good
introductory
tutorial
RESTful
approach
RESTful
services
Rodriguez
https
www
ibm
com
developerworks
webservices
library
ws
restful
Service
Design
Patterns
Fundamental
Design
Solutions
SOAP
WSDL
RESTful
Web
Services
advanced
text
developers
wish
use
web
services
enterprise
applications
describes
number
common
problems
abstract
web
service
solutions
problems
R
Daigneau
Addison
Wesley
@@@@@@@@@@
Chapter
Exercises
Web
Services
Tutorial
extensive
tutorial
aspects
service
oriented
architecture
web
services
web
service
standards
written
people
involved
development
standards
useful
need
detailed
understanding
standards
W
C
schools
http
www
w
schools
com
webservices
default
asp
WEbSiTE
PowerPoint
slides
chapter
www
pearsonglobaleditions
com
Sommerville
Links
supporting
videos
http
software
engineering
book
com
videos
software
reuse
ExERCiSES
important
define
exceptions
service
engineering
Standards
fundamental
service
oriented
architectures
believed
standards
conformance
essential
successful
adoption
service
based
approach
However
RESTful
services
increasingly
widely
used
standards
based
Discuss
think
change
occurred
think
lack
standards
inhibit
development
takeup
RESTful
services
Extend
Figure
include
WSDL
definitions
MaxMinTypeand
InDataFault
temperatures
represented
integers
additional
field
indicating
temperature
degrees
Fahrenheit
degrees
Celsius
InDataFaultshould
simple
type
consisting
error
code
Suggest
SimpleInterestCalculator
service
implemented
RESTful
service
workflow
List
key
stages
process
system
construction
composition
Design
possible
input
output
messages
services
shown
Figure
specify
UML
XML
Giving
reasons
answer
suggest
two
important
types
application
recommend
use
service
oriented
architecture
Explain
meant
compensation
action
using
example
show
actions
included
workflows
@@@@@@@@@@
Chapter
Service
oriented
software
engineering
example
vacation
package
reservation
service
design
workflow
book
ground
transportation
group
passengers
arriving
airport
given
option
booking
taxi
hire
car
assume
taxi
rental
car
companies
offer
web
services
make
reservation
Using
example
explain
detail
thorough
testing
services
include
compensation
actions
difficult
REFEREnCES
Erl
T
Service
Oriented
Architecture
Field
Guide
Integrating
XML
Web
Services
Upper
Saddle
River
NJ
Prentice
Hall
Service
Oriented
Architecture
Concepts
Technology
Design
Upper
Saddle
River
NJ
Prentice
Hall
Fielding
R
Representational
State
Transfer
Architectural
Styles
Design
Network
Based
Software
Architecture
https
www
ics
uci
edu
fielding
pubs
fielding
dissertation
pdf
Lovelock
C
S
Vandermerwe
B
Lewis
Services
Marketing
Englewood
Cliffs
NJ
Prentice
Hall
Newcomer
E
G
Lomow
Understanding
SOA
Web
Services
Boston
Addison
Wesley
OMG
Documents
Associated
Business
Process
Model
Notation
BPMN
Version
http
www
omg
org
spec
BPMN
Pautasso
C
O
Zimmermann
F
Leymann
RESTful
Web
Services
vs
Big
Web
Services
Making
Right
Architectural
Decision
Proc
WWW
Beijing
China
doi
Richardson
L
S
Ruby
RESTful
Web
Services
Sebastopol
CA
O
Reilly
Media
Inc
Rosenberg
F
F
Curbera
M
Duftler
R
Khalaf
Composing
RESTful
Services
Collaborative
Workflows
Lightweight
Approach
IEEE
Internet
Computing
doi
MIC
W
C
OWL
Web
Ontology
Language
http
www
w
org
TR
owl
overview
Web
Services
http
www
w
org
standards
webofservices
White
S
D
Miers
BPMN
Modeling
Reference
Guide
Understanding
Using
BPMN
Lighthouse
Point
FL
USA
Future
Strategies
Inc
@@@@@@@@@@
Systems
engineering
Objectives
objectives
chapter
explain
software
engineers
understand
systems
engineering
introduce
important
systems
engineering
processes
read
chapter
know
meant
sociotechnical
system
understand
human
social
organizational
issues
affect
requirements
design
software
systems
understand
idea
conceptual
design
essential
first
stage
systems
engineering
process
know
meant
system
procurement
understand
different
system
procurement
processes
used
different
types
system
know
key
systems
engineering
development
processes
relationships
Contents
Sociotechnical
systems
Conceptual
design
System
procurement
System
development
System
operation
evolution
@@@@@@@@@@
Chapter
Systems
engineering
computer
becomes
useful
includes
software
hardware
Without
hardware
software
system
abstraction
simply
representation
human
knowledge
ideas
Without
software
hardware
system
set
inert
electronic
devices
However
put
together
form
computer
system
create
machine
carry
complex
computations
deliver
results
computations
environment
illustrates
one
fundamental
characteristics
system
sum
parts
Systems
properties
apparent
components
integrated
operate
together
Furthermore
systems
developed
support
human
activities
work
entertainment
communication
protection
people
environment
interact
people
design
influenced
human
organizational
concerns
Hardware
human
social
organizational
factors
taken
account
developing
professional
software
systems
Systems
include
software
fall
two
categories
Technical
computer
based
systems
systems
include
hardware
software
components
procedures
processes
Examples
technical
systems
include
televisions
mobile
phones
equipment
embedded
software
Applications
PCs
computer
games
mobile
devices
technical
systems
Individuals
organizations
use
technical
systems
particular
purpose
knowledge
purpose
part
technical
system
example
word
processor
using
Microsoft
Word
aware
used
write
book
Sociotechnical
systems
include
one
technical
systems
crucially
people
understand
purpose
system
system
Sociotechnical
systems
defined
operational
processes
people
operators
inherent
parts
system
governed
organizational
policies
rules
affected
external
constraints
national
laws
regulatory
policies
example
book
created
sociotechnical
publishing
system
includes
various
processes
creation
editing
layout
etc
technical
systems
Microsoft
Word
Excel
Adobe
Illustrator
Indesign
etc
Systems
engineering
White
et
al
Stevens
et
al
Thayer
activity
designing
entire
systems
taking
account
characteristics
hardware
software
human
elements
systems
Systems
engineering
includes
everything
procuring
specifying
developing
deploying
operating
maintaining
technical
sociotechnical
systems
Systems
engineers
consider
capabilities
hardware
software
well
system
s
interactions
users
environment
think
system
s
services
constraints
system
built
operated
ways
system
used
chapter
focus
engineering
large
complex
software
intensive
systems
enterprise
systems
systems
used
support
goals
large
organization
Enterprise
systems
used
government
military
services
well
large
companies
public
bodies
@@@@@@@@@@
Chapter
Systems
engineering
Procurement
Development
Operation
Deployment
Equipment
software
updates
System
evolution
Conceptual
design
User
information
Outline
requirements
System
vision
features
Figure
Stages
systems
engineering
sociotechnical
systems
influenced
ways
organization
works
national
international
rules
regulations
made
number
separate
systems
distributed
systems
large
scale
databases
long
lifetime
critical
operation
enterprise
believe
important
software
engineers
know
systems
engineering
active
participants
systems
engineering
processes
two
reasons
Software
now
dominant
element
enterprise
systems
many
senior
decision
makers
organizations
limited
understanding
software
Software
engineers
play
active
part
high
level
systems
decision
making
system
software
dependable
developed
time
budget
software
engineer
helps
broader
awareness
software
interacts
hardware
software
systems
human
social
organizational
factors
affect
ways
software
used
knowledge
helps
understand
limits
software
design
better
software
systems
four
overlapping
stages
Figure
lifetime
large
complex
systems
Conceptual
design
initial
systems
engineering
activity
develops
concept
type
system
required
sets
nontechnical
language
purpose
system
needed
high
level
features
users
expect
see
system
describe
broad
constraints
need
interoperability
systems
limit
freedom
systems
engineers
designing
developing
system
Procurement
acquisition
stage
conceptual
design
developed
information
available
make
decisions
contract
system
development
involve
making
decisions
distribution
@@@@@@@@@@
Chapter
Systems
engineering
functionality
across
hardware
software
operational
processes
make
decisions
hardware
software
acquired
suppliers
develop
system
terms
conditions
supply
contract
Development
stage
system
developed
development
processes
include
requirements
definition
system
design
hardware
software
engineering
system
integration
testing
Operational
processes
defined
training
courses
system
users
designed
Operation
stage
system
deployed
users
trained
system
brought
use
planned
operational
processes
usually
change
reflect
real
working
environment
system
used
time
system
evolves
new
requirements
identified
Eventually
system
declines
value
decommissioned
replaced
Figure
shows
interactions
stages
conceptual
design
activity
basis
system
procurement
development
used
provide
information
users
system
development
procurement
overlap
procurement
development
operation
needed
new
equipment
software
available
system
operational
requirements
changes
inevitable
implementing
changes
requires
development
perhaps
software
hardware
procurement
decisions
made
one
stages
profound
influence
stages
design
options
restricted
procurement
decisions
scope
system
hardware
software
Human
errors
made
specification
design
development
stages
mean
faults
introduced
system
decision
limit
testing
budget
reasons
mean
faults
discovered
system
put
use
operation
errors
configuring
system
deployment
lead
problems
using
system
decisions
made
original
procurement
forgotten
system
changes
proposed
lead
unforeseen
consequences
arising
implementation
changes
important
difference
systems
software
engineering
involvement
range
professionals
throughout
lifetime
system
include
engineers
involved
hardware
software
design
system
end
users
managers
concerned
organizational
issues
experts
system
s
application
domain
example
engineering
insulin
pump
system
introduced
Chapter
requires
experts
electronics
mechanical
engineering
software
medicine
large
systems
even
wider
range
expertise
required
Figure
illustrates
technical
disciplines
involved
procurement
development
new
system
air
traffic
management
Architects
civil
engineers
involved
new
air
traffic
management
systems
usually
installed
new
building
Electrical
mechanical
engineers
involved
specify
maintain
power
air
conditioning
Electronic
engineers
concerned
computers
radars
equipment
Ergonomists
@@@@@@@@@@
Chapter
Systems
engineering
Systems
engineering
Electrical
engineering
Ergonomics
Software
engineering
Civil
engineering
Architecture
User
interface
design
Electronic
engineering
Mechanical
engineering
Figure
Professional
disciplines
involved
ATC
systems
engineering
design
controller
workstations
software
engineers
user
interface
designers
responsible
software
system
involvement
range
professional
disciplines
essential
different
types
components
complex
systems
However
differences
misunderstandings
disciplines
lead
inappropriate
design
decisions
poor
decisions
delay
system
s
development
make
less
suitable
intended
purpose
three
reasons
misunderstandings
differences
engineers
different
backgrounds
different
professional
disciplines
often
use
words
words
mean
thing
Consequently
misunderstandings
common
discussions
engineers
different
backgrounds
discovered
resolved
system
development
lead
errors
delivered
systems
example
electronic
engineer
know
bit
C
programming
understand
method
Java
like
function
C
discipline
makes
assumptions
disciplines
cannot
assumptions
often
based
inadequate
understanding
possible
example
electronic
engineer
decide
signal
processing
computationally
intensive
task
done
software
simplify
hardware
design
However
mean
significantly
greater
software
effort
ensure
system
processor
cope
amount
computation
resolved
disciplines
try
protect
professional
boundaries
argue
certain
design
decisions
decisions
call
professional
expertise
Therefore
software
engineer
argue
software
based
door
locking
system
building
mechanical
key
based
system
reliable
experience
interdisciplinary
working
successful
enough
time
available
issues
discussed
resolved
requires
regular
face
face
discussions
flexible
approach
everyone
involved
systems
engineering
process
@@@@@@@@@@
Chapter
Systems
engineering
Sociotechnical
systems
term
system
universally
used
talk
computer
systems
operating
systems
payment
systems
education
system
system
government
obviously
quite
different
uses
word
system
share
essential
characteristic
somehow
system
simply
sum
parts
Abstract
systems
system
government
outside
scope
book
focus
systems
include
computers
software
specific
purpose
enable
communication
support
navigation
maintain
medical
records
useful
working
definition
types
system
follows
system
purposeful
collection
interrelated
components
different
kinds
work
together
deliver
set
services
system
owner
users
general
definition
cover
wide
range
systems
example
simple
system
laser
pointer
delivers
indication
service
include
hardware
components
tiny
control
program
read
memory
ROM
contrast
air
traffic
control
system
includes
thousands
hardware
software
components
well
human
users
make
decisions
based
information
computer
system
delivers
range
services
including
providing
information
pilots
maintaining
safe
separation
planes
utilizing
airspace
complex
systems
properties
behavior
system
components
inextricably
intermingled
successful
functioning
system
component
depends
functioning
components
Software
operate
processor
operational
processor
carry
computations
software
system
defining
computations
successfully
installed
Large
scale
systems
often
systems
systems
made
several
separate
systems
example
police
command
control
system
include
geographical
information
system
provide
details
location
incidents
geographical
information
system
used
systems
transport
logistics
emergency
command
control
Engineering
systems
systems
increasingly
important
topic
software
engineering
cover
Chapter
Large
scale
systems
exceptions
sociotechnical
systems
explained
Chapter
include
software
hardware
people
processes
organizational
policies
Sociotechnical
systems
enterprise
systems
intended
help
deliver
business
purpose
purpose
increase
sales
reduce
material
used
manufacturing
collect
taxes
maintain
safe
airspace
embedded
organizational
environment
procurement
development
use
systems
influenced
organization
s
policies
procedures
well
working
culture
users
system
people
influenced
way
organization
managed
interactions
people
inside
outside
organization
close
relationships
sociotechnical
systems
organizations
use
systems
means
often
difficult
establish
system
boundaries
@@@@@@@@@@
Sociotechnical
systems
Technical
system
Nationallaws
regulations
Organizational
strategiesandgoalsOrganizationalculture
Organizational
policiesandrulesOperational
processes
Figure
Layered
structure
sociotechnical
systems
different
people
organization
see
boundaries
system
different
ways
significant
establishing
scope
system
important
defining
system
requirements
Figure
illustrates
problem
diagram
shows
sociotechnical
system
set
layers
layer
contributes
way
functioning
system
core
software
intensive
technical
system
operational
processes
shaded
Figure
people
agree
parts
system
However
system
s
behavior
influenced
range
sociotechnical
factors
outside
core
system
boundary
simply
drawn
around
core
include
organizational
levels
broader
sociotechnical
considerations
considered
part
system
depends
organization
policies
rules
organizational
rules
policies
changed
people
argue
part
system
However
difficult
change
organizational
culture
even
challenging
change
strategy
goals
governments
change
laws
accommodate
system
Moreover
different
stakeholders
different
opinions
system
boundaries
drawn
no
simple
answers
questions
discussed
negotiated
system
design
process
Generally
large
sociotechnical
systems
used
organizations
designing
developing
sociotechnical
systems
need
understand
far
possible
organizational
environment
used
don
t
systems
meet
business
needs
Users
managers
reject
system
fail
use
full
potential
Figure
shows
key
elements
organization
affect
requirements
design
operation
sociotechnical
system
new
system
lead
changes
elements
Process
changes
new
system
mean
people
change
way
work
training
certainly
required
changes
significant
involve
people
losing
jobs
danger
users
resist
introduction
system
@@@@@@@@@@
Chapter
Systems
engineering
PoliciesProcessesJobsPoliticsSystems
Figure
Organizational
elements
Job
changes
New
systems
deskill
users
environment
cause
change
way
work
users
actively
resist
introduction
system
organization
Professional
staff
doctors
teachers
resist
system
designs
require
change
normal
way
working
people
involved
feel
professional
expertise
eroded
status
organization
reduced
system
Organizational
policies
proposed
system
completely
consistent
organizational
policies
e
g
privacy
require
system
changes
policy
changes
process
changes
bring
system
policies
line
Organizational
politics
system
change
political
power
structure
organization
example
organization
dependent
complex
system
control
access
system
great
deal
political
power
Alternatively
organization
reorganizes
different
structure
affect
requirements
use
system
Sociotechnical
systems
complex
systems
means
practically
impossible
complete
understanding
advance
behavior
complexity
leads
three
important
characteristics
sociotechnical
systems
emergent
properties
properties
system
whole
rather
associated
individual
parts
system
Emergent
properties
depend
system
components
relationships
relationships
come
existence
system
integrated
components
emergent
properties
evaluated
time
Security
dependability
examples
important
emergent
system
properties
nondeterministic
presented
specific
input
produce
output
system
s
behavior
depends
human
operators
people
react
way
Furthermore
use
system
create
new
relationships
system
components
change
emergent
behavior
system
s
success
criteria
subjective
rather
objective
extent
system
supports
organizational
objectives
depend
system
depends
stability
objectives
relationships
@@@@@@@@@@
Sociotechnical
systems
Property
Description
Reliability
System
reliability
depends
component
reliability
unexpected
interactions
cause
new
types
failure
therefore
affect
reliability
system
property
reflects
easy
fix
problem
system
discovered
depends
able
diagnose
problem
access
components
faulty
modify
replace
components
security
system
ability
resist
attack
complex
property
cannot
easily
measured
Attacks
devised
anticipated
system
designers
defeat
built
safeguards
property
reflects
easy
use
system
depends
technical
system
components
operators
operating
environment
Repairability
Security
Usability
Volume
volume
system
total
space
occupied
depends
component
assemblies
arranged
connected
Figure
Examples
emergent
properties
conflicts
organizational
objectives
people
organization
interpret
objectives
New
management
reinterpret
organizational
objectives
system
designed
support
successful
system
seen
no
longer
fit
intended
purpose
Sociotechnical
considerations
often
critical
determining
system
successfully
met
objectives
Unfortunately
taking
account
difficult
engineers
little
experience
social
cultural
studies
help
understand
effects
systems
organizations
various
sociotechnical
systems
methodologies
proposed
paper
sociotechnical
systems
design
discusses
advantages
disadvantages
sociotechnical
design
methodologies
Baxter
Sommerville
Emergent
properties
complex
relationships
components
system
mean
system
simply
sum
parts
properties
properties
system
whole
emergent
properties
Checkland
cannot
attributed
specific
part
system
Rather
emerge
system
components
integrated
emergent
properties
weight
derived
directly
subsystem
properties
often
however
emerge
combination
subsystem
properties
subsystem
relationships
system
property
cannot
calculated
directly
properties
individual
system
components
Examples
emergent
properties
shown
Figure
two
types
emergent
properties
Functional
emergent
properties
purpose
system
emerges
components
integrated
example
bicycle
functional
property
transportation
device
assembled
components
@@@@@@@@@@
Chapter
Systems
engineering
Non
functional
emergent
properties
relate
behavior
system
operational
environment
Reliability
performance
safety
security
examples
properties
system
characteristics
critical
computer
based
systems
failure
achieve
minimum
defined
level
properties
usually
makes
system
unusable
users
need
system
functions
system
acceptable
without
However
system
unreliable
slow
likely
rejected
users
Emergent
properties
reliability
depend
properties
individual
components
interactions
relationships
example
reliability
sociotechnical
system
influenced
three
things
Hardware
reliability
probability
hardware
components
failing
long
take
repair
failed
component
Software
reliability
likely
software
component
produce
incorrect
output
Software
failure
unlike
hardware
failure
software
wear
Failures
often
transient
system
carries
working
incorrect
result
produced
Operator
reliability
likely
operator
system
make
error
provide
incorrect
input
likely
software
fail
detect
error
propagate
mistake
Hardware
software
operator
reliability
independent
affect
unpredictable
ways
Figure
shows
failures
one
level
propagated
levels
system
Say
hardware
component
system
starts
go
wrong
Hardware
failure
sometimes
generate
spurious
signals
outside
range
inputs
expected
software
software
behave
unpredictably
produce
unexpected
outputs
confuse
consequently
cause
stress
system
operator
know
people
likely
make
mistakes
feel
stressed
hardware
failure
trigger
operator
errors
mistakes
turn
lead
unexpected
software
behavior
resulting
additional
demands
processor
overload
hardware
causing
failures
Thus
initial
relatively
minor
failure
rapidly
develop
serious
problem
lead
complete
shutdown
system
reliability
system
depends
context
system
used
However
system
s
environment
cannot
completely
specified
often
impossible
system
designers
limit
environment
operational
systems
different
systems
operating
environment
react
problems
unpredictable
ways
thus
affecting
reliability
systems
example
say
system
designed
operate
normal
room
temperature
allow
variations
exceptional
conditions
electronic
components
system
designed
operate
certain
range
temperatures
say
degrees
degrees
Celsius
Outside
temperature
range
components
@@@@@@@@@@
Sociotechnical
systems
HardwareSoftwareOperationInitialfailureFailurepropagationFailureconsequence
Figure
Failure
propagation
behave
unpredictable
way
Now
assume
system
installed
close
air
conditioner
air
conditioner
fails
vents
hot
gas
electronics
system
overheat
components
whole
system
fail
system
installed
elsewhere
environment
problem
occurred
air
conditioner
worked
properly
no
problems
However
physical
closeness
machines
unanticipated
relationship
existed
led
system
failure
Like
reliability
emergent
properties
performance
usability
hard
assess
measured
system
operational
Properties
safety
security
however
directly
measurable
simply
concerned
attributes
relate
behavior
system
unwanted
unacceptable
behavior
secure
system
one
allow
unauthorized
access
data
Unfortunately
clearly
impossible
predict
possible
modes
access
explicitly
forbid
Therefore
possible
assess
shall
properties
system
operational
know
system
insecure
someone
manages
penetrate
system
Non
determinism
deterministic
system
one
absolutely
predictable
ignore
issues
concurrency
software
systems
run
reliable
hardware
deterministic
presented
sequence
inputs
produce
sequence
outputs
course
no
thing
completely
reliable
hardware
hardware
usually
reliable
enough
think
hardware
systems
deterministic
People
hand
non
deterministic
presented
exactly
input
say
request
complete
task
responses
depend
emotional
physical
state
person
making
request
people
environment
whatever
Sometimes
happy
work
times
refuse
sometimes
perform
task
well
sometimes
badly
Sociotechnical
systems
nondeterministic
partly
include
people
partly
changes
hardware
software
data
systems
@@@@@@@@@@
Chapter
Systems
engineering
frequent
interactions
changes
complex
behavior
system
unpredictable
Users
know
changes
made
see
system
nondeterministic
example
say
system
presented
set
test
inputs
processes
inputs
results
recorded
later
time
test
inputs
processed
results
compared
previous
stored
results
Five
different
mean
five
failures
differences
simply
reasonable
variations
system
s
behavior
find
looking
results
depth
making
judgments
way
system
handled
input
Non
determinism
often
seen
bad
thing
felt
designers
try
avoid
nondeterministic
behavior
possible
fact
sociotechnical
systems
non
determinism
important
benefits
means
behavior
system
fixed
time
change
depending
system
s
environment
example
operators
observe
system
showing
signs
failure
Instead
using
system
normally
change
behavior
diagnose
recover
detected
problems
Success
criteria
Generally
complex
sociotechnical
systems
developed
tackle
wicked
problems
Rittel
Webber
wicked
problem
problem
complex
involves
many
related
entities
no
definitive
problem
specification
different
stakeholders
see
problem
different
ways
no
one
full
understanding
problem
whole
true
nature
problem
emerge
solution
developed
extreme
example
wicked
problem
emergency
planning
deal
aftermath
earthquake
No
one
accurately
predict
epicenter
earthquake
time
occur
effect
local
environment
impossible
specify
detail
deal
problem
System
designers
make
assumptions
understanding
required
emerges
earthquake
happened
makes
difficult
define
success
criteria
system
decide
new
system
contributes
business
goals
company
paid
system
judgment
success
usually
made
original
reasons
procuring
developing
system
Rather
based
system
effective
time
deployed
business
environment
change
quickly
business
goals
changed
significantly
development
system
situation
even
complex
multiple
conflicting
goals
interpreted
differently
different
stakeholders
instance
system
Mentcare
system
based
designed
support
two
separate
business
goals
improve
quality
care
sufferers
mental
illness
improve
cost
effectiveness
treatments
providing
managers
detailed
reports
care
provided
costs
care
@@@@@@@@@@
Conceptual
design
Unfortunately
proved
conflicting
goals
information
needed
satisfy
reporting
goal
meant
doctors
nurses
provide
additional
information
health
records
normally
maintained
reduced
quality
care
patients
meant
clinical
staff
less
time
talk
doctor
s
perspective
system
improvement
previous
manual
system
manager
s
perspective
Thus
success
criteria
established
early
stages
systems
engineering
process
regularly
reconsidered
system
development
use
cannot
evaluate
criteria
objectively
depend
system
s
effect
environment
users
system
apparently
meet
requirements
originally
specified
practically
useless
changes
environment
used
Conceptual
design
idea
system
suggested
conceptual
design
first
thing
systems
engineering
process
conceptual
design
phase
take
initial
idea
investigate
feasibility
develop
create
overall
vision
system
developed
describe
envisaged
system
nonexperts
system
users
senior
company
decision
makers
politicians
understand
proposing
obvious
overlap
conceptual
design
requirements
engineering
part
conceptual
design
process
imagine
proposed
system
used
involve
discussions
potential
users
stakeholders
focus
groups
observations
existing
systems
used
goal
activities
understand
users
work
important
practical
constraints
system
importance
establishing
vision
proposed
system
rarely
mentioned
software
design
requirements
literature
However
vision
part
systems
engineering
process
military
systems
many
years
Fairley
et
al
Fairley
Thayer
Bjorke
discuss
idea
concept
analysis
documentation
results
concept
analysis
Concept
Operations
ConOps
document
idea
developing
ConOps
document
now
widely
used
large
scale
systems
find
many
examples
ConOps
documents
web
Unfortunately
often
case
military
government
systems
good
ideas
mired
bureaucracy
inflexible
standards
exactly
happened
ConOps
ConOps
document
standard
proposed
IEEE
Mostashari
et
al
say
Mostashari
et
al
tends
lead
long
unreadable
documents
serve
intended
purpose
propose
agile
approach
development
ConOps
document
shorter
flexible
document
output
process
@@@@@@@@@@
Chapter
Systems
engineering
Concept
formulation
Problem
understanding
System
proposal
development
Feasibility
study
System
structure
development
System
vision
document
Figure
Conceptual
design
activities
don
t
like
term
Concept
Operations
partly
military
connotations
partly
think
conceptual
design
document
system
operation
present
system
engineer
s
understanding
system
developed
explanation
design
proposals
appropriate
sometimes
initial
organization
system
Fairley
says
organized
tell
story
written
people
without
technical
background
understand
proposals
made
Figure
shows
activities
part
conceptual
design
process
Conceptual
design
team
process
involves
people
different
backgrounds
part
conceptual
design
team
digital
learning
environment
introduced
Chapter
digital
learning
environment
design
team
included
teachers
education
researchers
software
engineers
system
administrators
system
managers
Concept
formulation
first
stage
process
try
refine
initial
statement
needs
work
type
system
best
meet
needs
system
stakeholders
Initially
tasked
proposing
intranet
information
sharing
across
schools
easier
use
current
system
However
discussions
teachers
discovered
really
required
existing
system
awkward
use
people
found
workarounds
really
required
flexible
digital
learning
environment
adapted
adding
subject
age
specific
tools
content
freely
available
Internet
discovered
concept
formulation
activity
overlapped
activity
problem
understanding
understand
problem
need
discuss
users
stakeholders
work
need
find
important
barriers
stop
want
ideas
changes
required
need
open
minded
problem
prepared
change
ideas
reality
match
initial
vision
@@@@@@@@@@
Conceptual
design
system
proposal
development
stage
conceptual
design
team
set
ideas
alternative
systems
basis
feasibility
study
decide
ideas
worth
development
feasibility
study
look
comparable
systems
developed
elsewhere
technological
issues
e
g
use
mobile
devices
affect
use
system
need
assess
system
implemented
using
current
hardware
software
technologies
found
additional
useful
activity
develop
outline
structure
architecture
system
activity
helpful
making
feasibility
assessment
providing
basis
detailed
requirements
engineering
architectural
design
Furthermore
majority
systems
now
assembled
existing
systems
components
initial
architecture
means
key
parts
system
identified
procured
separately
approach
often
better
procuring
system
monolithic
unit
single
supplier
digital
learning
environment
decided
layered
service
architecture
shown
Figure
components
system
considered
replaceable
services
way
users
replace
standard
service
preferred
alternative
adapt
system
ages
interests
students
learning
system
activities
generate
information
used
develop
system
vision
document
critical
document
senior
decision
makers
use
decide
development
system
go
ahead
used
develop
documents
risk
analysis
budget
estimate
important
inputs
decision
making
process
Managers
use
system
vision
document
understand
system
procurement
team
uses
define
tender
document
requirements
engineers
use
basis
refining
system
requirements
different
people
need
different
levels
detail
suggest
document
structured
two
parts
short
summary
senior
decision
makers
presents
key
points
problem
proposed
system
written
readers
immediately
see
system
used
benefits
provide
number
appendices
develop
ideas
detail
used
system
procurement
requirements
engineering
activities
challenging
write
summary
system
vision
inasmuch
readers
busy
people
unlikely
technical
background
found
using
user
stories
effective
providing
tangible
vision
system
use
nontechnical
people
relate
Stories
short
personalized
feasible
description
use
system
shown
Figure
another
example
user
story
system
Chapter
Figure
@@@@@@@@@@
Chapter
Systems
engineering
Digital
art
Jill
S
pupil
secondary
school
Dundee
smartphone
family
shared
Samsung
tablet
Dell
laptop
computer
school
Jill
signs
school
computer
presented
personalized
Glow
environment
includes
range
services
chosen
teachers
chosen
Glow
app
library
working
Celtic
art
project
uses
Google
research
range
art
sites
sketches
designs
paper
uses
camera
phone
photograph
done
uploads
using
school
wifi
personal
Glow
space
homework
complete
design
write
short
commentary
ideas
home
uses
family
tablet
sign
Glow
uses
artwork
app
process
photograph
extend
work
add
color
finishes
part
work
complete
moves
home
laptop
type
commentary
uploads
finished
work
Glow
sends
message
art
teacher
available
review
teacher
looks
project
free
period
Jill
s
next
art
class
using
school
tablet
class
discusses
work
Jill
discussion
teacher
Jill
decide
work
shared
publish
school
web
pages
show
examples
students
work
addition
work
included
Jill
s
e
portfolio
record
schoolwork
age
Figure
user
story
used
system
vision
document
User
stories
effective
already
noted
readers
relate
addition
show
capabilities
proposed
system
easily
accessible
way
course
part
system
vision
summary
include
high
level
description
basic
assumptions
made
ways
system
deliver
value
organization
System
procurement
System
procurement
system
acquisition
process
outcome
decision
buy
one
systems
system
suppliers
stage
decisions
made
scope
system
purchased
system
budgets
timescales
high
level
system
requirements
Using
information
decisions
made
procure
system
type
system
required
supplier
suppliers
system
drivers
decisions
replacement
organizational
systems
organization
mixture
systems
cannot
work
together
expensive
maintain
procuring
replacement
system
additional
capabilities
lead
significant
business
benefits
need
comply
external
regulations
Increasingly
businesses
regulated
demonstrate
compliance
externally
defined
regulations
e
g
Sarbanes
Oxley
accounting
regulations
United
States
Compliance
require
replacement
noncompliant
systems
provision
new
systems
specifically
monitor
compliance
@@@@@@@@@@
System
procurement
External
competition
business
needs
compete
effectively
maintain
competitive
position
managers
decide
buy
new
systems
improve
business
efficiency
effectiveness
military
systems
need
improve
capability
face
new
threats
important
reason
procuring
new
systems
Business
reorganization
Businesses
organizations
frequently
restructure
intention
improving
efficiency
customer
service
Reorganizations
lead
changes
business
processes
require
new
systems
support
Available
budget
budget
available
obvious
factor
determining
scope
new
systems
procured
addition
new
government
systems
often
procured
reflect
political
changes
political
policies
example
politicians
decide
buy
new
surveillance
systems
claim
counter
terrorism
Buying
systems
shows
voters
taking
action
Large
complex
systems
usually
engineered
using
mixture
off
shelf
specially
built
components
often
integrated
existing
legacy
systems
organizational
databases
legacy
systems
off
shelf
systems
used
new
custom
software
needed
integrate
components
new
software
manages
component
interfaces
components
inter
operate
need
develop
glueware
one
reason
savings
using
off
shelf
components
sometimes
great
anticipated
Three
types
systems
system
components
procured
Off
shelf
applications
used
without
change
need
minimal
configuration
use
Configurable
application
ERP
systems
modified
adapted
use
modifying
code
using
inbuilt
configuration
features
process
definitions
rules
Custom
systems
specially
designed
implemented
use
components
tends
follow
different
procurement
process
Figure
illustrates
main
features
procurement
process
types
system
Key
issues
affect
procurement
processes
Organizations
often
approved
recommended
set
application
software
checked
department
usually
possible
buy
acquire
open
source
software
set
directly
without
need
detailed
justification
example
iLearn
system
recommended
Wordpress
made
available
student
staff
blogs
microphones
needed
off
shelf
hardware
bought
no
detailed
requirements
users
adapt
features
chosen
application
Off
shelf
components
usually
match
requirements
exactly
unless
requirements
written
components
mind
Therefore
choosing
@@@@@@@@@@
Chapter
Systems
engineering
Off
shelf
systems
Assess
approved
applications
Select
system
required
Place
order
system
Conceptual
design
Configurable
systems
Conceptual
design
Conceptual
design
Market
survey
Choose
system
shortlist
Refine
requirements
Choose
system
supplier
Negotiate
contract
Modify
requirements
Define
requirements
Issue
request
tender
Custom
systems
Choose
system
supplier
Negotiate
contract
Modify
requirements
Figure
System
system
means
find
closest
match
system
require
procurement
processes
ments
facilities
offered
off
shelf
systems
ERP
large
scale
application
systems
usually
fall
category
modify
requirements
fit
system
assumptions
knock
effects
subsystems
usually
extensive
configuration
process
tailor
adapt
application
ERP
system
buyer
s
working
environment
system
built
specially
specification
requirements
part
contract
system
acquired
therefore
legal
well
technical
document
requirements
document
critical
procurement
processes
type
usually
take
considerable
amount
time
public
sector
systems
particular
detailed
rules
regulations
affect
procurement
systems
example
European
Union
public
sector
systems
certain
price
open
tender
supplier
Europe
requires
detailed
tender
documents
drawn
tender
advertised
across
Europe
fixed
period
time
rule
slow
procurement
process
tends
inhibit
agile
development
forces
system
buyer
develop
requirements
companies
enough
information
bid
system
contract
application
systems
require
change
custom
systems
usually
contract
negotiation
period
customer
supplier
negotiate
terms
conditions
development
system
system
@@@@@@@@@@
System
procurement
selected
negotiate
supplier
costs
license
conditions
possible
changes
system
contractual
issues
custom
systems
negotiations
likely
involve
payment
schedules
reporting
acceptance
criteria
requirements
change
requests
costs
system
changes
process
requirements
changes
agreed
reduce
overall
costs
avoid
development
problems
Complex
sociotechnical
systems
rarely
developed
house
buyer
system
Rather
external
systems
companies
invited
bid
systems
engineering
contract
customer
s
business
systems
engineering
employees
skills
needed
develop
systems
complex
hardware
software
systems
necessary
use
group
suppliers
different
type
expertise
large
systems
air
traffic
management
system
group
suppliers
form
consortium
bid
contract
consortium
include
capabilities
required
type
system
ATC
system
include
computer
hardware
suppliers
software
companies
peripheral
suppliers
suppliers
specialist
equipment
radar
systems
Customers
usually
wish
negotiate
multiple
suppliers
contract
usually
awarded
principal
contractor
coordinates
project
principal
contractor
coordinates
development
different
subsystems
subcontractors
subcontractors
design
build
parts
system
specification
negotiated
principal
contractor
customer
completed
principal
contractor
integrates
components
delivers
customer
decisions
made
procurement
stage
systems
engineering
process
critical
later
stages
process
Poor
procurement
decisions
often
lead
problems
late
delivery
system
development
systems
unsuited
operational
environment
wrong
system
wrong
supplier
chosen
technical
processes
system
software
engineering
complex
example
studied
system
failure
decision
made
choose
ERP
system
standardize
operations
across
organization
operations
diverse
turned
good
reasons
Standardization
practically
impossible
ERP
system
adapted
cope
diversity
ultimately
abandoned
incurring
costs
around
million
decisions
choices
made
system
procurement
profound
effect
security
dependability
system
example
decision
made
procure
off
shelf
system
organization
accept
no
influence
security
dependability
requirements
system
System
security
depends
decisions
made
system
vendors
addition
off
shelf
systems
known
security
weaknesses
require
complex
configuration
Configuration
errors
entry
points
system
properly
secured
significant
source
security
problems
hand
decision
procure
custom
system
means
lot
effort
devoted
understanding
defining
security
dependability
requirements
company
limited
experience
area
quite
difficult
thing
@@@@@@@@@@
Chapter
Systems
engineering
required
level
dependability
well
acceptable
system
performance
achieved
development
time
extended
budget
increased
Many
bad
procurement
decisions
stem
political
rather
technical
causes
Senior
management
wish
control
demand
single
system
used
across
organization
Suppliers
chosen
longstanding
relationship
company
rather
offer
best
technology
Managers
wish
maintain
compatibility
existing
systems
feel
threatened
new
technologies
discuss
Chapter
people
understand
required
system
often
responsible
procurement
decisions
Engineering
issues
necessarily
play
major
part
decision
making
process
System
development
System
development
complex
process
elements
part
system
developed
purchased
integrated
create
final
system
system
requirements
bridge
conceptual
design
development
processes
conceptual
design
business
high
level
functional
non
functional
system
requirements
defined
think
start
development
overlapping
processes
shown
Figure
contracts
system
elements
agreed
detailed
requirements
engineering
takes
place
Figure
model
systems
development
process
Systems
engineering
processes
usually
follow
waterfall
process
model
similar
one
discussed
Chapter
waterfall
model
inappropriate
types
software
development
higher
level
systems
engineering
processes
plan
driven
processes
still
follow
model
Plan
driven
processes
used
systems
engineering
different
elements
system
independently
developed
different
contractors
working
concurrently
separate
subsystems
Therefore
interfaces
elements
designed
development
begins
systems
include
hardware
equipment
changes
development
expensive
sometimes
practically
impossible
essential
therefore
system
requirements
fully
understood
hardware
development
building
work
begins
One
confusing
aspects
systems
engineering
companies
use
different
terminology
stage
process
Sometimes
requirements
engineering
part
development
process
sometimes
separate
activity
However
conceptual
design
seven
fundamental
development
activities
Requirements
engineering
process
refining
analyzing
documenting
high
level
business
requirements
identified
conceptual
design
covered
important
requirements
engineering
activities
Chapter
Architectural
design
overlaps
significantly
requirements
engineering
process
process
involves
establishing
overall
architecture
system
@@@@@@@@@@
System
development
Subsystem
engineering
Architectural
design
Requirements
engineering
System
deployment
System
testing
System
integration
Requirements
partitioning
Figure
systems
development
process
identifying
different
system
components
understanding
relationships
Requirements
partitioning
concerned
deciding
subsystems
identified
system
architecture
responsible
implementing
system
requirements
Requirements
allocated
hardware
software
operational
processes
prioritized
implementation
Ideally
allocate
requirements
individual
subsystems
implementation
critical
requirement
need
subsystem
collaboration
However
possible
stage
decide
operational
processes
used
requirements
implementation
Subsystem
engineering
involves
developing
software
components
system
configuring
off
shelf
hardware
software
designing
necessary
special
purpose
hardware
defining
operational
processes
system
re
designing
essential
business
processes
System
integration
process
putting
together
system
elements
create
new
system
emergent
system
properties
apparent
System
testing
extended
activity
whole
system
tested
problems
exposed
subsystem
engineering
system
integration
phases
reentered
repair
problems
tune
performance
system
implement
new
requirements
System
testing
involve
testing
system
developer
acceptance
user
testing
organization
procured
system
System
deployment
process
making
system
available
users
transferring
data
existing
systems
establishing
communications
systems
environment
process
culminates
go
live
users
start
use
system
support
work
overall
process
plan
driven
processes
requirements
development
system
design
inextricably
linked
requirements
high
level
@@@@@@@@@@
Chapter
Systems
engineering
System
requirements
design
documentation
Review
assessment
Architectural
designStartRequirements
elicitation
analysis
Domain
problem
understanding
Requirements
partitioning
Figure
Requirements
design
spiral
design
developed
concurrently
Constraints
posed
existing
systems
limit
design
choices
choices
specified
requirements
initial
design
structure
organize
requirements
engineering
process
design
process
continues
discover
problems
existing
requirements
new
requirements
emerge
Consequently
think
linked
processes
spiral
shown
Figure
spiral
reflects
reality
requirements
affect
design
decisions
vice
versa
makes
sense
interleave
processes
Starting
center
round
spiral
add
detail
requirements
design
subsystems
identified
architecture
decisions
made
responsibilities
subsystems
providing
system
requirements
rounds
spiral
focus
requirements
others
design
Sometimes
new
knowledge
collected
requirements
design
process
means
problem
statement
changed
systems
many
possible
designs
meet
requirements
cover
range
solutions
combine
hardware
software
human
operations
solution
choose
development
appropriate
technical
solution
meets
requirements
However
wider
organizational
political
considerations
influence
choice
solution
example
government
client
prefer
use
national
rather
foreign
suppliers
system
even
national
products
technically
inferior
influences
usually
take
effect
review
assessment
phase
spiral
model
designs
requirements
accepted
rejected
process
ends
review
decides
requirements
high
level
design
sufficiently
detailed
subsystems
specified
designed
@@@@@@@@@@
System
development
Subsystem
engineering
involves
designing
building
system
s
hardware
software
components
types
systems
spacecraft
hardware
software
components
designed
built
development
process
However
systems
components
bought
rather
developed
usually
much
cheaper
buy
existing
products
develop
special
purpose
components
However
buy
large
off
shelf
systems
ERP
systems
significant
cost
configuring
systems
use
operational
environment
Subsystems
usually
developed
parallel
problems
cut
across
subsystem
boundaries
encountered
system
modification
request
made
systems
involve
extensive
hardware
engineering
making
modifications
manufacturing
started
usually
expensive
Often
workarounds
compensate
problem
found
workarounds
usually
involve
software
changes
implement
new
requirements
systems
integration
take
independently
developed
subsystems
put
together
make
complete
system
integration
achieved
using
big
bang
approach
subsystems
integrated
time
However
technical
managerial
reasons
incremental
integration
process
subsystems
integrated
one
time
best
approach
usually
impossible
schedule
development
subsystems
finished
time
Incremental
integration
reduces
cost
error
location
many
subsystems
simultaneously
integrated
error
arises
testing
subsystems
single
subsystem
integrated
already
working
system
errors
occur
probably
newly
integrated
subsystem
interactions
existing
subsystems
new
subsystem
increasing
number
systems
built
integrating
off
shelf
hardware
software
application
systems
distinction
implementation
integration
becoming
blurred
cases
no
need
develop
new
hardware
software
Essentially
systems
integration
implementation
phase
system
integration
process
system
tested
testing
focus
testing
interfaces
components
behavior
system
whole
Inevitably
testing
reveals
problems
individual
subsystems
repaired
Testing
takes
long
time
common
problem
system
development
testing
team
run
budget
time
problem
lead
delivery
error
prone
systems
need
repaired
deployed
Subsystem
faults
consequence
invalid
assumptions
subsystems
often
exposed
system
integration
lead
disputes
contractors
responsible
implementing
different
subsystems
problems
discovered
subsystem
interaction
contractors
argue
subsystem
faulty
Negotiations
solve
problems
take
weeks
months
final
stage
system
development
process
system
delivery
deployment
software
installed
hardware
readied
operation
@@@@@@@@@@
Chapter
Systems
engineering
involve
system
configuration
reflect
local
environment
used
transfer
data
existing
systems
preparation
user
documentation
training
stage
reconfigure
systems
environment
ensure
new
system
interoperates
system
deployment
straightforward
principle
often
difficult
anticipated
user
environment
different
anticipated
system
developers
Adapting
system
make
work
unexpected
environment
difficult
existing
system
data
require
extensive
clean
parts
involve
effort
expected
interfaces
systems
properly
documented
find
planned
operational
processes
changed
compatible
operational
processes
systems
User
training
often
difficult
arrange
consequence
initially
least
users
unable
access
capabilities
system
System
deployment
therefore
take
much
longer
cost
much
anticipated
System
operation
evolution
Operational
processes
processes
involved
using
system
intended
designers
example
operators
air
traffic
control
system
follow
specific
processes
aircraft
enter
leave
airspace
change
height
speed
emergency
occurs
new
systems
operational
processes
defined
documented
system
development
process
Operators
trained
work
processes
adapted
make
effective
use
new
system
Undetected
problems
arise
stage
system
specification
contain
errors
omissions
system
perform
specification
functions
meet
real
operational
needs
Consequently
operators
use
system
designers
intended
designers
operational
processes
based
process
designs
extensive
user
studies
period
domestication
Stewart
Williams
users
adapt
new
system
work
practical
processes
use
user
interface
design
important
studies
shown
given
time
users
adapt
complex
interfaces
experienced
prefer
ways
using
system
quickly
rather
easily
means
designing
systems
simply
cater
inexperienced
users
design
user
interface
adaptable
experienced
users
people
think
system
operators
source
problems
system
move
toward
automated
systems
operator
involvement
minimized
opinion
two
problems
approach
likely
increase
technical
complexity
system
designed
cope
anticipated
failure
modes
increases
costs
@@@@@@@@@@
System
operation
evolution
time
required
build
system
Provision
made
bring
people
deal
unanticipated
failures
People
adaptable
cope
problems
unexpected
situations
Thus
anticipate
everything
possibly
go
wrong
specifying
designing
system
People
unique
capability
able
respond
effectively
unexpected
even
never
direct
experience
unexpected
events
system
states
Therefore
things
go
wrong
system
operators
often
recover
situation
finding
workarounds
using
system
nonstandard
ways
Operators
use
local
knowledge
adapt
improve
processes
Normally
actual
operational
processes
different
anticipated
system
designers
Consequently
design
operational
processes
flexible
adaptable
operational
processes
constraining
require
operations
done
particular
order
system
software
rely
specific
process
followed
Operators
usually
improve
process
know
work
real
situation
problem
emerge
system
goes
operation
operation
new
system
alongside
existing
systems
physical
problems
incompatibility
difficult
transfer
data
one
system
another
subtle
problems
arise
different
systems
different
user
interfaces
Introducing
new
system
increase
operator
error
rate
operators
use
user
interface
commands
wrong
system
System
evolution
Large
complex
systems
usually
long
lifetime
Complex
hardware
software
systems
remain
use
years
even
though
original
hardware
software
technologies
used
obsolete
several
reasons
longevity
shown
Figure
lifetime
large
complex
systems
change
evolve
correct
errors
original
system
requirements
implement
new
requirements
emerged
system
s
computers
likely
replaced
new
faster
machines
organization
uses
system
reorganize
use
system
different
way
external
environment
system
change
forcing
changes
system
evolution
process
runs
alongside
normal
system
operational
processes
System
evolution
involves
reentering
development
process
make
changes
extensions
system
s
hardware
software
operational
processes
System
evolution
like
software
evolution
discussed
Chapter
inherently
costly
several
reasons
Proposed
changes
analyzed
carefully
business
technical
perspective
Changes
contribute
goals
system
simply
technically
motivated
@@@@@@@@@@
Chapter
Systems
engineering
Factor
Rationale
Investment
cost
costs
systems
engineering
project
tens
even
hundreds
millions
dollars
costs
justified
system
deliver
value
organization
many
years
Loss
expertise
businesses
change
restructure
focus
core
activities
often
lose
engineering
expertise
mean
lack
ability
specify
requirements
new
system
Replacement
cost
cost
replacing
large
system
high
Replacing
existing
system
justified
leads
significant
cost
savings
existing
system
Return
investment
fixed
budget
available
systems
engineering
spending
new
systems
area
business
lead
higher
return
investment
replacing
existing
system
Risks
change
Systems
inherent
part
business
operations
risks
replacing
existing
systems
new
systems
cannot
justified
danger
new
system
things
go
wrong
hardware
software
operational
processes
potential
costs
problems
business
high
cannot
take
risk
system
replacement
System
dependencies
Systems
interdependent
replacing
one
systems
lead
extensive
changes
systems
Figure
Factors
influence
system
lifetimes
subsystems
never
completely
independent
changes
one
subsystem
side
effects
adversely
affect
performance
behavior
subsystems
Consequent
changes
subsystems
therefore
needed
reasons
original
design
decisions
often
unrecorded
responsible
system
evolution
work
particular
design
decisions
made
systems
age
structure
becomes
corrupted
change
costs
making
changes
increases
Systems
use
many
years
often
reliant
obsolete
hardware
software
technology
legacy
systems
discussed
Chapter
sociotechnical
computer
based
systems
developed
using
technology
now
obsolete
However
don
t
include
legacy
hardware
software
rely
legacy
processes
procedures
old
ways
things
difficult
change
rely
legacy
software
Changes
one
part
system
inevitably
involve
changes
components
Changes
made
system
system
evolution
often
source
problems
vulnerabilities
people
implementing
changes
different
developed
system
unaware
design
decision
taken
dependability
security
reasons
Therefore
change
system
lose
safeguards
deliberately
implemented
system
built
Furthermore
testing
expensive
complete
retesting
impossible
every
system
change
Consequently
testing
discover
adverse
side
effects
changes
introduce
expose
faults
system
components
@@@@@@@@@@
Chapter
reading
Key
Points
Systems
engineering
concerned
aspects
specifying
buying
designing
testing
complex
sociotechnical
systems
Sociotechnical
systems
include
computer
hardware
software
people
situated
organization
designed
support
organizational
business
goals
objectives
emergent
properties
system
characteristics
system
whole
rather
component
parts
include
properties
performance
reliability
usability
safety
security
fundamental
systems
engineering
processes
conceptual
systems
design
system
procurement
system
development
system
operation
Conceptual
systems
design
key
activity
high
level
system
requirements
vision
operational
system
developed
System
procurement
covers
activities
involved
deciding
system
buy
supply
system
Different
procurement
processes
used
off
shelf
application
systems
configurable
COTS
systems
custom
systems
System
development
processes
include
requirements
specification
design
construction
integration
testing
system
put
use
operational
processes
system
inevitably
change
reflect
changes
business
requirements
system
s
environment
reading
Airport
Automated
Baggage
System
excellent
readable
case
study
go
wrong
systems
engineering
project
software
tends
get
blame
wider
systems
failures
ACM
Software
Engineering
Notes
March
http
doi
acm
org
Fundamentals
Systems
Engineering
introductory
chapter
NASA
s
systems
engineering
handbook
presents
overview
systems
engineering
process
space
systems
mostly
technical
systems
sociotechnical
issues
considered
Dependability
obviously
critically
important
NASA
Systems
Engineering
Handbook
NASA
SP
http
ntrs
nasa
gov
archive
nasa
casi
ntrs
nasa
gov
pdf
LSCITS
Socio
technical
Systems
Handbook
handbook
introduces
sociotechnical
systems
accessible
way
provides
access
detailed
papers
sociotechnical
topics
Various
authors
http
archive
cs
st
andrews
ac
uk
STSE
Handbook
Architecting
systems
Concepts
Principles
Practice
refreshingly
different
book
systems
engineering
hardware
focus
many
traditional
systems
engineering
books
@@@@@@@@@@
Chapter
Systems
engineering
author
experienced
systems
engineer
draws
examples
wide
range
systems
recognizes
importance
sociotechnical
well
technical
issues
H
Sillitto
College
Publications
WebSite
PowerPoint
slides
chapter
www
pearsonglobaleditions
com
Sommerville
Links
supporting
videos
http
software
engineering
book
com
videos
systems
engineering
exerCiSeS
Give
two
examples
government
functions
supported
complex
sociotechnical
systems
explain
foreseeable
future
functions
cannot
completely
automated
Explain
briefly
involvement
range
professional
disciplines
essential
systems
engineering
Complex
sociotechnical
systems
lead
three
important
characteristics
Explain
brief
wicked
problem
Explain
development
national
medical
records
system
considered
wicked
problem
multimedia
virtual
museum
system
offering
virtual
experiences
ancient
Greece
developed
consortium
European
museums
system
provide
users
facility
view
D
models
ancient
Greece
standard
web
browser
support
immersive
virtual
reality
experience
Develop
conceptual
design
system
highlighting
key
characteristics
essential
high
level
requirements
Explain
need
flexible
adapt
system
requirements
procuring
large
off
shelf
software
systems
ERP
systems
Search
web
discussions
failures
systems
explain
sociotechnical
perspective
failures
occurred
possible
starting
point
http
blog
cloudsolutions
com
blog
bid
Top
Six
ERP
Implementation
Failures
system
integration
particularly
critical
part
systems
development
process
Suggest
three
sociotechnical
issues
cause
difficulties
system
integration
process
system
evolution
inherently
costly
@@@@@@@@@@
Chapter
References
arguments
considering
system
engineering
profession
right
like
electrical
engineering
software
engineering
engineer
involved
development
financial
system
installation
discover
system
make
significant
number
people
redundant
people
environment
deny
access
essential
information
complete
system
installation
extent
systems
engineer
involved
situation
professional
responsibility
complete
installation
contracted
simply
abandon
work
procuring
organization
sorted
problem
reFerenCeS
Baxter
G
Sommerville
Socio
Technical
Systems
Design
Methods
Systems
Engineering
Interacting
Computers
doi
j
intcom
Checkland
P
Systems
Thinking
Systems
Practice
Chichester
UK
John
Wiley
Sons
Fairley
R
E
R
H
Thayer
P
Bjorke
Concept
Operations
Bridge
Operational
Requirements
Technical
Specifications
st
Int
Conf
Requirements
Engineering
Colorado
Springs
CO
doi
ICRE
IEEE
IEEE
Guide
Information
Technology
System
Definition
Concept
Operations
ConOps
Document
Electronics
Vol
doi
IEEESTD
http
ieeexplore
ieee
org
servlet
opac
punumber
Mostashari
S
McComb
D
M
Kennedy
R
Cloutier
P
Korfiatis
Developing
Stakeholder
Assisted
Agile
CONOPS
Development
Process
Systems
Engineering
doi
sys
Rittel
H
M
Webber
Dilemmas
General
Theory
Planning
Policy
Sciences
doi
BF
Stevens
R
P
Brook
K
Jackson
S
Arnold
Systems
Engineering
Coping
Complexity
London
Prentice
Hall
Stewart
J
R
Williams
Wrong
Trousers
Beyond
Design
Fallacy
Social
Learning
User
User
Involvement
Innovation
Processes
Strategies
Limitations
Socio
Technical
Perspective
edited
H
Rohrache
Berlin
Profil
Verlag
Thayer
R
H
Software
System
Engineering
Tutorial
IEEE
Computer
doi
MC
White
S
M
Alford
J
Holtzman
S
Kuehl
B
McCay
D
Oliver
D
Owens
C
Tully
Willey
Systems
Engineering
Computer
Based
Systems
IEEE
Computer
doi
ECBS
@@@@@@@@@@
Systems
systems
Objectives
objectives
chapter
introduce
idea
system
systems
discuss
challenges
building
complex
systems
software
systems
read
chapter
understand
meant
system
systems
differs
individual
system
understand
systems
systems
classification
differences
different
types
systems
systems
understand
conventional
methods
software
engineering
based
reductionism
inadequate
developing
systems
systems
introduced
systems
systems
engineering
process
architectural
patterns
systems
systems
Contents
System
complexity
Systems
systems
classification
Reductionism
complex
systems
Systems
systems
engineering
Systems
systems
architecture
@@@@@@@@@@
Chapter
Systems
systems
need
software
engineering
create
large
complex
software
systems
discipline
emerged
s
first
attempts
build
large
software
systems
mostly
went
wrong
Creating
software
much
expensive
expected
took
longer
planned
software
often
unreliable
address
problems
developed
range
software
engineering
techniques
technologies
remarkably
successful
now
build
systems
much
larger
complex
much
reliable
effective
software
systems
s
However
solved
problems
large
system
engineering
Software
project
failures
still
common
example
serious
problems
delays
implementation
government
health
care
systems
United
States
UK
root
cause
problems
s
trying
build
systems
larger
complex
attempting
build
mega
systems
using
methods
technology
never
designed
purpose
discuss
later
chapter
believe
current
software
engineering
technology
cannot
scale
cope
complexity
inherent
many
systems
now
proposed
increase
size
software
systems
since
introduction
software
engineering
remarkable
Today
s
large
systems
hundred
even
thousand
times
larger
large
systems
s
Northrop
colleagues
Northrop
et
al
suggested
shortly
see
development
systems
billion
lines
code
years
prediction
suspect
systems
already
use
course
start
nothing
write
billion
lines
code
discussed
Chapter
real
success
story
software
engineering
software
reuse
developed
ways
reusing
software
across
applications
systems
large
scale
development
possible
large
scale
systems
now
future
built
integrating
existing
systems
different
providers
create
systems
systems
SoS
mean
talk
system
systems
Hitchens
says
Hitchins
general
systems
perspective
no
difference
system
system
systems
emergent
properties
composed
subsystems
However
software
engineering
perspective
think
useful
distinction
terms
distinction
sociotechnical
rather
technical
system
systems
system
contains
two
independently
managed
elements
means
no
single
manager
parts
system
systems
different
parts
system
subject
different
management
control
policies
rules
shall
see
distributed
management
control
profound
effect
overall
complexity
system
definition
systems
systems
says
nothing
size
systems
systems
relatively
small
system
includes
services
different
providers
@@@@@@@@@@
system
systems
problems
SoS
engineering
apply
small
systems
real
challenges
emerge
constituent
systems
large
scale
systems
Much
work
area
systems
systems
come
defense
community
capability
software
systems
increased
late
th
century
possible
coordinate
control
previously
independent
military
systems
naval
ground
based
air
ship
defense
systems
system
include
tens
hundreds
separate
elements
software
systems
keeping
track
elements
providing
controllers
information
allows
deployed
effectively
type
system
systems
outside
scope
software
engineering
book
Instead
focus
systems
systems
system
elements
software
systems
rather
hardware
aircraft
military
vehicles
radars
Systems
software
systems
created
integrating
separate
software
systems
time
writing
software
SoS
include
relatively
small
number
separate
systems
constituent
system
usually
complex
system
right
However
predicted
next
years
size
software
SoS
likely
grow
significantly
systems
integrated
make
use
capabilities
offer
Examples
systems
systems
software
systems
cloud
management
system
handles
local
private
cloud
management
management
servers
public
clouds
Amazon
Microsoft
online
banking
system
handles
loan
requests
connects
credit
reference
system
provided
credit
reference
agencies
check
credit
applicants
emergency
information
system
integrates
information
police
ambulance
fire
coast
guard
services
assets
available
deal
civil
emergencies
flooding
large
scale
accidents
digital
learning
environment
iLearn
introduced
Chapter
system
provides
range
learning
support
integrating
separate
software
systems
Microsoft
Office
virtual
learning
environments
Moodle
simulation
modeling
tools
content
newspaper
archives
Maier
Maier
identified
five
essential
characteristics
systems
systems
Operational
independence
elements
Parts
system
simply
components
operate
useful
systems
right
systems
SoS
evolve
independently
Managerial
independence
elements
Parts
system
owned
managed
different
organizations
different
parts
larger
organization
Therefore
different
rules
policies
apply
management
evolution
@@@@@@@@@@
Chapter
Systems
systems
systems
suggested
key
factor
distinguishes
system
systems
system
Evolutionary
development
SoS
developed
single
project
evolve
time
constituent
systems
Emergence
SoS
emergent
characteristics
apparent
SoS
created
course
discussed
Chapter
emergence
characteristic
systems
particularly
important
SoS
Geographical
distribution
elements
elements
SoS
often
geographically
distributed
across
different
organizations
important
technically
means
externally
managed
network
integral
part
SoS
important
managerially
increases
difficulties
communication
involved
making
system
management
decisions
adds
difficulties
maintaining
system
security
like
add
two
characteristics
Maier
s
list
particularly
relevant
systems
software
systems
Data
intensive
software
SoS
typically
relies
manages
large
volume
data
terms
size
tens
even
hundreds
times
larger
code
constituent
systems
Heterogeneity
different
systems
software
SoS
unlikely
developed
using
programming
languages
design
methods
consequence
rapid
pace
evolution
software
technologies
Companies
frequently
update
development
methods
tools
new
improved
versions
available
year
lifetime
large
SoS
technologies
change
four
five
times
discuss
Section
characteristics
mean
SoS
much
complex
systems
single
owner
manager
believe
current
software
engineering
methods
techniques
cannot
scale
cope
complexity
Consequently
problems
large
complex
systems
now
developing
inevitable
need
completely
new
set
abstractions
methods
technologies
software
systems
systems
engineering
need
recognized
independently
number
different
authorities
UK
report
published
Royal
Academy
Engineering
led
establishment
national
research
training
initiative
large
scale
complex
systems
Sommerville
et
al
United
States
Software
Engineering
Institute
reported
Ultra
Large
Scale
Systems
Northrop
et
al
systems
engineering
community
Stevens
Stevens
discusses
problems
constructing
mega
systems
transport
health
care
defense
Maier
M
W
Architecting
Principles
Systems
Systems
Systems
Engineering
doi
SICI
AID
SYS
CO
D
@@@@@@@@@@
Figure
Simple
complex
systems
System
System
b
System
complexity
suggested
introduction
engineering
problems
arise
constructing
systems
software
systems
due
inherent
complexity
systems
section
explain
basis
system
complexity
discuss
different
types
complexity
arise
software
SoS
systems
composed
parts
elements
relationships
elements
system
example
parts
program
objects
parts
object
constants
variables
methods
Examples
relationships
include
calls
method
calls
method
B
inherits
object
X
inherits
methods
attributes
object
Y
part
method
part
object
X
complexity
system
depends
number
types
relationships
system
elements
Figure
shows
examples
two
systems
System
relatively
simple
system
small
number
relationships
elements
contrast
System
b
number
elements
complex
system
many
element
element
relationships
type
relationship
influences
overall
complexity
system
Static
relationships
relationships
planned
analyzable
static
depictions
system
Therefore
uses
relationship
software
system
static
relationship
software
source
code
UML
model
system
work
one
software
component
uses
components
Dynamic
relationships
relationships
exist
executing
system
calls
relationship
dynamic
relationship
system
statements
cannot
tell
one
method
call
another
method
depends
runtime
inputs
system
Dynamic
relationships
complex
analyze
need
know
system
inputs
data
used
well
source
code
system
well
system
complexity
consider
complexity
processes
used
develop
maintain
system
gone
use
Figure
illustrates
processes
relationship
developed
system
@@@@@@@@@@
System
complexity
Production
process
Management
process
Complex
system
Produces
Manages
Figure
Production
management
processes
systems
grow
size
need
complex
production
management
processes
Complex
processes
complex
systems
difficult
understand
undesirable
emergent
properties
time
consuming
simpler
processes
require
documentation
coordination
people
organizations
involved
system
development
complexity
production
process
one
main
reasons
projects
go
wrong
software
delivered
late
overbudget
Therefore
large
systems
risk
cost
time
overruns
Complexity
important
software
engineering
main
influence
understandability
changeability
system
complex
system
difficult
understand
analyze
Given
complexity
function
number
relationships
elements
system
inevitable
large
systems
complex
small
systems
complexity
increases
relationships
elements
system
increased
likelihood
changing
one
part
system
undesirable
effects
elsewhere
Several
different
types
complexity
relevant
sociotechnical
systems
technical
complexity
system
derived
relationships
different
components
system
managerial
complexity
system
derived
complexity
relationships
system
managers
e
managers
change
system
relationships
managers
different
parts
system
@@@@@@@@@@
governance
complexity
system
depends
relationships
laws
regulations
policies
affect
system
relationships
decision
making
processes
organizations
responsible
system
different
parts
system
different
organizations
different
countries
different
laws
rules
policies
apply
system
SoS
Governance
managerial
complexity
related
thing
Managerial
complexity
operational
issue
t
done
system
Governance
complexity
associated
higher
level
decision
making
processes
organizations
affect
system
decision
making
processes
constrained
national
international
laws
regulations
example
say
company
decides
allow
staff
access
systems
using
mobile
devices
rather
company
issued
laptops
decision
allow
governance
decision
changes
policy
company
result
decision
management
system
becomes
complex
managers
ensure
mobile
devices
configured
properly
company
data
secure
technical
complexity
system
increases
no
longer
single
implementation
platform
Software
modified
work
laptops
tablets
phones
well
technical
complexity
characteristics
systems
systems
lead
significantly
increased
managerial
governance
complexity
Figure
summarizes
different
SoS
characteristics
primarily
contribute
different
types
complexity
Operational
independence
constituent
systems
SoS
subject
different
policies
rules
governance
complexity
ways
managing
system
managerial
complexity
Managerial
independence
constituent
systems
SoS
managed
different
people
different
ways
coordinate
ensure
management
changes
consistent
managerial
complexity
Special
software
needed
support
consistent
management
evolution
technical
complexity
Evolutionary
development
contributes
technical
complexity
SoS
different
parts
system
likely
built
using
different
technologies
Emergence
consequence
complexity
complex
system
likely
undesirable
emergent
properties
properties
increase
technical
complexity
system
software
developed
changed
compensate
Geographical
distribution
increases
technical
managerial
governance
complexity
SoS
Technical
complexity
increased
software
required
coordinate
synchronize
remote
systems
managerial
complexity
increased
difficult
managers
different
countries
coordinate
actions
governance
complexity
increased
different
@@@@@@@@@@
Systems
systems
classification
Figure
SoS
characteristics
system
complexity
SoS
characteristic
Technical
complexity
Managerial
complexity
Governance
complexity
Operational
independence
X
X
Managerial
independence
X
X
Evolutionary
development
X
Emergence
X
Geographical
distribution
X
X
X
Data
intensive
X
X
Heterogeneity
X
parts
systems
located
different
jurisdictions
subject
different
laws
regulations
Data
intensive
systems
technically
complex
relationships
data
items
technical
complexity
likely
increased
cope
data
errors
incompleteness
Governance
complexity
increased
different
laws
governing
use
data
heterogeneity
system
contributes
technical
complexity
difficulties
ensuring
different
technologies
used
different
parts
system
compatible
Large
scale
systems
systems
now
unimaginably
complex
entities
cannot
understood
analyzed
whole
discuss
Section
large
number
interactions
parts
dynamic
nature
interactions
means
conventional
engineering
approaches
work
well
complex
systems
complexity
root
cause
problems
projects
develop
large
software
intensive
systems
poor
management
technical
failings
Systems
systems
classification
Earlier
suggested
distinguishing
feature
system
systems
two
elements
independently
managed
Different
people
different
priorities
authority
take
day
day
operational
decisions
changes
system
work
necessarily
aligned
conflicts
arise
require
significant
amount
time
effort
resolve
Systems
systems
therefore
degree
managerial
complexity
However
broad
definition
SoS
covers
wide
range
system
types
includes
systems
owned
single
organization
managed
different
@@@@@@@@@@
parts
organization
includes
systems
constituent
systems
owned
managed
different
organizations
times
compete
Maier
Maier
devised
classification
scheme
SoS
based
governance
management
complexity
Directed
systems
Directed
SoS
owned
single
organization
developed
integrating
systems
owned
organization
system
elements
independently
managed
parts
organization
However
ultimate
governing
body
organization
set
priorities
system
management
resolve
disputes
managers
different
elements
system
Directed
systems
therefore
managerial
complexity
no
governance
complexity
military
commandand
control
system
integrates
information
airborne
ground
based
systems
example
directed
SoS
Collaborative
systems
Collaborative
SoS
systems
no
central
authority
set
management
priorities
resolve
disputes
Typically
elements
system
owned
governed
different
organizations
However
organizations
involved
recognize
mutual
benefits
joint
governance
system
therefore
usually
set
voluntary
governance
body
makes
decisions
system
Collaborative
systems
managerial
complexity
limited
degree
governance
complexity
integrated
public
transport
information
system
example
collaborative
system
systems
Bus
rail
air
transport
providers
agree
link
systems
provide
passengers
date
information
Virtual
systems
Virtual
systems
no
central
governance
participants
agree
overall
purpose
system
Participant
systems
enter
leave
SoS
Interoperability
guaranteed
depends
published
interfaces
change
systems
high
degree
managerial
governance
complexity
example
virtual
SoS
automated
high
speed
algorithmic
trading
system
systems
different
companies
automatically
buy
sell
stock
trades
taking
place
fractions
second
Unfortunately
think
names
Maier
used
really
reflect
distinctions
different
types
systems
Maier
says
collaboration
management
system
elements
collaborative
systems
really
good
name
term
directed
systems
implies
top
authority
However
even
single
organization
need
maintain
good
working
relationships
people
involved
means
governance
agreed
rather
imposed
virtual
SoS
no
formal
mechanisms
collaboration
system
mutual
benefit
participants
Therefore
likely
collaborate
informally
ensure
system
continue
operate
Furthermore
Maier
s
use
term
virtual
confusing
virtual
now
come
mean
implemented
software
virtual
machines
virtual
reality
@@@@@@@@@@
Systems
systems
classification
GovernanceManagementTechnicalOrganizationalFederatedCoalition
Figure
SoS
collaboration
Figure
illustrates
collaboration
different
types
system
Rather
use
Maier
s
names
used
hope
descriptive
terms
Organizational
systems
systems
SoS
governance
management
system
lies
organization
company
correspond
Maier
s
directed
SoS
Collaboration
system
owners
managed
organization
SoS
geographically
distributed
different
parts
system
subject
different
national
laws
regulations
Figure
Systems
independently
managed
governance
systems
centralized
Federated
systems
SoS
governance
SoS
depends
voluntary
participative
body
system
owners
represented
Figure
shown
owners
Systems
participating
single
governance
body
system
owners
agree
collaborate
believe
decisions
made
governance
body
binding
implement
decisions
individual
management
policies
implementations
differ
national
laws
regulations
culture
System
system
coalitions
SoS
no
formal
governance
mechanisms
organizations
involved
informally
collaborate
manage
systems
maintain
system
whole
example
one
system
provides
data
feed
others
managers
system
change
format
data
without
notice
Figure
shows
no
governance
organizational
level
informal
collaboration
exists
management
level
governance
based
classification
scheme
provides
means
identifying
governance
requirements
SoS
classifying
system
according
model
check
appropriate
governance
structures
exist
ones
really
need
Setting
structures
across
organizations
political
process
inevitably
takes
long
time
therefore
helpful
understand
governance
@@@@@@@@@@
problem
early
process
take
actions
ensure
appropriate
governance
place
case
need
adopt
governance
model
moves
system
one
class
another
Moving
governance
model
left
Figure
usually
reduces
complexity
suggested
school
digital
learning
environment
iLearn
system
systems
well
digital
learning
system
connected
school
administration
systems
network
management
systems
network
management
systems
used
Internet
filtering
stops
students
accessing
undesirable
material
Internet
iLearn
relatively
simple
technical
system
high
level
governance
complexity
complexity
arises
way
education
funded
managed
many
countries
pre
university
education
funded
organized
local
level
rather
national
level
States
cities
counties
responsible
schools
area
autonomy
deciding
school
funding
policies
local
authority
maintains
school
administration
system
network
management
system
Scotland
local
authorities
responsibility
education
area
School
administration
outsourced
one
three
providers
iLearn
connect
systems
However
local
authority
network
management
policies
separate
network
management
systems
involved
development
digital
learning
system
national
initiative
create
digital
learning
environment
integrated
network
management
school
administration
systems
therefore
system
systems
administration
network
management
systems
well
systems
iLearn
Office
Wordpress
no
common
governance
process
across
authorities
according
classification
scheme
coalition
systems
practice
means
cannot
guaranteed
students
different
places
access
tools
content
different
Internet
filtering
policies
produced
conceptual
model
system
made
strong
recommendation
common
policies
established
across
local
authorities
administrative
information
provision
Internet
filtering
essence
suggested
system
federated
system
rather
coalition
systems
suggestion
requires
new
governance
body
established
agree
common
policies
standards
system
Reductionism
complex
systems
already
suggested
current
software
engineering
methods
technologies
cannot
cope
complexity
inherent
modern
systems
systems
course
idea
new
Progress
engineering
disciplines
driven
challenging
difficult
problems
New
methods
tools
developed
response
failures
difficulties
existing
approaches
@@@@@@@@@@
Reductionism
complex
systems
software
engineering
seen
incredibly
rapid
development
discipline
help
manage
increasing
size
complexity
software
systems
effort
successful
indeed
now
build
systems
orders
magnitude
larger
complex
s
s
engineering
disciplines
approach
basis
complexity
management
software
engineering
called
reductionism
Reductionism
philosophical
position
based
assumptions
system
made
parts
subsystems
assumes
behavior
properties
system
whole
understood
predicted
understanding
individual
parts
relationships
parts
Therefore
design
system
parts
making
system
identified
constructed
separately
assembled
complete
system
Systems
thought
hierarchies
important
relationships
parent
child
nodes
hierarchy
Reductionism
continues
fundamental
underpinning
approach
kinds
engineering
identify
common
abstractions
across
types
system
design
build
separately
integrated
create
required
system
example
abstractions
automobile
body
shell
drive
train
engine
fuel
system
relatively
small
number
relationships
abstractions
possible
specify
interfaces
design
build
part
system
separately
reductionist
approach
basis
software
engineering
years
Top
design
start
high
level
model
system
break
components
reductionist
approach
basis
software
design
methods
object
oriented
design
Programming
languages
include
abstractions
procedures
objects
directly
reflect
reductionist
system
decomposition
Agile
methods
appear
quite
different
top
systems
design
reductionist
rely
able
decompose
system
parts
implement
parts
separately
integrate
create
system
real
difference
agile
methods
top
design
system
decomposed
components
incrementally
rather
Reductionist
methods
successful
relatively
relationships
interactions
parts
system
possible
model
relationships
scientific
way
generally
true
mechanical
electrical
systems
physical
linkages
system
components
less
true
electronic
systems
certainly
case
software
systems
many
static
dynamic
relationships
system
components
distinctions
software
hardware
components
recognized
s
Design
methods
emphasized
importance
limiting
controlling
relationships
parts
system
methods
suggested
components
tightly
integrated
loose
coupling
components
Tight
integration
meant
relationships
internal
component
loose
coupling
meant
relatively
component
component
@@@@@@@@@@
Control
Decision
making
Problem
definition
Owners
system
control
development
Decisions
made
rationally
driven
technical
criteria
definable
problem
clear
system
boundaries
Reductionist
assumptions
Figure
Reductionist
assumptions
complex
no
single
system
owner
controller
Decision
making
Wicked
problem
driven
political
constantly
renegotiated
motives
system
boundaries
Systems
systems
reality
system
reality
relationships
need
tight
integration
data
operations
loose
coupling
driver
development
object
oriented
software
engineering
Unfortunately
controlling
number
types
relationship
practically
impossible
large
systems
especially
systems
systems
Reductionism
work
well
many
relationships
system
relationships
difficult
understand
analyze
Therefore
type
large
system
development
likely
run
difficulties
reasons
potential
difficulties
fundamental
assumptions
inherent
reductionism
inapplicable
large
complex
systems
Sommerville
et
al
assumptions
shown
Figure
apply
three
areas
System
ownership
control
Reductionism
assumes
controlling
authority
system
resolve
disputes
make
high
level
technical
decisions
apply
across
system
seen
multiple
bodies
involved
governance
simply
true
systems
systems
Rational
decision
making
Reductionism
assumes
interactions
components
objectively
assessed
example
mathematical
modeling
assessments
driver
system
decision
making
Therefore
one
particular
design
vehicle
say
offers
best
fuel
economy
without
reduction
power
reductionist
approach
assumes
design
chosen
Defined
system
boundaries
Reductionism
assumes
boundaries
system
agreed
defined
often
straightforward
physical
shell
defining
system
car
bridge
cross
given
stretch
water
Complex
systems
often
developed
address
wicked
problems
Rittel
Webber
problems
deciding
part
system
outside
usually
subjective
judgment
frequent
disagreements
stakeholders
involved
@@@@@@@@@@
Systems
systems
engineering
reductionist
assumptions
break
complex
systems
systems
software
intensive
difficulties
compounded
Relationships
software
systems
governed
physical
laws
cannot
produce
mathematical
models
software
systems
predict
behavior
attributes
therefore
no
scientific
basis
decision
making
Political
factors
usually
driver
decision
making
large
complex
software
systems
Software
no
physical
limitations
no
limits
boundaries
system
drawn
Different
stakeholders
argue
boundaries
placed
way
best
Furthermore
much
easier
change
software
requirements
hardware
requirements
boundaries
scope
system
likely
change
development
Linking
software
systems
different
owners
relatively
easy
likely
try
create
SoS
no
single
governing
body
management
evolution
different
systems
involved
cannot
completely
controlled
reasons
believe
problems
difficulties
commonplace
large
software
systems
engineering
inevitable
Failures
large
government
projects
health
automation
projects
UK
United
States
consequence
complexity
rather
technical
project
management
failures
Reductionist
approaches
object
oriented
development
successful
improving
ability
engineer
many
types
software
system
continue
useful
effective
developing
small
medium
sized
systems
complexity
controlled
parts
software
SoS
However
fundamental
assumptions
underlying
reductionism
improving
methods
lead
improvement
ability
engineer
complex
systems
systems
Rather
need
new
abstractions
methods
tools
recognize
technical
human
social
political
complexities
SoS
engineering
believe
new
methods
probabilistic
statistical
tools
rely
system
simulation
support
decision
making
Developing
new
approaches
major
challenge
software
systems
engineering
st
century
Systems
systems
engineering
Systems
systems
engineering
process
integrating
existing
systems
create
new
functionality
capabilities
Systems
systems
designed
top
way
Rather
created
organization
recognizes
add
value
existing
systems
integrating
SoS
example
city
government
wish
reduce
air
pollution
particular
hot
spots
city
integrate
traffic
management
system
national
real
time
pollution
monitoring
systems
allows
traffic
management
system
alter
strategy
reduce
pollution
changing
traffic
light
sequences
speed
limits
@@@@@@@@@@
Systems
Conceptual
design
System
selection
Architectural
design
Interface
development
Integration
deployment
knowledge
Governance
management
policy
settingFigure
SoS
engineering
process
problems
software
SoS
engineering
much
common
problems
integrating
large
scale
application
systems
discussed
Chapter
Boehm
Abts
recap
Lack
control
system
functionality
performance
Differing
incompatible
assumptions
made
developers
different
systems
Different
evolution
strategies
timetables
different
systems
Lack
support
system
owners
problems
arise
Much
effort
building
systems
software
systems
comes
addressing
problems
involves
deciding
system
architecture
developing
software
interfaces
reconcile
differences
participating
systems
making
system
resilient
unforeseen
changes
occur
Software
systems
systems
large
complex
entities
processes
used
development
vary
widely
depending
type
systems
involved
application
domain
needs
organizations
involved
developing
SoS
However
shown
Figure
five
general
activities
involved
SoS
development
processes
Conceptual
design
introduced
idea
conceptual
design
Chapter
covers
systems
engineering
Conceptual
design
activity
creating
high
level
vision
system
defining
essential
requirements
identifying
constraints
overall
system
SoS
engineering
important
input
conceptual
design
process
knowledge
existing
systems
participate
SoS
System
selection
activity
set
systems
inclusion
SoS
chosen
process
comparable
process
choosing
application
@@@@@@@@@@
Systems
systems
engineering
systems
reuse
covered
Chapter
need
assess
evaluate
existing
systems
choose
capabilities
need
selecting
application
systems
selection
criteria
largely
commercial
systems
offer
suitable
functionality
price
prepared
pay
However
political
imperatives
issues
system
governance
management
often
key
factors
influence
systems
included
SoS
example
systems
excluded
consideration
organization
wish
collaborate
competitor
cases
organizations
contributing
federation
systems
systems
place
insist
used
even
though
necessarily
best
systems
Architectural
design
parallel
system
selection
overall
architecture
SoS
developed
Architectural
design
major
topic
right
cover
Section
Interface
development
different
systems
involved
SoS
usually
incompatible
interfaces
Therefore
major
part
software
engineering
effort
developing
SoS
develop
interfaces
constituent
systems
interoperate
involve
development
unified
user
interface
SoS
operators
deal
multiple
user
interfaces
use
different
systems
SoS
Integration
deployment
stage
involves
making
different
systems
involved
SoS
work
together
interoperate
developed
interfaces
System
deployment
means
putting
system
place
organizations
concerned
making
operational
parallel
technical
activities
needs
high
level
activity
concerned
establishing
policies
governance
system
systems
defining
management
guidelines
implement
policies
several
organizations
involved
process
prolonged
difficult
involve
organizations
changing
policies
processes
therefore
important
start
governance
discussions
early
stage
SoS
development
process
Interface
development
constituent
systems
SoS
usually
developed
independently
specific
purpose
user
interface
tailored
original
purpose
systems
application
programming
interfaces
APIs
allow
systems
interface
directly
Therefore
systems
integrated
SoS
software
interfaces
developed
allows
constituent
systems
SoS
interoperate
general
aim
SoS
development
systems
able
communicate
directly
without
user
intervention
systems
already
offer
service
based
interface
discussed
Chapter
communication
implemented
using
approach
Interface
development
involves
describing
@@@@@@@@@@
Service
interfaces
System
System
System
Principal
system
Unified
service
interface
Figure
Systems
service
interfaces
use
interfaces
access
functionality
system
systems
involved
communicate
directly
System
coalitions
systems
involved
peers
likely
use
type
direct
interaction
require
prearranged
agreements
system
communication
protocols
commonly
however
constituent
systems
SoS
specialized
API
allow
functionality
accessed
user
interfaces
therefore
develop
software
reconciles
differences
interfaces
best
implement
interfaces
service
based
interfaces
shown
Figure
Sillitto
develop
service
based
interfaces
examine
functionality
existing
systems
define
set
services
reflect
functionality
interface
provides
services
services
implemented
calls
underlying
system
API
mimicking
user
interaction
system
One
systems
SoS
usually
principal
coordinating
system
manages
interactions
constituent
systems
principal
system
acts
service
broker
directing
service
calls
different
systems
SoS
system
therefore
need
know
system
providing
called
service
User
interfaces
system
SoS
likely
different
principal
system
overall
user
interfaces
handle
user
authentication
provide
access
features
underlying
system
However
usually
expensive
time
consuming
implement
unified
user
interface
replace
individual
interfaces
underlying
systems
unified
user
interface
UI
makes
easier
new
users
learn
use
SoS
reduces
likelihood
user
error
However
unified
UI
development
cost
effective
depends
number
factors
interaction
assumptions
systems
SoS
systems
process
driven
model
interaction
system
controls
interface
prompts
user
inputs
Others
give
control
user
user
chooses
sequence
interactions
system
practically
impossible
unify
different
interaction
models
@@@@@@@@@@
Systems
systems
engineering
mode
use
SoS
many
cases
SoS
used
way
interactions
users
site
one
constituent
systems
use
systems
additional
information
required
example
air
traffic
controllers
normally
use
radar
system
flight
information
access
flight
plan
database
additional
information
required
unified
interface
bad
idea
situations
slow
interaction
commonly
used
system
However
operators
interact
constituent
systems
unified
UI
best
way
forward
openness
SoS
SoS
open
new
systems
added
use
unified
UI
development
impractical
impossible
anticipate
UI
new
systems
Openness
applies
organizations
using
SoS
new
organizations
involved
existing
equipment
preferences
user
interaction
therefore
prefer
unified
UI
practice
limiting
factor
UI
unification
likely
budget
time
available
UI
development
UI
development
one
expensive
systems
engineering
activities
many
cases
simply
enough
project
budget
available
pay
creation
unified
SoS
user
interface
Integration
deployment
System
integration
deployment
usually
separate
activities
system
integrated
components
integration
testing
team
validated
released
deployment
components
managed
changes
controlled
integration
team
confident
required
version
included
system
However
SoS
approach
possible
component
systems
already
deployed
use
integration
team
cannot
control
changes
systems
SoS
therefore
makes
sense
consider
integration
deployment
part
process
approach
reflects
one
design
guidelines
discuss
following
section
incomplete
system
systems
usable
provide
useful
functionality
integration
process
begin
systems
already
deployed
new
systems
added
SoS
provide
coherent
additions
functionality
overall
system
often
makes
sense
plan
deployment
SoS
reflect
SoS
deployment
takes
place
number
stages
example
Figure
illustrates
three
stage
deployment
process
iLearn
digital
learning
environment
initial
deployment
provides
authentication
basic
learning
functionality
integration
school
administration
systems
Stage
deployment
adds
integrated
storage
system
set
specialized
tools
support
subject
specific
learning
tools
include
@@@@@@@@@@
Release
timeline
Office
School
admin
systems
Learning
portfolio
system
Wordpress
Conferencing
system
Moodle
VLE
Authentication
system
Authentication
system
Programming
environments
Drawing
photo
tools
Science
simulation
systems
Storage
system
Content
systems
history
languages
etc
iLearn
V
tools
Data
analysis
tools
ibook
tools
Google
Apps
Age
specific
tools
iLearn
V
tools
Configuration
system
Storage
system
Authentication
system
iLearn
V
iLearn
V
iLearn
V
Figure
Release
sequence
iLearn
SoS
archives
history
simulation
systems
science
programming
environments
computing
Stage
adds
features
user
configuration
ability
users
add
new
systems
iLearn
environment
stage
allows
different
versions
system
created
different
age
groups
specialized
tools
alternatives
standard
tools
included
large
systems
engineering
project
time
consuming
expensive
part
system
integration
system
testing
Testing
systems
systems
difficult
expensive
three
reasons
detailed
requirements
specification
used
basis
system
testing
cost
effective
develop
SoS
requirements
document
details
system
functionality
defined
systems
included
constituent
systems
change
course
testing
process
tests
repeatable
problems
discovered
possible
fix
problems
requiring
one
constituent
systems
changed
Rather
intermediate
software
introduced
solve
problem
help
address
problems
believe
SoS
testing
take
board
testing
techniques
developed
agile
methods
Agile
methods
rely
complete
system
specification
system
acceptance
testing
Rather
stakeholders
closely
engaged
testing
process
@@@@@@@@@@
Systems
systems
architecture
authority
decide
overall
system
acceptable
SoS
range
stakeholders
involved
testing
process
possible
comment
system
ready
deployment
Agile
methods
make
extensive
use
automated
testing
makes
much
easier
rerun
tests
discover
unexpected
system
changes
caused
problems
SoS
whole
Depending
type
system
plan
installation
equipment
user
training
part
deployment
process
system
installed
new
environment
equipment
installation
straightforward
However
intended
replace
existing
system
problems
installing
new
equipment
compatible
equipment
use
physical
space
new
equipment
installed
alongside
working
system
insufficient
electrical
power
users
time
involved
busy
using
current
system
nontechnical
issues
delay
deployment
process
slow
adoption
use
SoS
Systems
systems
architecture
Perhaps
crucial
activity
systems
systems
engineering
process
architectural
design
Architectural
design
involves
selecting
systems
included
SoS
assessing
systems
interoperate
designing
mechanisms
facilitate
interaction
Key
decisions
data
management
redundancy
communications
made
essence
SoS
architect
responsible
realizing
vision
set
conceptual
design
system
organizational
federated
systems
particular
decisions
made
stage
crucial
performance
resilience
maintainability
system
systems
Maier
Maier
discusses
four
general
principles
architecting
complex
systems
systems
Design
systems
deliver
value
incomplete
system
composed
several
systems
useful
components
working
properly
Rather
several
stable
intermediate
forms
partial
system
works
useful
things
realistic
controlled
best
performance
SoS
achieved
individual
group
exerts
control
overall
system
constituents
no
control
delivering
value
SoS
difficult
However
attempts
overcontrol
SoS
likely
lead
resistance
individual
system
owners
consequent
delays
system
deployment
evolution
Focus
system
interfaces
build
successful
system
systems
design
interfaces
system
elements
interoperate
@@@@@@@@@@
important
interfaces
restrictive
system
elements
evolve
continue
useful
participants
SoS
Provide
collaboration
incentives
system
elements
independently
owned
managed
important
system
owner
incentives
continue
participate
system
financial
incentives
pay
per
use
reduced
operational
costs
access
incentives
share
data
ll
share
community
incentives
participate
SoS
get
say
community
Sillitto
Sillitto
added
principles
suggests
additional
important
design
guidelines
include
following
Design
SoS
node
web
architecture
Nodes
sociotechnical
systems
include
data
software
hardware
infrastructure
technical
components
organizational
policies
people
processes
training
sociotechnical
web
communications
infrastructure
nodes
provides
mechanism
informal
formal
social
communications
people
managing
running
systems
node
Specify
behavior
services
exchanged
nodes
development
service
oriented
architectures
now
provides
standard
mechanism
system
operability
system
already
provide
service
interface
interface
implemented
part
SoS
development
process
Understand
manage
system
vulnerabilities
SoS
unexpected
failures
undesirable
behavior
critically
important
try
understand
vulnerabilities
design
system
resilient
failures
key
message
emerges
Maier
s
Sillitto
s
work
SoS
architects
take
broad
perspective
need
look
system
whole
taking
account
technical
sociotechnical
considerations
Sometimes
best
solution
problem
software
changes
rules
policies
govern
operation
system
Architectural
frameworks
MODAF
MOD
TOGAF
TOGAF
registered
trademark
Open
Group
suggested
means
supporting
architectural
design
systems
systems
Architectural
frameworks
originally
developed
support
enterprise
systems
architectures
portfolios
separate
systems
Enterprise
systems
organizational
systems
systems
simpler
management
structure
system
portfolio
managed
whole
Architectural
frameworks
intended
development
organizational
systems
systems
single
governance
authority
entire
SoS
architectural
framework
recognizes
single
model
architecture
present
information
needed
architectural
business
analysis
Rather
frameworks
propose
number
architectural
views
created
maintained
describe
document
enterprise
systems
Frameworks
much
common
tend
reflect
language
history
organizations
@@@@@@@@@@
Systems
systems
architecture
Preliminary
Figure
TOGAF
architecture
development
method
TOGAF
Version
Open
Group
Architecture
vision
B
Business
architecture
C
Information
systems
G
architectures
D
Technology
architecture
E
Opportunities
solutions
F
Migration
planning
Implementation
governance
H
Architecture
change
management
Requirements
management
involved
example
MODAF
DODAF
comparable
frameworks
UK
Ministry
Defence
MOD
U
S
Department
Defense
DOD
TOGAF
framework
developed
Open
Group
open
standard
intended
support
design
business
architecture
data
architecture
application
architecture
technology
architecture
enterprise
heart
Architecture
Development
Method
ADM
consists
number
discrete
phases
shown
Figure
taken
TOGAF
reference
documentation
Open
Group
architectural
frameworks
involve
production
management
large
set
architectural
models
activities
shown
Figure
leads
production
system
models
However
problematic
two
reasons
Initial
model
development
takes
long
time
involves
extensive
negotiations
system
stakeholders
slows
development
overall
system
time
consuming
expensive
maintain
model
consistency
changes
made
organization
constituent
systems
SoS
Architecture
frameworks
fundamentally
reductionist
largely
ignore
sociotechnical
political
issues
recognize
problems
diffi
cult
define
open
ended
assume
degree
control
governance
@@@@@@@@@@
Data
feed
Data
feed
Data
feed
Data
feed
Principal
system
Data
feed
Data
feed
Data
feed
Data
feed
Principal
system
Figure
Systems
data
feeds
impossible
achieve
many
systems
systems
useful
checklist
remind
architects
things
think
architectural
design
process
However
think
overhead
involved
model
management
reductionist
approach
taken
frameworks
limits
usefulness
SoS
architectural
design
Architectural
patterns
systems
systems
described
architectural
patterns
different
types
system
Chapters
short
architectural
pattern
stylized
architecture
recognized
across
range
different
systems
Architectural
patterns
useful
way
stimulating
discussions
appropriate
architecture
system
documenting
explaining
architectures
used
section
covers
number
typical
patterns
systems
software
systems
architectural
patterns
real
systems
usually
based
one
patterns
notion
architectural
patterns
systems
systems
still
early
stage
development
Kawalsky
Kawalsky
et
al
discusses
value
architectural
patterns
understanding
supporting
SoS
design
focus
patterns
command
control
systems
find
patterns
effective
illustrating
SoS
organization
without
need
detailed
domain
knowledge
Systems
data
feeds
architectural
pattern
Figure
principal
system
requires
data
different
types
data
available
systems
principal
system
queries
systems
get
data
required
Generally
systems
provide
data
interact
pattern
often
observed
organizational
federated
systems
governance
mechanisms
place
example
license
vehicle
UK
need
valid
insurance
roadworthiness
certificate
interact
vehicle
licensing
system
interacts
two
systems
check
documents
valid
systems
insured
vehicles
system
federated
system
run
car
insurance
companies
maintains
information
current
car
insurance
policies
@@@@@@@@@@
Systems
systems
architecture
Data
feed
Data
feed
Data
feed
Principal
system
Data
feed
Data
feed
b
Data
feed
c
Figure
Systems
data
feeds
unifying
interface
MOT
certificate
system
used
record
roadworthiness
certificates
issued
testing
agencies
licensed
government
systems
data
feeds
architecture
appropriate
architecture
use
possible
identify
entities
unique
way
create
relatively
simple
queries
entities
licensing
system
vehicles
uniquely
identified
registration
number
systems
possible
identify
entities
pollution
monitors
GPS
coordinates
variant
systems
data
feeds
architecture
arises
number
systems
provide
data
similar
identical
Therefore
architecture
include
intermediate
layer
shown
Figure
role
intermediate
layer
translate
general
query
principal
system
specific
query
required
individual
information
system
example
iLearn
environment
interacts
school
administration
systems
three
different
providers
systems
provide
information
students
names
personal
information
etc
different
interfaces
databases
different
organizations
format
data
returned
differs
one
system
another
unifying
interface
detects
user
system
based
using
regional
information
knows
administrative
system
accessed
converts
standard
query
appropriate
query
system
Problems
arise
systems
use
pattern
primarily
interface
problems
data
feeds
unavailable
slow
respond
important
ensure
timeouts
included
system
failure
data
feed
compromise
response
time
system
whole
Governance
mechanisms
place
ensure
format
provided
data
changed
without
agreement
system
owners
Systems
container
Systems
container
systems
systems
one
systems
acts
virtual
container
provides
set
common
services
authentication
storage
service
Conceptually
systems
placed
container
@@@@@@@@@@
Included
systems
s
s
s
s
s
s
Common
service
Common
service
Common
service
Figure
Systems
container
Container
system
make
functionality
accessible
system
users
Figure
illustrates
container
system
three
common
services
six
included
systems
systems
included
selected
approved
list
systems
need
aware
included
container
pattern
SoS
often
observed
federated
systems
system
coalitions
iLearn
environment
system
container
common
services
support
authentication
storage
user
data
system
configuration
functionality
comes
choosing
existing
systems
newspaper
archive
virtual
learning
environment
integrating
container
course
don
t
place
systems
real
container
implement
systems
systems
Rather
approved
system
separate
interface
allows
integrated
common
services
interface
manages
translation
common
services
provided
container
requirements
integrated
system
possible
include
systems
approved
However
access
common
services
provided
container
Figure
illustrates
integration
graphic
simplified
version
iLearn
provides
three
common
services
authentication
service
provides
single
sign
approved
systems
Users
maintain
separate
credentials
systems
storage
service
user
data
service
seamlessly
transferred
approved
systems
configuration
service
used
include
remove
systems
container
example
shows
version
iLearn
Physics
well
office
productivity
system
Office
VLE
Moodle
system
includes
simulation
data
analysis
systems
systems
YouTube
science
encyclopedia
part
system
However
approved
no
container
interface
available
Users
log
systems
separately
organize
data
transfers
@@@@@@@@@@
Systems
systems
architecture
Digital
Learning
Environment
MS
Office
Moodle
Lab
data
analyzer
External
interaction
Configuration
Storage
Authentication
YouTube
Science
encyclopedia
Physics
simulator
Interfaces
Figure
DLE
container
system
two
problems
type
SoS
architecture
separate
interface
developed
approved
system
common
services
used
systems
means
relatively
small
number
approved
systems
supported
owners
container
system
no
influence
functionality
behavior
included
systems
Systems
stop
working
withdrawn
time
However
main
benefit
architecture
allows
incremental
development
early
version
container
system
based
unapproved
systems
Interfaces
developed
later
versions
closely
integrated
container
services
Trading
systems
Trading
systems
systems
systems
no
single
principal
system
processing
take
place
constituent
systems
systems
involved
trade
information
among
one
one
one
many
interactions
systems
system
publishes
interface
interface
standards
followed
systems
system
shown
Figure
Trading
systems
federated
systems
system
coalitions
example
trading
SoS
system
systems
algorithmic
trading
stocks
shares
Brokers
separate
systems
automatically
buy
sell
stock
systems
set
prices
negotiate
individually
systems
Another
example
trading
system
travel
aggregator
shows
price
comparisons
allows
travel
booked
directly
user
@@@@@@@@@@
Figure
trading
system
systems
Trading
system
Trading
system
Trading
system
Trading
system
Trading
systems
developed
type
marketplace
information
exchanged
information
goods
traded
prices
trading
systems
systems
right
conceivably
used
individual
trading
useful
automated
trading
context
systems
negotiate
directly
major
problem
type
system
no
governance
mechanism
systems
involved
change
time
changes
contradict
assumptions
made
systems
trading
cannot
continue
Sometimes
owners
systems
coalition
wish
able
continue
trading
systems
make
informal
arrangements
ensure
changes
one
system
make
trading
impossible
cases
travel
aggregator
airline
deliberately
change
system
unavailable
force
bookings
made
directly
Key
Points
Systems
systems
systems
two
constituent
systems
independently
managed
governed
Three
types
complexity
important
systems
systems
technical
complexity
managerial
complexity
governance
complexity
System
governance
used
basis
classification
scheme
SoS
leads
three
classes
SoS
namely
organizational
systems
federated
systems
system
coalitions
Reductionism
engineering
method
breaks
inherent
complexity
systems
systems
Reductionism
assumes
clear
system
boundaries
rational
decision
making
well
defined
problems
None
true
systems
systems
key
stages
SoS
development
process
conceptual
design
system
selection
architectural
design
interface
development
integration
deployment
Governance
management
policies
designed
parallel
activities
@@@@@@@@@@
Chapter
Exercises
Architectural
patterns
systems
systems
means
describing
discussing
typical
architectures
SoS
Important
patterns
systems
data
feeds
systems
container
trading
systems
Reading
Architecting
Principles
Systems
Systems
now
classic
paper
systems
systems
introduces
classification
scheme
SoS
discusses
value
proposes
number
architectural
principles
SoS
design
M
Maier
Systems
Engineering
Ultra
large
Scale
Systems
Software
Challenge
Future
book
produced
U
S
Department
Defense
introduces
notion
ultra
large
scale
systems
systems
systems
hundreds
nodes
discusses
issues
challenges
developing
systems
L
Northrop
et
al
Software
Engineering
Institute
http
www
sei
cmu
edu
library
assets
ULS
Book
pdf
Large
scale
Complex
Systems
paper
discusses
problems
large
scale
complex
systems
systems
systems
expands
ideas
breakdown
reductionism
proposes
number
research
challenges
area
SoS
Sommerville
et
al
Communications
ACM
July
http
dx
doi
org
WebSiTe
PowerPoint
slides
chapter
www
pearsonglobaleditions
com
Sommerville
Links
supporting
videos
http
software
engineering
book
com
videos
systems
engineering
exeRCiSeS
Explain
managerial
operational
independence
key
distinguishing
characteristics
systems
systems
compared
large
complex
systems
Briefly
explain
four
essential
characteristics
systems
systems
@@@@@@@@@@
Chapter
Systems
systems
classification
SoS
presented
Section
suggests
governance
based
classification
scheme
Giving
reasons
answer
identify
classifications
following
systems
systems
health
care
system
provides
unified
access
patient
health
records
hospitals
clinics
primary
care
b
World
Wide
Web
c
government
system
provides
access
range
welfare
services
pensions
disability
benefits
unemployment
benefits
problems
suggested
classification
systems
Explain
meant
reductionism
effective
basis
many
kinds
engineering
Define
systems
systems
engineering
List
problems
software
SoS
engineering
common
problems
integrating
large
scale
application
systems
beneficial
unified
user
interface
interface
design
SoS
factors
cost
effectiveness
unified
user
interface
dependent
Sillitto
suggests
communications
nodes
SoS
technical
include
informal
sociotechnical
communications
people
involved
system
Using
iLearn
SoS
example
suggest
informal
communications
important
improve
effectiveness
system
Suggest
closest
fit
architectural
pattern
systems
systems
introduced
Exercise
trading
system
pattern
assumes
no
central
authority
involved
However
areas
equity
trading
trading
systems
follow
regulatory
rules
Suggest
pattern
modified
allow
regulator
check
rules
followed
involve
trades
going
central
node
work
software
company
developed
system
provides
information
consumers
used
SoS
number
retail
businesses
pay
services
used
Discuss
ethics
changing
system
interfaces
without
notice
coerce
users
paying
higher
charges
Consider
question
point
view
company
s
employees
customers
shareholders
ReFeRenCeS
Boehm
B
C
Abts
COTS
Integration
Plug
Pray
Computer
doi
Hitchins
D
System
Systems
Ultimate
Tautology
http
www
hitchins
net
profsstuff
profs
blog
system
systems
html
@@@@@@@@@@
Chapter
References
Kawalsky
R
D
Joannou
Y
Tian
Fayoumi
Using
Architecture
Patterns
Architect
Analyze
Systems
Systems
Conference
Systems
Engineering
Research
CSER
doi
j
procs
Maier
M
W
Architecting
Principles
Systems
Systems
Systems
Engineering
doi
SICI
AID
SYS
CO
D
MOD
UK
MOD
Architecture
Framework
https
www
gov
uk
mod
architecture
framework
Northrop
Linda
R
P
Gabriel
M
Klein
D
Schmidt
Ultra
Large
Scale
Systems
Software
Challenge
Future
Pittsburgh
Software
Engineering
Institute
http
www
sei
cmu
edu
library
assets
ULS
Book
pdf
Open
Group
Open
Group
Standard
TOGAF
Version
http
pubs
opengroup
org
architecture
togaf
doc
arch
Rittel
H
M
Webber
Dilemmas
General
Theory
Planning
Policy
Sciences
doi
BF
Royal
Academy
Engineering
Challenges
Complex
Projects
London
http
www
bcs
org
upload
pdf
complexity
pdf
Sillitto
H
Design
Principles
Ultra
Large
Scale
Systems
Proceedings
th
International
Council
Systems
Engineering
International
Symposium
Chicago
Sommerville
D
Cliff
R
Calinescu
J
Keen
T
Kelly
M
Kwiatkowska
J
McDermid
R
Paige
Large
Scale
Complex
Systems
Comm
ACM
doi
Stevens
R
Engineering
Mega
Systems
Challenge
Systems
Engineering
Information
Age
Boca
Raton
FL
CRC
Press
@@@@@@@@@@
Real
time
software
engineering
Objectives
objective
chapter
introduce
characteristic
features
embedded
real
time
software
engineering
read
chapter
understand
concept
embedded
software
used
control
systems
react
external
events
environment
introduced
design
process
real
time
systems
software
systems
organized
set
cooperating
processes
understand
three
architectural
patterns
commonly
used
embedded
real
time
systems
design
understand
organization
real
time
operating
systems
role
play
embedded
real
time
system
Contents
Embedded
systems
design
Architectural
patterns
real
time
software
Timing
analysis
Real
time
operating
systems
@@@@@@@@@@
Chapter
Real
time
software
engineering
Computers
used
control
wide
range
systems
simple
domestic
machines
games
controllers
entire
manufacturing
plants
computers
interact
directly
hardware
devices
software
react
events
generated
hardware
often
issue
control
signals
response
events
signals
result
action
initiation
phone
call
movement
character
screen
opening
valve
display
system
status
software
systems
embedded
system
hardware
often
read
memory
responds
real
time
events
system
s
environment
real
time
mean
software
system
deadline
responding
external
events
deadline
missed
overall
hardware
software
system
operate
correctly
Embedded
software
important
economically
every
electrical
device
now
includes
software
therefore
many
embedded
software
systems
types
software
systems
Ebert
Jones
Ebert
Jones
estimated
embedded
microprocessor
systems
per
person
developed
countries
figure
increasing
per
year
suggests
embedded
systems
per
person
Responsiveness
real
time
critical
difference
embedded
systems
software
systems
information
systems
web
based
systems
personal
software
systems
main
purpose
data
processing
non
real
time
systems
correctness
system
defined
specifying
system
inputs
map
corresponding
outputs
produced
system
response
input
corresponding
output
generated
system
often
data
stored
example
choose
create
command
patient
information
system
correct
system
response
create
new
patient
record
database
confirm
done
reasonable
limits
matter
long
takes
However
real
time
system
correctness
depends
response
input
time
taken
generate
response
system
takes
long
respond
required
response
ineffective
example
embedded
software
controlling
car
s
braking
system
slow
accident
occur
impossible
stop
car
time
Therefore
time
fundamental
definition
real
time
software
system
real
time
software
system
system
correct
operation
depends
results
produced
system
time
results
produced
soft
real
time
system
system
operation
degraded
results
produced
according
specified
timing
requirements
results
produced
according
timing
specification
hard
real
time
system
considered
system
failure
Timely
response
important
factor
embedded
systems
embedded
systems
require
fast
response
example
insulin
pump
software
used
example
several
chapters
book
embedded
system
However
system
needs
check
glucose
level
periodic
intervals
need
@@@@@@@@@@
respond
quickly
external
events
wilderness
weather
station
software
embedded
system
require
fast
response
external
events
well
need
real
time
response
important
differences
embedded
systems
types
software
system
Embedded
systems
generally
run
continuously
terminate
start
hardware
switched
execute
hardware
switched
off
Techniques
reliable
software
engineering
discussed
Chapter
therefore
used
ensure
continuous
operation
real
time
system
include
update
mechanisms
support
dynamic
reconfiguration
system
updated
service
Interactions
system
s
environment
unpredictable
interactive
systems
pace
interaction
controlled
system
limiting
user
options
events
commands
processed
known
advance
contrast
real
time
embedded
systems
able
respond
expected
unexpected
events
time
leads
design
real
time
systems
based
concurrency
several
processes
executing
parallel
Physical
limitations
affect
design
system
Examples
limitations
include
restrictions
power
available
system
physical
space
taken
hardware
limitations
generate
requirements
embedded
software
need
conserve
power
prolong
battery
life
Size
weight
limitations
mean
software
take
hardware
functions
need
limit
number
chips
used
system
Direct
hardware
interaction
necessary
interactive
systems
information
systems
layer
software
device
drivers
hides
hardware
operating
system
possible
connect
types
device
systems
keyboards
mice
displays
contrast
embedded
systems
interact
wide
range
hardware
devices
separate
device
drivers
Issues
safety
reliability
dominate
system
design
Many
embedded
systems
control
devices
failure
high
human
economic
costs
Therefore
dependability
critical
system
design
ensure
safety
critical
behavior
times
often
leads
conservative
approach
design
tried
tested
techniques
used
instead
newer
techniques
introduce
new
failure
modes
Real
time
embedded
systems
thought
reactive
systems
react
events
environment
Berry
Lee
Response
times
often
governed
laws
physics
rather
chosen
human
convenience
contrast
types
software
system
controls
speed
interaction
example
word
processor
using
write
book
check
spelling
grammar
no
practical
limits
time
taken
@@@@@@@@@@
Embedded
system
design
design
process
embedded
software
software
designers
consider
detail
design
performance
system
hardware
Part
system
design
process
involve
deciding
system
capabilities
implemented
software
hardware
many
real
time
systems
embedded
consumer
products
systems
cell
phones
costs
power
consumption
hardware
critical
Specific
processors
designed
support
embedded
systems
used
systems
special
purpose
hardware
designed
built
top
software
design
process
design
starts
abstract
model
decomposed
developed
series
stages
impractical
real
time
systems
Low
level
decisions
hardware
support
software
system
timing
considered
early
process
limit
flexibility
system
designers
Additional
software
functionality
battery
power
management
included
system
Given
embedded
systems
reactive
systems
react
events
environment
general
approach
embedded
real
time
software
design
based
stimulus
response
model
stimulus
event
occurring
software
system
s
environment
causes
system
react
way
response
signal
message
software
sends
environment
define
behavior
real
time
system
listing
stimuli
received
system
associated
responses
time
response
produced
example
Figure
shows
possible
stimuli
system
responses
burglar
alarm
system
discussed
Section
Stimuli
fall
two
classes
Periodic
stimuli
occur
predictable
time
intervals
example
system
examine
sensor
every
milliseconds
take
action
respond
depending
sensor
value
stimulus
Aperiodic
stimuli
occur
irregularly
unpredictably
usually
signaled
using
computer
s
interrupt
mechanism
example
stimulus
interrupt
indicating
O
transfer
complete
data
available
buffer
Stimuli
come
sensors
system
s
environment
responses
sent
actuators
shown
Figure
actuators
control
equipment
pump
makes
changes
system
s
environment
actuators
generate
stimuli
stimuli
actuators
often
indicate
problem
actuator
occurred
handled
system
general
design
guideline
real
time
systems
separate
control
processes
type
sensor
actuator
Figure
type
sensor
sensor
management
process
handles
data
collection
sensors
Data
processing
processes
compute
required
responses
stimuli
received
system
Actuator
control
processes
associated
actuator
@@@@@@@@@@
Stimulus
Response
Stimulus
Response
Clear
alarms
Switch
off
active
alarms
switch
off
lights
switched
Console
panic
button
positive
Initiate
alarm
turn
lights
around
console
call
police
Power
supply
failure
Call
service
technician
Sensor
failure
Call
service
technician
Single
sensor
positive
Initiate
alarm
turn
lights
around
site
positive
sensor
Two
sensors
positive
Initiate
alarm
turn
lights
around
sites
positive
sensors
call
police
location
suspected
break
Voltage
drop
Switch
battery
backup
run
power
supply
test
Voltage
drop
Switch
battery
backup
initiate
alarm
call
police
run
power
supply
test
Figure
Stimuli
responses
burglar
alarm
system
manage
operation
actuator
model
allows
data
collected
quickly
sensor
overwritten
next
input
enables
processing
associated
actuator
response
carried
later
real
time
system
respond
stimuli
occur
different
times
therefore
organize
system
architecture
soon
stimulus
received
control
transferred
correct
handler
impractical
sequential
programs
Consequently
real
time
software
systems
normally
designed
set
concurrent
cooperating
processes
support
management
processes
execution
platform
real
time
system
executes
include
real
time
operating
system
discussed
Section
functions
provided
operating
system
accessed
runtime
support
system
real
time
programming
language
used
no
standard
embedded
system
design
process
Rather
different
processes
used
depend
type
system
available
hardware
organization
developing
system
following
activities
included
real
time
software
design
process
Platform
selection
activity
choose
execution
platform
system
hardware
real
time
operating
system
used
Factors
influence
choices
include
timing
constraints
system
limitations
power
available
experience
development
team
price
target
delivered
system
Stimuli
response
identification
involves
identifying
stimuli
system
process
associated
response
responses
stimulus
@@@@@@@@@@
SensorSensorSensor
SensorSensorSensor
Stimuli
SensorSensorSensor
SensorSensorSensor
Stimuli
Real
time
Figure
general
model
embedded
real
time
system
control
system
Actuator
Actuator
Actuator
Actuator
Responses
Timing
analysis
stimulus
associated
response
identify
timing
constraints
apply
stimulus
response
processing
constraints
used
establish
deadlines
processes
system
Process
design
Process
design
involves
aggregating
stimulus
response
processing
number
concurrent
processes
good
starting
point
designing
process
architecture
architectural
patterns
describe
Section
optimize
process
architecture
reflect
specific
requirements
implement
Algorithm
design
stimulus
response
design
algorithms
carry
required
computations
Algorithm
designs
developed
relatively
early
design
process
indicate
amount
processing
required
time
needed
complete
processing
especially
important
computationally
intensive
tasks
signal
processing
Data
design
specify
information
exchanged
processes
events
coordinate
information
exchange
design
data
structures
manage
information
exchange
Several
concurrent
processes
share
data
structures
Process
scheduling
design
scheduling
system
ensure
processes
started
time
meet
deadlines
specific
activities
activity
sequence
real
time
system
design
process
depend
type
system
developed
novelty
environment
DataprocessorActuatorcontrolActuatorSensorcontrolSensorStimulusResponse
Figure
Sensor
actuator
processes
@@@@@@@@@@
Figure
Producer
consumer
processes
sharing
circular
buffer
Circular
Buffer
Producer
process
Head
Tail
v
v
v
v
v
v
v
v
v
v
Consumer
process
cases
new
systems
able
follow
fairly
abstract
approach
start
stimuli
associated
processing
decide
hardware
execution
platforms
late
process
cases
choice
hardware
operating
system
made
software
design
starts
design
software
take
account
constraints
imposed
system
hardware
Processes
real
time
system
coordinated
share
information
Process
coordination
mechanisms
ensure
mutual
exclusion
shared
resources
one
process
modifying
shared
resource
processes
able
change
resource
Mechanisms
ensuring
mutual
exclusion
include
semaphores
monitors
critical
regions
process
synchronization
mechanisms
described
operating
system
books
Silberschaltz
Galvin
Gagne
Stallings
designing
information
exchange
processes
take
account
processes
running
different
speeds
One
process
producing
information
process
consuming
information
producer
running
faster
consumer
new
information
overwrite
previously
read
information
item
consumer
process
read
original
information
consumer
process
running
faster
producer
process
item
read
twice
avoid
problem
implement
information
exchange
using
shared
buffer
use
mutual
exclusion
mechanisms
control
access
buffer
means
information
t
overwritten
read
information
cannot
read
twice
Figure
illustrates
organization
shared
buffer
usually
implemented
circular
queue
using
list
data
structure
Mismatches
speed
producer
consumer
processes
accommodated
without
delay
process
execution
producer
process
enters
data
buffer
location
end
queue
represented
v
Figure
consumer
process
retrieves
information
head
queue
represented
v
Figure
consumer
process
retrieved
information
tail
queue
adjusted
point
next
item
v
producer
process
added
information
tail
queue
adjusted
point
next
free
slot
queue
@@@@@@@@@@
Obviously
important
ensure
producer
consumer
process
attempt
access
item
time
e
Head
Tail
value
item
unpredictable
system
ensure
producer
process
add
items
full
buffer
consumer
process
try
take
items
empty
buffer
implement
circular
buffer
process
Get
Put
operations
access
buffer
Put
operation
called
producer
process
Get
operation
consumer
process
Synchronization
primitives
semaphores
critical
regions
used
ensure
operation
Get
Put
synchronized
don
t
access
location
simultaneously
buffer
full
Put
process
wait
slot
free
buffer
empty
Get
process
wait
entry
made
chosen
execution
platform
system
designed
process
architecture
decided
scheduling
policy
check
system
meet
timing
requirements
perform
check
static
analysis
system
using
knowledge
timing
behavior
components
simulation
analysis
reveal
system
perform
adequately
process
architecture
scheduling
policy
execution
platform
redesigned
improve
performance
system
Timing
constraints
requirements
sometimes
mean
best
implement
system
functions
signal
processing
hardware
Modern
hardware
components
FPGAs
field
programmable
gate
arrays
flexible
adapted
different
functions
Hardware
components
deliver
much
better
performance
equivalent
software
System
processing
bottlenecks
identified
replaced
hardware
thus
avoiding
expensive
software
optimization
Real
time
system
modeling
events
real
time
system
react
often
cause
system
move
one
state
another
reason
state
models
introduced
Chapter
used
describe
real
time
systems
state
model
system
assumes
time
system
one
number
possible
states
stimulus
received
cause
transition
different
state
example
system
controlling
valve
move
state
Valve
open
state
Valve
closed
operator
command
stimulus
received
State
models
integral
part
real
time
system
design
methods
UML
supports
development
state
models
based
Statecharts
Harel
Statecharts
formal
state
machine
models
support
hierarchical
states
groups
states
considered
single
entity
Douglass
discusses
use
UML
real
time
systems
development
Douglass
already
illustrated
approach
system
modeling
Chapter
used
example
model
simple
microwave
oven
Figure
another
example
state
model
shows
operation
fuel
delivery
software
system
embedded
petrol
gas
pump
rounded
rectangles
represent
system
states
arrows
represent
stimuli
force
transition
one
state
another
@@@@@@@@@@
Timeout
Card
inserted
reader
Timeout
Resetting
display
CC
error
Initializing
initialize
display
Paying
Stopped
Reading
get
CC
details
Waiting
display
welcome
deliver
fuel
debit
CC
account
Payment
ack
Ready
Delivering
update
displayNozzle
trigger
Nozzle
trigger
off
Nozzle
trigger
Hose
holster
validate
credit
card
Validating
Invalid
card
Card
removed
Card
Hose
holster
Hose
inholster
Figure
State
machine
model
petrol
gas
pump
names
chosen
state
machine
diagram
descriptive
associated
information
indicates
actions
taken
system
actuators
information
displayed
Notice
system
never
terminates
idles
waiting
state
pump
operating
fuel
delivery
system
designed
allow
unattended
operation
following
sequence
actions
buyer
inserts
credit
card
card
reader
built
pump
causes
transition
Reading
state
card
details
read
buyer
asked
remove
card
Removal
card
triggers
transition
Validating
state
card
validated
card
valid
system
initializes
pump
fuel
hose
removed
holster
transitions
Delivering
state
ready
deliver
fuel
Activating
trigger
nozzle
causes
fuel
pumped
stops
trigger
released
simplicity
ignored
pressure
switch
designed
stop
fuel
spillage
@@@@@@@@@@
Real
time
Java
Java
programming
language
modified
make
suitable
real
time
systems
development
modifications
include
asynchronous
communications
addition
time
including
absolute
relative
time
new
thread
model
threads
cannot
interrupted
garbage
collection
new
memory
management
model
avoids
unpredictable
delays
result
garbage
collection
http
software
engineering
book
com
web
real
time
java
fuel
delivery
complete
buyer
replaced
hose
holster
system
moves
Paying
state
user
s
account
debited
payment
pump
software
returns
Waiting
state
State
models
used
model
driven
engineering
discussed
Chapter
define
operation
system
transformed
automatically
semiau
tomatically
executable
program
Real
time
programming
Programming
languages
real
time
systems
development
include
facilities
access
system
hardware
possible
predict
timing
particular
operations
languages
Hard
real
time
systems
running
limited
hardware
still
sometimes
programmed
assembly
language
tight
deadlines
met
Systems
programming
languages
C
allow
efficient
code
generated
widely
used
advantage
using
systems
programming
language
like
C
allows
development
efficient
programs
However
languages
include
constructs
support
concurrency
management
shared
resources
Concurrency
resource
management
implemented
calls
primitives
provided
real
time
operating
system
mutual
exclusion
compiler
cannot
check
calls
programming
errors
likely
Programs
often
difficult
understand
language
include
real
time
features
well
understanding
program
reader
know
real
time
support
provided
using
system
calls
real
time
systems
meet
timing
constraints
able
use
object
oriented
development
hard
real
time
systems
Object
oriented
development
involves
hiding
data
representations
accessing
attribute
values
operations
defined
object
significant
performance
overhead
object
oriented
systems
extra
code
required
mediate
access
attributes
handle
calls
operations
consequent
loss
performance
make
impossible
meet
real
time
deadlines
version
Java
developed
embedded
systems
development
Burns
Wellings
Bruno
Bollella
language
includes
modified
thread
mechanism
allows
threads
specified
interrupted
@@@@@@@@@@
language
garbage
collection
mechanism
Asynchronous
event
handling
timing
specification
included
However
time
writing
specification
mostly
used
platforms
significant
processor
memory
capacity
e
g
cell
phone
rather
simpler
embedded
systems
limited
resources
systems
still
usually
implemented
C
Architectural
patterns
real
time
software
Architectural
patterns
abstract
stylized
descriptions
good
design
practice
capture
knowledge
organization
system
architectures
architectures
used
advantages
disadvantages
use
architectural
pattern
understand
architecture
starting
point
creating
specific
architectural
design
difference
real
time
interactive
software
means
distinct
architectural
patterns
real
time
embedded
systems
Real
time
systems
patterns
process
oriented
rather
object
component
oriented
section
discuss
three
real
time
architectural
patterns
commonly
used
Observe
React
pattern
used
set
sensors
routinely
monitored
displayed
sensors
show
event
occurred
e
g
incoming
call
cell
phone
system
reacts
initiating
process
handle
event
Environmental
Control
pattern
used
system
includes
sensors
provide
information
environment
actuators
change
environment
response
environmental
changes
detected
sensor
control
signals
sent
system
actuators
Process
Pipeline
pattern
used
data
transformed
one
representation
another
processed
transformation
implemented
sequence
processing
steps
carried
concurrently
allows
fast
data
processing
separate
core
processor
execute
transformation
patterns
course
combined
often
see
one
single
system
example
Environmental
Control
pattern
used
common
actuators
monitored
using
Observe
React
pattern
event
actuator
failure
system
react
displaying
warning
message
shutting
actuator
switching
backup
system
forth
patterns
cover
architectural
patterns
describe
overall
structure
embedded
system
Douglass
Douglass
describes
lower
level
real
time
design
patterns
support
detailed
design
decision
making
patterns
include
design
patterns
execution
control
communications
resource
allocation
safety
reliability
@@@@@@@@@@
Name
Observe
React
Name
Observe
React
Description
input
values
set
sensors
types
collected
analyzed
values
displayed
way
sensor
values
indicate
exceptional
condition
arisen
actions
initiated
draw
operator
s
attention
value
necessary
take
actions
response
exceptional
value
Stimuli
Values
sensors
attached
system
Responses
Outputs
display
alarm
triggers
signals
reacting
systems
Processes
Observer
Analysis
Display
Alarm
Reactor
Used
Monitoring
systems
alarm
systems
Figure
Observe
React
pattern
Sensors
Display
Analysis
process
Observer
process
Reactor
process
Alarm
process
Sensor
values
Display
process
Display
values
equipment
Figure
Observe
React
process
structure
Alarm
architectural
patterns
starting
point
embedded
systems
design
however
design
templates
use
probably
end
inefficient
process
architecture
optimize
process
structure
ensure
many
processes
ensure
clear
correspondence
processes
sensors
actuators
system
Observe
react
Monitoring
systems
important
class
embedded
real
time
systems
monitoring
system
examines
environment
set
sensors
usually
displays
state
environment
way
built
screen
special
purpose
instrument
displays
remote
display
system
detects
exceptional
event
sensor
state
monitoring
system
takes
action
@@@@@@@@@@
Lighting
control
process
External
alert
process
Voltage
monitor
process
System
controller
Console
display
process
Door
sensor
process
Movement
detector
process
Window
sensor
process
Audible
alarm
process
Control
panel
process
Testing
process
Power
management
process
Lighting
control
process
External
alert
process
Voltage
monitor
process
System
controller
Console
display
process
Door
sensor
process
Movement
detector
process
Window
sensor
process
Audible
alarm
process
Control
panel
process
Testing
process
Power
management
process
Figure
process
structure
burglar
alarm
system
often
involves
raising
alarm
draw
operator
s
attention
event
Sometimes
system
initiate
preventative
action
shutting
system
preserve
damage
Observe
React
pattern
Figures
commonly
used
monitoring
systems
values
sensors
observed
system
initiates
actions
depend
sensor
values
Monitoring
systems
composed
several
instantiations
Observe
React
pattern
one
type
sensor
system
Depending
system
requirements
optimize
design
combining
processes
e
g
use
single
display
process
display
information
different
types
sensor
example
use
pattern
consider
design
burglar
alarm
system
installed
office
building
software
system
implemented
part
burglar
alarm
system
commercial
buildings
uses
several
different
types
sensors
sensors
include
movement
detectors
individual
rooms
door
sensors
detect
corridor
doors
opening
window
sensors
ground
floor
windows
detect
window
opened
sensor
detects
presence
intruder
system
automatically
calls
local
police
using
voice
synthesizer
reports
location
alarm
switches
lights
rooms
around
active
sensor
sets
off
audible
alarm
sensor
system
normally
powered
mains
power
equipped
battery
backup
Power
loss
detected
using
separate
power
circuit
monitor
monitors
mains
voltage
voltage
drop
detected
system
assumes
intruders
interrupted
power
supply
alarm
raised
process
architecture
alarm
system
shown
Figure
arrows
represent
signals
sent
one
process
another
system
soft
real
time
system
stringent
timing
requirements
sensors
need
detect
@@@@@@@@@@
Name
Environmental
Control
Name
Environmental
Control
Description
system
analyzes
information
set
sensors
collect
data
system
s
environment
information
collected
state
actuators
connected
system
Based
data
sensors
actuators
control
signals
sent
actuators
cause
changes
system
s
environment
Information
sensor
values
state
actuators
displayed
Stimuli
Values
sensors
attached
system
state
system
actuators
Responses
Control
signals
actuators
display
information
Processes
Monitor
Control
Display
Actuator
driver
Actuator
monitor
Used
Control
systems
Figure
Environmental
Control
pattern
Display
Sensors
Control
process
Monitor
process
Actuator
monitor
process
Actuator
driver
process
Sensor
values
Display
process
Display
values
Actuator
Control
instructions
Actuator
state
Figure
Environmental
Control
process
structure
presence
people
rather
high
speed
events
need
polled
times
per
second
cover
timing
requirements
system
Section
already
introduced
stimuli
responses
alarm
system
Figure
responses
used
starting
point
system
design
Observe
React
pattern
used
design
observer
processes
associated
type
sensor
reactor
processes
type
reaction
single
analysis
process
checks
data
sensors
display
processes
pattern
combined
single
display
process
Environmental
Control
widespread
use
real
time
embedded
software
control
systems
systems
software
controls
operation
equipment
based
stimuli
@@@@@@@@@@
Pedal
pressure
sensor
Analysis
process
Wheel
monitor
Pedal
monitor
Brake
process
Brake
process
Brake
process
Brake
process
Brake
Brake
Brake
Brake
Wheel
sensors
Figure
Control
system
architecture
anti
skid
braking
system
equipment
s
environment
example
anti
skid
braking
system
car
monitors
car
s
wheels
brake
system
system
s
environment
looks
signs
wheels
skidding
brake
pressure
applied
case
system
adjusts
brake
pressure
stop
wheels
locking
reduce
likelihood
skid
Control
systems
make
use
Environmental
Control
pattern
general
control
pattern
includes
sensor
actuator
processes
pattern
described
Figure
process
architecture
shown
Figure
variant
pattern
leaves
display
process
variant
used
situations
user
intervention
required
rate
control
high
display
meaningful
pattern
basis
control
system
design
instantiation
Environmental
Control
pattern
actuator
actuator
type
controlled
optimize
design
reduce
number
processes
example
combine
actuator
monitoring
actuator
control
processes
single
monitoring
control
process
several
actuators
optimizations
choose
depend
timing
requirements
need
monitor
sensors
frequently
send
control
signals
case
impractical
combine
control
monitoring
processes
direct
feedback
actuator
control
actuator
monitoring
process
allows
fine
grain
control
decisions
made
actuator
control
process
see
pattern
used
Figure
shows
example
controller
car
braking
system
starting
point
design
associating
instance
pattern
actuator
type
system
case
four
actuators
controlling
brake
one
wheel
individual
sensor
processes
combined
single
wheel
monitoring
process
monitors
sensors
@@@@@@@@@@
Name
Process
Pipeline
Name
Process
Pipeline
Description
pipeline
processes
set
data
moving
sequence
one
end
pipeline
another
processes
often
linked
synchronized
buffers
allow
producer
consumer
processes
run
different
speeds
culmination
pipeline
display
data
storage
pipeline
terminate
actuator
Stimuli
Input
values
environment
process
Responses
Output
values
environment
shared
buffer
Processes
Producer
Buffer
Consumer
Used
Data
acquisition
systems
multi
media
systems
Figure
Process
Pipeline
pattern
BufferprocessProducerprocessConsumerprocess
Figure
Process
Pipeline
process
structure
Produced
Consumed
data
data
wheels
monitors
state
wheel
check
wheel
turning
locked
separate
process
monitors
pressure
brake
pedal
exerted
car
driver
system
includes
anti
skid
feature
triggered
sensors
indicate
wheel
locked
brake
applied
means
insufficient
friction
road
tire
words
car
skidding
wheel
locked
driver
cannot
steer
wheel
counteract
effect
system
sends
rapid
sequence
off
signals
brake
wheel
allows
wheel
turn
control
regained
Wheel
monitor
process
monitors
wheel
turning
wheel
skidding
turning
informs
Analysis
process
signals
processes
associated
wheels
skidding
initiate
anti
skid
braking
Process
pipeline
Many
real
time
systems
concerned
collecting
analog
data
system
s
environment
digitize
data
analysis
processing
system
system
convert
digital
data
analog
data
sends
environment
example
software
radio
accepts
incoming
packets
digital
data
representing
radio
transmission
transforms
data
sound
signal
people
listen
data
processing
involved
many
systems
carried
quickly
Otherwise
incoming
data
lost
outgoing
signals
broken
essential
information
missing
Process
Pipeline
pattern
makes
rapid
processing
possible
breaking
required
data
processing
sequence
separate
transformations
transformations
implemented
@@@@@@@@@@
Flux
value
buffer
Flux
processing
Raw
data
buffer
D
convertor
Sensor
identifier
flux
value
Processed
flux
level
Neutron
flux
sensors
Storage
Display
Flux
value
buffer
Flux
processing
Raw
data
buffer
D
convertor
Sensor
identifier
flux
value
Processed
flux
level
Neutron
flux
sensors
Storage
Display
Figure
Neutron
flux
data
acquisition
independent
process
architecture
efficient
systems
use
multiple
processors
multicore
processors
process
pipeline
associated
separate
processor
core
processing
steps
carried
parallel
Figure
brief
description
data
pipeline
pattern
Figure
shows
process
architecture
pattern
Notice
processes
involved
produce
consume
information
processes
exchange
information
using
synchronized
buffers
explained
Section
Producer
consumer
processes
thereby
operate
different
speeds
without
data
losses
example
system
use
process
pipeline
high
speed
data
acquisition
system
Data
acquisition
systems
collect
data
sensors
subsequent
processing
analysis
systems
used
situations
sensors
collecting
large
volumes
data
system
s
environment
isn
t
possible
necessary
process
data
real
time
Rather
collected
stored
later
analysis
Data
acquisition
systems
often
used
scientific
experiments
process
control
systems
physical
processes
chemical
reactions
rapid
systems
sensors
generating
data
quickly
data
acquisition
system
ensure
sensor
reading
collected
sensor
value
changes
Figure
simplified
model
data
acquisition
system
part
control
software
nuclear
reactor
system
collects
data
sensors
monitoring
neutron
flux
density
neutrons
reactor
sensor
data
placed
buffer
extracted
processed
average
flux
level
displayed
operator
s
display
stored
future
processing
Timing
analysis
discussed
introduction
chapter
correctness
real
time
system
depends
correctness
outputs
time
outputs
produced
Therefore
timing
analysis
important
activity
embedded
real
time
software
development
process
analysis
calculate
often
process
system
executed
ensure
inputs
@@@@@@@@@@
processed
system
responses
produced
timely
way
results
timing
analysis
used
decide
frequently
process
execute
processes
scheduled
real
time
operating
system
Timing
analysis
real
time
systems
particularly
difficult
system
deal
mixture
periodic
aperiodic
stimuli
responses
aperiodic
stimuli
unpredictable
make
assumptions
probability
stimuli
occurring
therefore
requiring
service
particular
time
assumptions
incorrect
system
performance
delivery
adequate
Cooling
s
book
Cooling
discusses
techniques
real
time
system
performance
analysis
takes
aperiodic
events
account
computers
faster
possible
many
systems
design
using
periodic
stimuli
processors
slow
aperiodic
stimuli
used
ensure
critical
events
processed
deadline
delays
processing
usually
involved
loss
system
example
failure
power
supply
embedded
system
mean
system
shut
attached
equipment
controlled
way
short
time
say
milliseconds
implemented
power
fail
interrupt
However
implemented
using
periodic
process
runs
frequently
checks
power
long
time
process
invocations
short
still
time
perform
controlled
shutdown
system
lack
power
causes
damage
reason
discuss
timing
issues
periodic
processes
analyzing
timing
requirements
embedded
real
time
systems
designing
systems
meet
requirements
consider
three
key
factors
Deadlines
times
stimuli
processed
response
produced
system
system
meet
deadline
hard
real
time
system
system
failure
soft
real
time
system
results
degraded
system
service
Frequency
number
times
per
second
process
execute
confident
meet
deadlines
Execution
time
time
required
process
stimulus
produce
response
Execution
time
conditional
execution
code
delays
waiting
processes
Therefore
consider
average
execution
time
process
worst
case
execution
time
process
worst
case
execution
time
maximum
time
process
takes
execute
hard
real
time
system
make
assumptions
based
worst
case
execution
time
ensure
deadlines
missed
soft
real
time
systems
base
calculations
average
execution
time
continue
example
power
supply
failure
let
s
calculate
worst
case
execution
time
process
switches
equipment
power
mains
@@@@@@@@@@
Voltage
Normal
voltage
R
R
R
R
Battery
startup
Power
switcher
ms
ms
ms
ms
ms
ms
ms
ms
ms
ms
level
Critical
voltage
level
Time
Figure
power
battery
backup
Figure
presents
timeline
showing
events
Power
failure
timing
analysis
system
Assume
mains
power
failure
event
takes
milliseconds
ms
supplied
voltage
drop
level
equipment
damaged
battery
backup
therefore
activated
operation
ms
Usually
allow
margin
error
set
shorter
deadline
ms
physical
variations
equipment
means
equipment
running
battery
backup
power
supply
ms
However
battery
backup
system
cannot
instantaneously
activated
takes
ms
starting
backup
power
supply
supply
fully
operational
means
time
available
detect
power
failure
start
battery
backup
system
ms
process
scheduled
run
times
per
second
every
ms
process
assumes
power
supply
problem
significant
drop
voltage
occurs
readings
sustained
three
readings
time
allowed
temporary
fluctuations
cause
switch
battery
backup
system
timeline
power
fails
immediately
reading
taken
Therefore
reading
R
start
reading
power
fail
check
voltage
continues
drop
readings
R
R
power
failure
assumed
worst
possible
case
power
failure
event
occurs
immediately
sensor
check
ms
elapsed
since
event
stage
process
switches
battery
backup
started
battery
backup
takes
ms
operational
worst
case
execution
time
process
ms
ms
deadline
reached
@@@@@@@@@@
Stimulus
Response
Timing
requirements
Stimulus
Response
Timing
requirements
Audible
alarm
audible
alarm
switched
half
second
alarm
raised
sensor
Communications
call
police
started
seconds
alarm
raised
sensor
Door
alarm
door
alarm
polled
twice
per
second
Lights
switch
lights
switched
half
second
alarm
raised
sensor
Movement
detector
movement
detector
polled
twice
per
second
Power
failure
switch
backup
power
completed
deadline
ms
Voice
synthesizer
synthesized
message
available
seconds
alarm
raised
sensor
Window
alarm
window
alarm
polled
twice
per
second
Figure
Timing
requirements
burglar
alarm
system
starting
point
timing
analysis
real
time
system
timing
requirements
set
deadlines
required
response
system
Figure
shows
possible
timing
requirements
office
building
burglar
alarm
system
discussed
Section
simplify
example
let
us
ignore
stimuli
generated
system
testing
procedures
external
signals
reset
system
event
false
alarm
means
two
types
stimulus
processed
system
Power
failure
detected
observing
voltage
drop
required
response
switch
circuit
backup
power
signaling
electronic
power
switching
device
switches
mains
power
battery
backup
Intruder
alarm
stimulus
generated
one
system
sensors
response
stimulus
compute
room
number
active
sensor
set
call
police
initiate
voice
synthesizer
manage
call
switch
audible
intruder
alarm
building
lights
area
shown
Figure
list
timing
constraints
class
sensor
separately
even
case
considering
separately
leave
scope
future
change
make
easier
compute
number
times
controlling
process
executed
second
Allocating
system
functions
concurrent
processes
next
design
stage
Four
types
sensors
polled
periodically
associated
process
voltage
sensor
door
sensors
window
sensors
movement
detectors
Normally
processes
associated
sensor
execute
quickly
@@@@@@@@@@
Hz
ms
Hz
ms
B
Figure
Alarm
process
timing
Lighting
control
process
External
alert
process
Voltage
monitor
process
System
controller
Console
display
Audible
alarm
process
Door
sensor
process
Movement
Testing
process
detector
process
Window
sensor
process
Control
panel
process
Hz
ms
ms
process
Power
management
process
Hz
ms
Hz
ms
Hz
Hz
ms
R
ms
R
ms
R
ms
R
ms
checking
sensor
changed
status
e
g
off
reasonable
assume
execution
time
check
assess
state
one
sensor
less
millisecond
ensure
meet
deadlines
defined
timing
requirements
decide
frequently
related
processes
run
many
sensors
examined
execution
process
obvious
trade
offs
frequency
execution
time
deadline
detecting
change
state
second
means
sensor
checked
times
per
second
examine
one
sensor
process
execution
N
sensors
particular
type
schedule
process
N
times
per
second
ensure
sensors
checked
deadline
examine
four
sensors
say
process
execution
execution
time
increased
ms
need
run
process
N
times
second
meet
timing
requirement
case
system
requirements
define
actions
two
sensors
positive
best
strategy
examine
sensors
groups
groups
based
physical
proximity
sensors
intruder
entered
building
probably
adjacent
sensors
positive
completed
timing
analysis
annotate
process
model
information
frequency
execution
expected
execution
time
see
Figure
periodic
processes
annotated
frequency
processes
started
response
stimulus
annotated
R
testing
process
background
process
annotated
B
background
process
@@@@@@@@@@
runs
processor
time
available
general
simpler
design
system
small
number
process
frequencies
execution
times
represent
required
worst
case
execution
times
processes
final
step
design
process
design
scheduling
system
ensure
process
scheduled
meet
deadlines
know
scheduling
approaches
supported
real
time
operating
system
OS
used
Burns
Wellings
scheduler
real
time
OS
allocates
process
processor
given
amount
time
time
fixed
vary
depending
priority
process
allocating
process
priorities
consider
deadlines
process
processes
short
deadlines
receive
processor
time
meet
deadlines
example
voltage
monitor
process
burglar
alarm
needs
scheduled
voltage
drops
detected
switch
made
backup
power
system
fails
therefore
higher
priority
processes
check
sensor
values
fairly
relaxed
deadlines
compared
expected
execution
time
Real
time
operating
systems
execution
platform
application
systems
operating
system
manages
shared
resources
provides
features
file
system
runtime
process
management
However
extensive
functionality
conventional
operating
system
takes
great
deal
space
slows
operation
programs
Furthermore
process
management
features
system
designed
allow
fine
grain
control
scheduling
processes
reasons
standard
operating
systems
Linux
Windows
normally
used
execution
platform
real
time
systems
simple
embedded
systems
implemented
bare
metal
systems
systems
provide
execution
support
include
system
startup
shutdown
process
resource
management
process
scheduling
commonly
however
embedded
applications
built
top
real
time
operating
system
RTOS
efficient
operating
system
offers
features
needed
real
time
systems
Examples
RTOS
Windows
Embedded
Compact
VxWorks
RTLinux
real
time
operating
system
manages
processes
resource
allocation
real
time
system
starts
stops
processes
stimuli
handled
allocates
memory
processor
resources
components
RTOS
Figure
depend
size
complexity
real
time
system
developed
except
simplest
systems
usually
include
real
time
clock
provides
information
required
schedule
processes
periodically
interrupts
supported
interrupt
handler
manages
aperiodic
requests
service
@@@@@@@@@@
Scheduling
information
Scheduling
information
Process
resource
requirements
Scheduler
Resource
manager
Dispatcher
Real
time
clock
Processes
awaiting
resources
Ready
list
Interrupt
handler
Available
resource
list
Processor
list
Executing
process
Ready
processes
Released
resources
Figure
Components
real
time
operating
system
scheduler
responsible
examining
processes
executed
choosing
one
processes
execution
resource
manager
allocates
appropriate
memory
processor
resources
processes
scheduled
execution
dispatcher
responsible
starting
execution
processes
Real
time
operating
systems
large
systems
process
control
telecommunication
systems
additional
facilities
namely
disk
storage
management
fault
management
facilities
detect
report
system
faults
configuration
manager
supports
dynamic
reconfiguration
real
time
applications
Process
management
Real
time
systems
handle
external
events
quickly
cases
meet
deadlines
processing
events
event
handling
processes
therefore
scheduled
execution
time
detect
event
allocated
sufficient
processor
resources
meet
deadline
process
manager
RTOS
responsible
choosing
processes
execution
allocating
processor
memory
resources
starting
stopping
process
execution
processor
@@@@@@@@@@
Process
queue
Memory
map
Processor
list
Ready
list
Memory
map
Processor
list
Ready
list
Resource
manager
Allocate
memory
processor
Scheduler
Choose
process
execution
Dispatcher
Start
execution
available
processor
Figure
RTOS
actions
required
start
process
process
manager
manage
processes
different
priorities
stimuli
associated
certain
exceptional
events
essential
processing
completed
specified
time
limits
processes
safely
delayed
critical
process
requires
service
Consequently
RTOS
able
manage
least
two
priority
levels
system
processes
Clock
level
level
priority
allocated
periodic
processes
Interrupt
level
highest
priority
level
allocated
processes
need
fast
response
One
processes
real
time
clock
process
process
required
interrupts
supported
system
priority
level
allocated
background
processes
self
checking
process
need
meet
real
time
deadlines
processes
scheduled
execution
processor
capacity
available
Periodic
processes
executed
specified
time
intervals
data
acquisition
actuator
control
real
time
systems
several
types
periodic
process
Using
timing
requirements
specified
application
program
RTOS
arranges
execution
periodic
processes
meet
deadlines
actions
taken
operating
system
periodic
process
management
shown
Figure
scheduler
examines
list
periodic
processes
selects
process
executed
choice
depends
process
priority
process
periods
expected
execution
times
deadlines
ready
processes
Sometimes
two
processes
different
deadlines
executed
clock
tick
situation
one
process
delayed
Normally
system
choose
delay
process
longest
deadline
Processes
respond
quickly
asynchronous
events
interrupt
driven
computer
s
interrupt
mechanism
causes
control
transfer
predetermined
memory
location
location
contains
instruction
jump
simple
fast
interrupt
service
routine
service
routine
disables
interrupts
avoid
interrupted
discovers
cause
interrupt
initiates
high
priority
process
handle
stimulus
causing
interrupt
high
speed
data
acquisition
systems
interrupt
handler
saves
data
interrupt
signaled
available
buffer
later
processing
Interrupts
enabled
control
returned
operating
system
@@@@@@@@@@
one
time
several
processes
different
priorities
executed
process
scheduler
implements
system
scheduling
policies
determine
order
process
execution
two
commonly
used
scheduling
strategies
Nonpreemptive
scheduling
process
scheduled
execution
runs
completion
blocked
reason
waiting
input
cause
problems
processes
different
priorities
high
priority
process
wait
low
priority
process
finish
Preemptive
scheduling
execution
executing
process
stopped
higher
priority
process
requires
service
higher
priority
process
preempts
execution
lower
priority
process
allocated
processor
strategies
different
scheduling
algorithms
developed
include
round
robin
scheduling
process
executed
turn
rate
monotonic
scheduling
process
shortest
period
highest
frequency
given
priority
shortest
deadline
first
scheduling
process
queue
shortest
deadline
scheduled
Burns
Wellings
Information
process
executed
passed
resource
manager
resource
manager
allocates
memory
multiprocessor
system
adds
processor
process
process
placed
ready
list
list
processes
ready
execution
processor
finishes
executing
process
becomes
available
dispatcher
invoked
scans
ready
list
find
process
executed
available
processor
starts
execution
Key
Points
embedded
software
system
part
hardware
software
system
reacts
events
environment
software
embedded
hardware
Embedded
systems
normally
real
time
systems
real
time
system
software
system
respond
events
real
time
System
correctness
depend
results
produces
time
results
produced
Real
time
systems
usually
implemented
set
communicating
processes
react
stimuli
produce
responses
State
models
important
design
representation
embedded
real
time
systems
used
show
system
reacts
environment
events
trigger
changes
state
system
Several
standard
patterns
observed
different
types
embedded
system
include
pattern
monitoring
system
s
environment
adverse
events
pattern
actuator
control
data
processing
pattern
@@@@@@@@@@
Chapter
Exercises
Designers
real
time
systems
timing
analysis
driven
deadlines
processing
responding
stimuli
decide
often
process
system
run
expected
worst
case
execution
time
processes
real
time
operating
system
responsible
process
resource
management
includes
scheduler
component
responsible
deciding
process
scheduled
execution
REAding
Real
time
Systems
Programming
Language
Ada
Real
time
Java
C
Real
time
POSIX
th
ed
excellent
comprehensive
text
provides
broad
coverage
aspects
real
time
systems
Burns
Wellings
Addison
Wesley
Trends
Embedded
Software
Engineering
article
suggests
model
driven
development
discussed
Chapter
book
important
approach
embedded
systems
development
part
special
issue
embedded
systems
articles
one
Ebert
Jones
useful
reading
IEEE
Software
June
http
dx
doi
org
MS
Real
time
systems
Design
Principles
Distributed
Embedded
Applications
nd
ed
comprehensive
textbook
modern
real
time
systems
distributed
mobile
systems
author
focuses
hard
real
time
systems
covers
important
topics
Internet
connectivity
power
management
H
Kopetz
Springer
WEbsiTE
PowerPoint
slides
chapter
www
pearsonglobaleditions
com
Sommerville
Links
supporting
videos
http
software
engineering
book
com
videos
systems
engineering
ExERCisEs
Explain
responsiveness
real
time
critical
difference
embedded
systems
software
systems
Identify
possible
stimuli
expected
responses
embedded
system
controls
home
refrigerator
domestic
washing
machine
Using
state
based
approach
modeling
discussed
Section
model
operation
embedded
software
voicemail
system
included
landline
phone
@@@@@@@@@@
Chapter
Real
time
software
engineering
Train
protection
system
system
acquires
information
speed
limit
segment
trackside
transmitter
continually
broadcasts
segment
identifier
speed
limit
transmitter
broadcasts
information
status
signal
controlling
track
segment
time
required
broadcast
track
segment
signal
information
ms
train
receive
information
trackside
transmitter
m
transmitter
maximum
train
speed
kph
Sensors
train
provide
information
current
train
speed
updated
every
ms
train
brake
status
updated
every
ms
train
speed
exceeds
current
segment
speed
limit
kph
warning
sounded
driver
s
cabin
train
speed
exceeds
current
segment
speed
limit
kph
train
s
brakes
automatically
applied
speed
falls
segment
speed
limit
Train
brakes
applied
ms
time
excessive
train
speed
detected
train
enters
track
segment
signaled
red
light
train
protection
system
applies
train
brakes
reduces
speed
zero
Train
brakes
applied
ms
time
red
light
signal
received
system
continually
updates
status
display
driver
s
cabin
Figure
Requirements
train
protection
system
display
number
recorded
messages
LED
display
allow
user
dial
listen
recorded
messages
commonly
used
architectural
patterns
real
time
systems
used
Show
Environmental
Control
pattern
used
basis
design
system
control
temperature
greenhouse
temperature
degrees
Celsius
falls
degrees
heating
system
switched
goes
windows
automatically
opened
Design
process
architecture
environmental
monitoring
system
collects
data
set
air
quality
sensors
situated
around
city
sensors
organized
neighborhoods
sensor
interrogated
four
times
per
second
sensors
particular
neighborhood
indicate
air
quality
acceptable
level
local
warning
lights
activated
sensors
return
readings
central
computer
generates
reports
every
minutes
air
quality
city
train
protection
system
automatically
applies
brakes
train
speed
limit
segment
track
exceeded
train
enters
track
segment
currently
signaled
red
light
e
segment
entered
Details
shown
Figure
Identify
stimuli
processed
board
train
control
system
associated
responses
stimuli
@@@@@@@@@@
Chapter
References
Suggest
possible
process
architecture
system
periodic
process
board
train
protection
system
used
collect
data
trackside
transmitter
often
scheduled
ensure
system
guaranteed
collect
information
transmitter
Explain
arrived
answer
help
examples
define
real
time
operating
system
Explain
different
conventional
operating
system
components
included
real
time
operating
systems
responsibilities
REFEREnCEs
Berry
G
Real
Time
Programming
Special
Purpose
General
Purpose
Languages
Information
Processing
edited
G
Ritter
Amsterdam
Elsevier
Science
Publishers
Bruno
E
J
G
Bollella
Real
Time
Java
Programming
Java
RTS
Boston
Prentice
Hall
Burns
Wellings
Real
Time
Systems
Programming
Languages
Ada
Real
Time
Java
C
Real
Time
POSIX
Boston
Addison
Wesley
Cooling
J
Software
Engineering
Real
Time
Systems
Harlow
UK
Addison
Wesley
Douglass
B
P
Real
Time
UML
Developing
Efficient
Objects
Embedded
Systems
nd
ed
Boston
Addison
Wesley
Real
Time
Design
Patterns
Robust
Scalable
Architecture
Real
Time
Systems
Boston
Addison
Wesley
Ebert
C
C
Jones
Embedded
Software
Facts
Figures
Future
IEEE
Computer
doi
MC
Harel
D
Statecharts
Visual
Formalism
Complex
Systems
Sci
Comput
Programming
doi
Visual
Formalisms
Comm
ACM
doi
Lee
E
Embedded
Software
Advances
Computers
edited
M
Zelkowitz
Vol
London
Academic
Press
Silberschaltz
P
B
Galvin
G
Gagne
Operating
System
Concepts
th
ed
New
York
John
Wiley
Sons
Stallings
W
Operating
Systems
Internals
Design
Principles
th
ed
Boston
Prentice
Hall
@@@@@@@@@@
page
intentionally
left
blank
@@@@@@@@@@
PART
Software
Management
sometimes
suggested
key
difference
software
engineering
types
programming
software
engineering
managed
process
mean
software
development
takes
place
organization
subject
range
schedule
budget
organizational
constraints
introduce
range
management
topics
part
book
focus
technical
management
issues
rather
softer
management
issues
people
management
strategic
management
enterprise
systems
Chapters
focus
essential
project
management
activities
planning
risk
management
people
management
Chapter
introduces
software
project
management
first
major
section
concerned
risk
management
managers
identify
go
wrong
plan
chapter
includes
sections
people
management
team
working
Chapter
covers
project
planning
estimation
introduce
bar
charts
fundamental
planning
tools
explain
plan
driven
development
remain
important
development
approach
spite
success
agile
methods
discuss
issues
influence
price
charged
system
techniques
software
cost
estimation
use
COCOMO
family
cost
models
describe
algorithmic
cost
modeling
explain
benefits
disadvantages
algorithmic
approaches
@@@@@@@@@@
Chapters
explains
basics
software
quality
management
practised
large
projects
Quality
management
concerned
processes
techniques
ensuring
improving
quality
software
discuss
importance
standards
quality
management
use
reviews
inspections
quality
assurance
process
final
section
chapter
covers
software
measurement
discuss
benefits
problems
using
metrics
software
data
analytics
quality
management
Finally
Chapter
discusses
configuration
management
critical
issue
large
systems
However
need
configuration
management
obvious
students
concerned
personal
software
development
describe
various
aspects
topic
including
version
management
system
building
change
management
release
management
explain
continuous
integration
daily
system
building
important
important
change
edition
inclusion
new
material
distributed
version
management
systems
Git
increasingly
used
support
software
engineering
distributed
teams
@@@@@@@@@@
Project
management
Objectives
objective
chapter
introduce
software
project
management
two
important
management
activities
namely
risk
management
people
management
read
chapter
know
principal
tasks
software
project
managers
introduced
notion
risk
management
risks
arise
software
projects
understand
factors
influence
personal
motivation
mean
software
project
managers
understand
key
issues
influence
team
working
team
composition
organization
communication
Contents
Risk
management
Managing
people
Teamwork
@@@@@@@@@@
Chapter
Project
management
Software
project
management
essential
part
software
engineering
Projects
need
managed
professional
software
engineering
subject
organizational
budget
schedule
constraints
project
manager
s
job
ensure
software
project
meets
overcomes
constraints
well
delivering
high
quality
software
Good
management
cannot
guarantee
project
success
However
bad
management
usually
results
project
failure
software
delivered
late
cost
originally
estimated
fail
meet
expectations
customers
success
criteria
project
management
obviously
vary
project
project
projects
important
goals
deliver
software
customer
agreed
time
keep
overall
costs
budget
deliver
software
meets
customer
s
expectations
maintain
coherent
well
functioning
development
team
goals
unique
software
engineering
goals
engineering
projects
However
software
engineering
different
types
engineering
number
ways
make
software
management
particularly
challenging
differences
product
intangible
manager
shipbuilding
civil
engineering
project
see
product
developed
schedule
slips
effect
product
visible
parts
structure
obviously
unfinished
Software
intangible
cannot
seen
touched
Software
project
managers
cannot
see
progress
looking
artifact
constructed
Rather
rely
others
produce
evidence
use
review
progress
work
Large
software
projects
often
one
off
projects
Every
large
software
development
project
unique
every
environment
software
developed
ways
different
others
Even
managers
large
body
previous
experience
find
difficult
anticipate
problems
Furthermore
rapid
technological
changes
computers
communications
make
experience
obsolete
Lessons
learned
previous
projects
readily
transferable
new
projects
Software
processes
variable
organization
specific
engineering
process
types
system
bridges
buildings
well
understood
However
different
companies
use
quite
different
software
development
processes
cannot
reliably
predict
particular
software
process
likely
lead
development
problems
especially
true
software
project
part
wider
systems
engineering
project
completely
new
software
developed
issues
surprising
software
projects
late
overbudget
behind
schedule
Software
systems
often
new
complex
technically
innovative
Schedule
cost
overruns
common
@@@@@@@@@@
Chapter
Project
management
engineering
projects
new
transport
systems
complex
innovative
Given
difficulties
involved
perhaps
remarkable
many
software
projects
delivered
time
budget
impossible
write
standard
job
description
software
project
manager
job
varies
tremendously
depending
organization
software
developed
important
factors
affect
software
projects
managed
Company
size
Small
companies
operate
informal
management
team
communications
need
formal
policies
management
structures
less
management
overhead
larger
organizations
larger
organizations
management
hierarchies
formal
reporting
budgeting
approval
processes
followed
Software
customers
customer
internal
customer
case
software
product
development
customer
communications
informal
no
need
fit
customer
s
ways
working
custom
software
developed
external
customer
agreement
reached
formal
communication
channels
customer
government
agency
software
company
operate
according
agency
s
policies
procedures
likely
bureaucratic
Software
size
Small
systems
developed
small
team
get
together
room
discuss
progress
management
issues
Large
systems
usually
need
multiple
development
teams
geographically
distributed
different
companies
project
manager
coordinate
activities
teams
arrange
communicate
Software
type
software
developed
consumer
product
formal
records
project
management
decisions
unnecessary
hand
safety
critical
system
developed
project
management
decisions
recorded
justified
affect
safety
system
Organizational
culture
organizations
culture
based
supporting
encouraging
individuals
others
group
focused
Large
organizations
often
bureaucratic
organizations
culture
taking
risks
others
risk
averse
Software
development
processes
Agile
processes
typically
try
operate
lightweight
management
formal
processes
require
management
monitoring
ensure
development
team
following
defined
process
factors
mean
project
managers
different
organizations
work
quite
different
ways
However
number
fundamental
project
management
activities
common
organizations
Project
planning
Project
managers
responsible
planning
estimating
scheduling
project
development
assigning
people
tasks
supervise
@@@@@@@@@@
Chapter
Project
management
work
ensure
carried
required
standards
monitor
progress
check
development
time
budget
Risk
management
Project
managers
assess
risks
affect
project
monitor
risks
take
action
problems
arise
People
management
Project
managers
responsible
managing
team
people
choose
people
team
establish
ways
working
lead
effective
team
performance
Reporting
Project
managers
usually
responsible
reporting
progress
project
customers
managers
company
developing
software
able
communicate
range
levels
detailed
technical
information
management
summaries
write
concise
coherent
documents
abstract
critical
information
detailed
project
reports
able
present
information
progress
reviews
Proposal
writing
first
stage
software
project
involve
writing
proposal
win
contract
carry
item
work
proposal
describes
objectives
project
carried
usually
includes
cost
schedule
estimates
justifies
project
contract
awarded
particular
organization
team
Proposal
writing
critical
task
survival
many
software
companies
depends
enough
proposals
accepted
contracts
awarded
Project
planning
important
topic
right
discuss
Chapter
chapter
focus
risk
management
people
management
Risk
management
Risk
management
one
important
jobs
project
manager
think
risk
something
d
prefer
happen
Risks
threaten
project
software
developed
organization
Risk
management
involves
anticipating
risks
affect
project
schedule
quality
software
developed
taking
action
avoid
risks
Hall
Ould
Risks
categorized
according
type
risk
technical
organizational
etc
explain
Section
complementary
classification
classify
risks
according
risks
affect
Project
risks
affect
project
schedule
resources
example
project
risk
loss
experienced
system
architect
Finding
replacement
architect
appropriate
skills
experience
take
long
time
consequently
take
longer
develop
software
design
originally
planned
Product
risks
affect
quality
performance
software
developed
example
product
risk
failure
purchased
component
perform
@@@@@@@@@@
Risk
management
expected
affect
overall
performance
system
slower
expected
Business
risks
affect
organization
developing
procuring
software
example
competitor
introducing
new
product
business
risk
introduction
competitive
product
mean
assumptions
made
sales
existing
software
products
unduly
optimistic
course
risk
categories
overlap
experienced
engineer
s
decision
leave
project
example
presents
project
risk
software
delivery
schedule
affected
inevitably
takes
time
new
project
member
understand
work
done
cannot
immediately
productive
Consequently
delivery
system
delayed
loss
team
member
product
risk
replacement
experienced
make
programming
errors
Finally
losing
team
member
business
risk
experienced
engineer
s
reputation
critical
factor
winning
new
contracts
large
projects
record
results
risk
analysis
risk
register
along
consequence
analysis
sets
consequences
risk
project
product
business
Effective
risk
management
makes
easier
cope
problems
ensure
lead
unacceptable
budget
schedule
slippage
small
projects
formal
risk
recording
required
project
manager
aware
specific
risks
affect
project
depend
project
organizational
environment
software
developed
However
common
risks
independent
type
software
developed
occur
software
development
project
examples
common
risks
shown
Figure
Software
risk
management
important
inherent
uncertainties
software
development
uncertainties
stem
loosely
defined
requirements
requirements
changes
due
changes
customer
needs
difficulties
estimating
time
resources
required
software
development
differences
individual
skills
anticipate
risks
understand
impact
project
product
business
take
steps
avoid
risks
need
draw
contingency
plans
risks
occur
take
immediate
recovery
action
outline
process
risk
management
presented
Figure
involves
several
stages
Risk
identification
identify
possible
project
product
business
risks
Risk
analysis
assess
likelihood
consequences
risks
Risk
planning
make
plans
address
risk
avoiding
minimizing
effects
project
Risk
monitoring
regularly
assess
risk
plans
risk
mitigation
revise
plans
learn
risk
@@@@@@@@@@
Chapter
Project
management
Risk
Affects
Description
Staff
turnover
Project
Experienced
staff
leave
project
finished
Management
change
Project
change
company
management
different
priorities
Hardware
unavailability
Project
Hardware
essential
project
delivered
schedule
Requirements
change
Project
product
larger
number
changes
requirements
anticipated
Specification
delays
Project
product
Specifications
essential
interfaces
available
schedule
Size
underestimate
Project
product
size
system
underestimated
Software
tool
underperformance
Product
Software
tools
support
project
perform
anticipated
Technology
change
Business
underlying
technology
system
built
superseded
new
technology
Product
competition
Business
competitive
product
marketed
system
completed
Figure
Examples
common
project
product
business
risks
Risk
identification
Risk
analysis
Risk
planning
Risk
monitoring
List
potential
risks
Prioritized
risk
list
Risk
avoidance
contingency
plans
Risk
assessment
Figure
risk
management
process
large
projects
document
outcomes
risk
management
process
risk
management
plan
include
discussion
risks
faced
project
analysis
risks
information
plan
manage
risk
seems
likely
problem
risk
management
process
iterative
process
continues
throughout
project
drawn
initial
risk
management
plan
monitor
situation
detect
emerging
risks
information
risks
becomes
@@@@@@@@@@
Risk
management
available
re
analyze
risks
decide
risk
priority
changed
change
plans
risk
avoidance
contingency
management
Risk
management
agile
development
less
formal
fundamental
activities
still
followed
risks
discussed
formally
documented
Agile
development
reduces
risks
risks
requirements
changes
However
agile
development
downside
reliance
people
staff
turnover
significant
effects
project
product
business
lack
formal
documentation
reliance
informal
communications
hard
maintain
continuity
momentum
key
people
leave
project
Risk
identification
Risk
identification
first
stage
risk
management
process
concerned
identifying
risks
pose
major
threat
software
engineering
process
software
developed
development
organization
Risk
identification
team
process
team
gets
together
brainstorm
possible
risks
Alternatively
project
managers
identify
risks
based
experience
went
wrong
previous
projects
starting
point
risk
identification
checklist
different
types
risk
used
Six
types
risk
included
risk
checklist
Estimation
risks
arise
management
estimates
resources
required
build
system
Organizational
risks
arise
organizational
environment
software
developed
People
risks
associated
people
development
team
Requirements
risks
come
changes
customer
requirements
process
managing
requirements
change
Technology
risks
come
software
hardware
technologies
used
develop
system
Tools
risks
come
software
tools
support
software
used
develop
system
Figure
shows
examples
possible
risks
categories
finished
risk
identification
process
long
list
risks
occur
affect
product
process
business
need
prune
list
manageable
size
many
risks
practically
impossible
keep
track
@@@@@@@@@@
Chapter
Project
management
Risk
type
Possible
risks
Estimation
time
required
develop
software
underestimated
rate
defect
repair
underestimated
size
software
underestimated
Figure
Examples
different
types
risk
Organizational
People
Requirements
Technology
Tools
organization
restructured
different
management
responsible
project
Organizational
financial
problems
force
reductions
project
budget
impossible
recruit
staff
skills
required
Key
staff
ill
unavailable
critical
times
Required
training
staff
available
Changes
requirements
require
major
design
rework
proposed
Customers
fail
understand
impact
requirements
changes
database
used
system
cannot
process
many
transactions
per
second
expected
Faults
reusable
software
components
repaired
components
reused
code
generated
software
code
generation
tools
inefficient
Software
tools
cannot
work
together
integrated
way
Risk
analysis
risk
analysis
process
consider
identified
risk
make
judgment
probability
seriousness
risk
no
easy
way
rely
judgment
experience
previous
projects
problems
arose
possible
make
precise
numeric
assessment
probability
seriousness
risk
Rather
assign
risk
one
number
bands
probability
risk
assessed
insignificant
low
moderate
high
high
effects
risk
assessed
catastrophic
threaten
survival
project
serious
cause
major
delays
tolerable
delays
allowed
contingency
insignificant
tabulate
results
analysis
process
using
table
ordered
according
seriousness
risk
Figure
illustrates
risks
identified
Figure
Obviously
assessment
probability
seriousness
arbitrary
make
assessment
need
@@@@@@@@@@
Risk
management
Risk
Probability
Effects
Organizational
financial
problems
force
reductions
project
Low
Catastrophic
budget
impossible
recruit
staff
skills
required
High
Catastrophic
Key
staff
ill
critical
times
project
Moderate
Serious
Faults
reusable
software
components
repaired
components
reused
Moderate
Serious
Changes
requirements
require
major
design
rework
proposed
Moderate
Serious
organization
restructured
different
managements
responsible
project
High
Serious
database
used
system
cannot
process
many
transactions
per
second
expected
Moderate
Serious
time
required
develop
software
underestimated
High
Serious
Software
tools
cannot
integrated
High
Tolerable
Customers
fail
understand
impact
requirements
changes
Moderate
Tolerable
Required
training
staff
available
Moderate
Tolerable
rate
defect
repair
underestimated
Moderate
Tolerable
size
software
underestimated
High
Tolerable
Code
generated
code
generation
tools
inefficient
Moderate
Insignificant
Figure
Risk
types
examples
detailed
information
project
process
development
team
organization
course
probability
assessment
effects
risk
change
information
risk
becomes
available
risk
management
plans
implemented
therefore
update
table
iteration
risk
management
process
risks
analyzed
ranked
assess
risks
significant
judgment
depend
combination
probability
risk
arising
effects
risk
general
catastrophic
risks
considered
serious
risks
moderate
probability
occurrence
Boehm
Boehm
recommends
identifying
monitoring
top
risks
However
think
right
number
risks
monitor
depend
project
risks
identified
Figure
think
appropriate
consider
eight
risks
catastrophic
serious
consequences
Figure
@@@@@@@@@@
Chapter
Project
management
Risk
planning
risk
planning
process
develops
strategies
manage
key
risks
threaten
project
risk
think
actions
take
minimize
disruption
project
problem
identified
risk
occurs
think
information
need
collect
monitoring
project
emerging
problems
detected
serious
risk
planning
ask
questions
consider
individual
risks
combinations
risks
external
factors
affect
risks
example
questions
ask
several
engineers
ill
time
economic
downturn
leads
budget
cuts
project
performance
open
source
software
inadequate
expert
open
source
software
leaves
company
supplies
maintains
software
components
goes
business
customer
fails
deliver
revised
requirements
predicted
Based
answers
questions
devise
strategies
managing
risks
Figure
shows
possible
risk
management
strategies
identified
key
risks
e
serious
intolerable
shown
Figure
strategies
fall
three
categories
Avoidance
strategies
Following
strategies
means
probability
risk
arise
reduced
example
risk
avoidance
strategy
strategy
dealing
defective
components
shown
Figure
Minimization
strategies
Following
strategies
means
impact
risk
reduced
example
risk
minimization
strategy
strategy
staff
illness
shown
Figure
Contingency
plans
Following
strategies
means
prepared
worst
strategy
place
deal
example
contingency
strategy
strategy
organizational
financial
problems
shown
Figure
see
clear
analogy
strategies
used
critical
systems
ensure
reliability
security
safety
avoid
tolerate
recover
failures
Obviously
best
use
strategy
avoids
risk
possible
use
strategy
reduces
chances
risk
serious
effects
Finally
strategies
place
@@@@@@@@@@
Risk
management
Risk
Strategy
Organizational
Prepare
briefing
document
senior
management
financial
problems
showing
project
making
important
contribution
goals
business
presenting
reasons
cuts
project
budget
cost
effective
Recruitment
problems
Alert
customer
potential
difficulties
possibility
delays
investigate
buying
components
Staff
illness
Reorganize
team
overlap
work
people
therefore
understand
s
jobs
Defective
components
Replace
potentially
defective
components
bought
components
known
reliability
Requirements
changes
Derive
traceability
information
assess
requirements
change
impact
maximize
information
hiding
design
Organizational
restructuring
Prepare
briefing
document
senior
management
showing
project
making
important
contribution
goals
business
Database
performance
Investigate
possibility
buying
higher
performance
database
Underestimated
development
time
Investigate
buying
components
investigate
use
automated
code
generation
Figure
Strategies
help
manage
risk
cope
risk
arises
reduce
overall
impact
risk
project
product
Risk
monitoring
Risk
monitoring
process
checking
assumptions
product
process
business
risks
changed
regularly
assess
identified
risks
decide
risk
becoming
less
probable
think
effects
risk
changed
look
factors
number
requirements
change
requests
give
clues
risk
probability
effects
factors
obviously
dependent
types
risk
Figure
gives
examples
factors
helpful
assessing
risk
types
monitor
risks
regularly
stages
project
every
management
review
consider
discuss
key
risks
separately
decide
risk
less
likely
arise
seriousness
consequences
risk
changed
@@@@@@@@@@
Chapter
Project
management
Risk
type
Potential
indicators
Estimation
Failure
meet
agreed
schedule
failure
clear
reported
defects
Figure
Risk
indicators
Organizational
Organizational
gossip
lack
action
senior
management
People
Poor
staff
morale
poor
relationships
among
team
members
high
staff
turnover
Requirements
Many
requirements
change
requests
customer
complaints
Technology
Late
delivery
hardware
support
software
many
reported
technology
problems
Tools
Reluctance
team
members
use
tools
complaints
software
tools
requests
faster
computers
memory
Managing
people
people
working
software
organization
greatest
assets
expensive
recruit
retain
good
people
software
managers
ensure
engineers
working
project
productive
possible
successful
companies
economies
productivity
achieved
people
respected
organization
assigned
responsibilities
reflect
skills
experience
important
software
project
managers
understand
technical
issues
influence
work
software
development
Unfortunately
however
good
software
engineers
good
people
managers
Software
engineers
often
strong
technical
skills
lack
softer
skills
enable
motivate
lead
project
development
team
project
manager
aware
potential
problems
people
management
try
develop
people
management
skills
four
critical
factors
influence
relationship
manager
people
manages
Consistency
people
project
team
treated
comparable
way
No
one
expects
rewards
identical
people
feel
contribution
organization
undervalued
Respect
Different
people
different
skills
managers
respect
differences
members
team
given
opportunity
make
contribution
cases
course
find
people
simply
don
t
fit
team
cannot
continue
important
jump
conclusions
early
stage
project
@@@@@@@@@@
Managing
people
Inclusion
People
contribute
effectively
feel
others
listen
take
account
proposals
important
develop
working
environment
views
even
least
experienced
staff
considered
Honesty
manager
honest
going
well
going
badly
team
honest
level
technical
knowledge
willing
defer
staff
knowledge
necessary
try
cover
ignorance
problems
eventually
found
lose
respect
group
Practical
people
management
based
experiences
aim
section
following
section
teamwork
raise
awareness
important
issues
project
managers
deal
Motivating
people
project
manager
need
motivate
people
work
contribute
best
abilities
practice
motivation
means
organizing
work
environment
encourage
people
work
effectively
possible
people
motivated
less
interested
work
work
slowly
likely
make
mistakes
contribute
broader
goals
team
organization
provide
encouragement
understand
little
motivates
people
Maslow
Maslow
suggests
people
motivated
satisfying
needs
needs
arranged
series
levels
shown
Figure
lower
levels
hierarchy
represent
fundamental
needs
food
sleep
need
feel
secure
environment
Social
need
concerned
need
feel
part
social
grouping
Esteem
need
represents
need
feel
respected
others
self
realization
need
concerned
personal
development
People
need
satisfy
lower
level
needs
hunger
abstract
higher
level
needs
People
working
software
development
organizations
usually
hungry
thirsty
physically
threatened
environment
Therefore
making
sure
peoples
social
esteem
self
realization
needs
satisfied
important
management
point
view
satisfy
social
needs
need
give
people
time
meet
co
workers
provide
places
meet
Software
companies
Google
provide
social
space
offices
people
get
together
relatively
easy
members
development
team
work
place
increasingly
team
members
located
building
even
town
state
work
different
organizations
home
time
@@@@@@@@@@
Chapter
Project
management
Physiological
needs
Safety
needs
Social
needs
Esteem
needs
Self
realization
needs
Figure
Human
needs
hierarchy
Social
networking
systems
teleconferencing
used
remote
communications
experience
systems
effective
people
already
know
arrange
face
face
meetings
early
project
people
directly
interact
members
team
direct
interaction
people
part
social
group
accept
goals
priorities
group
satisfy
esteem
needs
need
show
people
valued
organization
Public
recognition
achievements
simple
effective
way
Obviously
people
feel
paid
level
reflects
skills
experience
Finally
satisfy
self
realization
needs
need
give
people
responsibility
work
assign
demanding
impossible
tasks
provide
opportunities
training
development
people
enhance
skills
Training
important
motivating
influence
people
like
gain
new
knowledge
learn
new
skills
Maslow
s
model
motivation
helpful
point
think
problem
takes
exclusively
personal
viewpoint
motivation
take
adequate
account
fact
people
feel
part
organization
professional
group
one
cultures
member
cohesive
group
highly
motivating
people
People
fulfilling
jobs
often
like
go
work
motivated
people
work
work
Therefore
manager
think
group
whole
motivated
discuss
teamwork
issues
Section
Figure
illustrate
problem
motivation
managers
often
face
example
competent
group
member
loses
interest
work
group
whole
quality
work
falls
becomes
unacceptable
situation
dealt
quickly
don
t
sort
problem
group
members
dissatisfied
feel
unfair
share
work
@@@@@@@@@@
Figure
Individual
motivation
Managing
people
Case
study
Motivation
Alice
software
project
manager
working
company
develops
alarm
systems
company
wishes
enter
growing
market
assistive
technology
help
elderly
disabled
people
live
independently
Alice
asked
lead
team
six
developers
develop
new
products
based
company
s
alarm
technology
Alice
s
assistive
technology
project
starts
well
Good
working
relationships
develop
team
creative
new
ideas
developed
team
decides
develop
system
user
initiate
control
alarm
system
cell
phone
tablet
computer
However
months
project
Alice
notices
Dorothy
hardware
expert
starts
coming
work
late
quality
work
deteriorating
increasingly
appear
communicating
members
team
Alice
talks
problem
informally
team
members
try
find
Dorothy
s
personal
circumstances
changed
affecting
work
don
t
know
anything
Alice
decides
talk
Dorothy
try
understand
problem
initial
denials
problem
Dorothy
admits
lost
interest
job
expected
able
develop
use
hardware
interfacing
skills
However
product
direction
chosen
little
opportunity
use
skills
Basically
working
C
programmer
alarm
system
software
admits
work
challenging
concerned
developing
interfacing
skills
worried
finding
job
involves
hardware
interfacing
difficult
project
want
upset
team
revealing
thinking
next
project
decided
best
minimize
conversation
example
Alice
tries
find
Dorothy
s
personal
circumstances
problem
Personal
difficulties
commonly
affect
motivation
people
cannot
therefore
concentrate
work
give
time
support
resolve
issues
make
clear
still
responsibility
employer
Dorothy
s
motivation
problem
one
arise
projects
develop
unexpected
direction
People
expect
one
type
work
end
something
completely
different
circumstances
decide
team
member
leave
team
find
opportunities
elsewhere
example
however
Alice
decides
try
convince
Dorothy
broadening
experience
positive
career
step
gives
Dorothy
design
autonomy
organizes
training
courses
software
engineering
give
opportunities
current
project
finished
Psychological
personality
type
influences
motivation
Bass
Dunteman
Bass
Dunteman
identified
three
classifications
professional
workers
Task
oriented
people
motivated
work
software
engineering
people
motivated
intellectual
challenge
software
development
@@@@@@@@@@
Chapter
Project
management
People
Capability
Maturity
Model
People
Capability
Maturity
Model
P
CMM
framework
assessing
well
organizations
manage
development
staff
highlights
best
practice
people
management
provides
basis
organizations
improve
people
management
processes
best
suited
large
rather
small
informal
companies
http
software
engineering
book
com
web
people
cmm
Self
oriented
people
principally
motivated
personal
success
recognition
interested
software
development
means
achieving
goals
often
longer
term
goals
career
progression
motivate
wish
successful
work
help
realize
goals
Interaction
oriented
people
motivated
presence
actions
co
workers
attention
paid
user
interface
design
interaction
oriented
individuals
becoming
involved
software
engineering
Research
shown
interaction
oriented
personalities
usually
like
work
part
group
task
oriented
self
oriented
people
usually
prefer
act
individuals
Women
likely
interaction
oriented
men
often
effective
communicators
discuss
mix
different
personality
types
groups
case
study
shown
later
Figure
individual
s
motivation
made
elements
class
one
type
motivation
usually
dominant
one
time
However
individuals
change
example
technical
people
feel
properly
rewarded
self
oriented
put
personal
interests
technical
concerns
group
works
particularly
well
self
oriented
people
interaction
oriented
Teamwork
professional
software
developed
project
teams
range
size
two
several
hundred
people
However
impossible
everyone
large
group
work
together
single
problem
large
teams
usually
split
number
smaller
groups
group
responsible
developing
part
overall
system
best
size
software
engineering
group
members
never
members
groups
small
communication
problems
reduced
Everyone
knows
everyone
whole
group
get
around
table
meeting
discuss
project
software
developing
@@@@@@@@@@
Teamwork
Putting
together
group
right
balance
technical
skills
experience
personalities
critical
management
task
However
successful
groups
simply
collection
individuals
right
balance
skills
good
group
cohesive
thinks
strong
single
unit
people
involved
motivated
success
group
well
personal
goals
cohesive
group
members
think
group
important
individuals
group
members
Members
well
led
cohesive
group
loyal
group
identify
group
goals
group
members
attempt
protect
group
entity
outside
interference
makes
group
robust
able
cope
problems
unexpected
situations
benefits
creating
cohesive
group
group
establish
quality
standards
standards
established
consensus
likely
observed
external
standards
imposed
group
Individuals
learn
support
Group
members
learn
working
together
Inhibitions
caused
ignorance
minimized
mutual
learning
encouraged
Knowledge
shared
Continuity
maintained
group
member
leaves
Others
group
take
critical
tasks
ensure
project
unduly
disrupted
Refactoring
continual
improvement
encouraged
Group
members
work
collectively
deliver
high
quality
results
fix
problems
irrespective
individuals
originally
created
design
program
Good
project
managers
try
encourage
group
cohesiveness
try
establish
sense
group
identity
naming
group
establishing
group
identity
territory
managers
like
explicit
group
building
activities
sports
games
popular
group
members
Social
events
group
members
families
good
way
bring
people
together
One
effective
ways
promoting
cohesion
inclusive
treat
group
members
responsible
trustworthy
make
information
freely
available
Sometimes
managers
feel
cannot
reveal
certain
information
everyone
group
invariably
creates
climate
mistrust
effective
way
making
people
feel
valued
part
group
make
sure
know
going
see
example
case
study
Figure
Alice
arranges
regular
informal
meetings
tells
group
members
going
makes
point
involving
people
product
development
asking
come
new
ideas
derived
family
experiences
away
@@@@@@@@@@
Chapter
Project
management
Figure
Group
cohesion
Case
study
Team
spirit
Alice
experienced
project
manager
understands
importance
creating
cohesive
group
company
developing
new
product
takes
opportunity
involve
group
members
product
specification
design
getting
discuss
possible
technology
elderly
members
families
encourages
bring
family
members
meet
members
development
group
Alice
arranges
monthly
lunches
everyone
group
lunches
opportunity
team
members
meet
informally
talk
around
issues
concern
get
know
lunch
Alice
tells
group
knows
organizational
news
policies
strategies
forth
team
member
briefly
summarizes
group
discusses
general
topic
new
product
ideas
elderly
relatives
Every
months
Alice
organizes
away
day
group
team
spends
two
days
technology
updating
team
member
prepares
update
relevant
technology
presents
group
offsite
meeting
plenty
time
scheduled
discussion
social
interaction
days
good
ways
promoting
cohesion
People
relax
together
help
learn
new
technologies
group
effective
depends
extent
nature
project
organization
work
organization
state
turmoil
constant
reorganizations
job
insecurity
difficult
team
members
focus
software
development
Similarly
project
keeps
changing
danger
cancellation
people
lose
interest
Given
stable
organizational
project
environment
three
factors
biggest
effect
team
working
people
group
need
mix
people
project
group
software
development
involves
diverse
activities
negotiating
clients
programming
testing
documentation
way
group
organized
group
organized
individuals
contribute
best
abilities
tasks
completed
expected
Technical
managerial
communications
Good
communication
group
members
software
engineering
team
project
stakeholders
essential
management
issues
getting
right
team
cannot
guarantee
project
success
many
things
go
wrong
including
changes
business
business
environment
However
don
t
pay
attention
group
composition
organization
communications
increase
likelihood
project
run
difficulties
@@@@@@@@@@
Teamwork
Selecting
group
members
manager
team
leader
s
job
create
cohesive
group
organize
group
work
together
effectively
task
involves
selecting
group
right
balance
technical
skills
personalities
Sometimes
people
hired
outside
organization
often
software
engineering
groups
put
together
current
employees
experience
projects
Managers
rarely
completely
free
hand
team
selection
often
use
people
available
company
even
ideal
people
job
Many
software
engineers
motivated
primarily
work
Software
development
groups
therefore
often
composed
people
ideas
technical
problems
solved
want
best
job
possible
deliberately
redesign
systems
think
improved
add
extra
system
features
system
requirements
Agile
methods
encourage
engineers
take
initiative
improve
software
However
sometimes
means
time
spent
things
aren
t
really
needed
different
engineers
compete
rewrite
s
code
Technical
knowledge
ability
factor
used
select
group
members
competing
engineers
problem
reduced
people
group
complementary
motivations
People
motivated
work
likely
strongest
technically
People
self
oriented
probably
best
pushing
work
forward
finish
job
People
interaction
oriented
help
facilitate
communications
group
think
particularly
important
interaction
oriented
people
group
like
talk
people
detect
tensions
disagreements
early
stage
problems
serious
impact
group
case
study
Figure
suggested
Alice
project
manager
tried
create
group
complementary
personalities
particular
group
good
mix
interaction
task
oriented
people
already
discussed
Figure
Dorothy
s
self
oriented
personality
caused
problems
work
expected
Fred
s
part
time
role
group
domain
expert
problem
mostly
interested
technical
challenges
interact
well
group
members
fact
part
team
means
fully
relate
team
s
goals
sometimes
impossible
choose
group
complementary
personalities
case
project
manager
control
group
individual
goals
take
precedence
organizational
group
objectives
control
easier
achieve
group
members
participate
stage
project
Individual
initiative
likely
develop
group
members
given
instructions
without
aware
part
task
plays
overall
project
example
say
software
engineer
takes
development
system
notices
possible
improvements
made
design
implements
improvements
without
understanding
rationale
original
design
changes
though
well
intentioned
adverse
implications
@@@@@@@@@@
Chapter
Project
management
Case
study
Group
composition
creating
group
assistive
technology
development
Alice
aware
importance
selecting
members
complementary
personalities
interviewing
potential
group
members
tried
assess
task
oriented
self
oriented
interaction
oriented
felt
primarily
self
oriented
type
considered
project
way
getting
noticed
senior
management
possibly
promoted
therefore
looked
one
perhaps
two
interaction
oriented
personalities
task
oriented
individuals
complete
team
final
assessment
arrived
Alice
self
oriented
Brian
task
oriented
Chun
interaction
oriented
Dorothy
self
oriented
Ed
interaction
oriented
Fiona
task
oriented
Fred
task
oriented
Hassan
interaction
oriented
Figure
Group
composition
parts
system
members
group
involved
design
start
likely
understand
design
decisions
made
identify
decisions
rather
oppose
Group
organization
way
group
organized
affects
group
s
decisions
ways
information
exchanged
interactions
development
group
external
project
stakeholders
Important
organizational
questions
project
managers
include
following
project
manager
technical
leader
group
technical
leader
system
architect
responsible
critical
technical
decisions
made
software
development
Sometimes
project
manager
skill
experience
take
role
However
large
projects
best
separate
technical
managerial
roles
project
manager
appoint
senior
engineer
project
architect
take
responsibility
technical
leadership
involved
making
critical
technical
decisions
decisions
made
decisions
made
system
architect
project
manager
reaching
consensus
among
wider
range
team
members
interactions
external
stakeholders
senior
company
management
handled
many
cases
project
manager
responsible
interactions
assisted
system
architect
one
However
alternative
organizational
model
create
dedicated
role
concerned
external
liaison
appoint
someone
appropriate
interaction
skills
role
@@@@@@@@@@
Teamwork
Hiring
right
people
Project
managers
often
responsible
selecting
people
organization
join
software
engineering
team
Getting
best
possible
people
process
important
poor
selection
decisions
serious
risk
project
Key
factors
influence
selection
staff
education
training
application
domain
technology
experience
communication
ability
adaptability
problem
solving
ability
http
software
engineering
book
com
web
people
selection
groups
integrate
people
co
located
now
common
groups
include
members
different
organizations
people
work
home
well
shared
office
change
considered
group
decision
making
processes
knowledge
shared
across
group
Group
organization
affects
information
sharing
certain
methods
organization
better
sharing
others
However
avoid
much
information
sharing
people
overloaded
excessive
information
distracts
work
Small
programming
groups
usually
organized
informal
way
group
leader
gets
involved
software
development
group
members
informal
group
group
whole
discusses
work
carried
tasks
allocated
according
ability
experience
senior
group
members
responsible
architectural
design
However
detailed
design
implementation
responsibility
team
member
allocated
particular
task
Agile
development
teams
informal
groups
Agile
enthusiasts
claim
formal
structure
inhibits
information
exchange
Many
decisions
usually
seen
management
decisions
decisions
schedule
devolved
group
members
However
still
needs
project
manager
responsible
strategic
decision
making
communications
outside
group
Informal
groups
successful
particularly
group
members
experienced
competent
group
makes
decisions
consensus
improves
cohesiveness
performance
However
group
composed
mostly
inexperienced
incompetent
members
informality
hindrance
no
experienced
engineers
direct
work
result
lack
coordination
group
members
possibly
eventual
project
failure
hierarchical
groups
group
leader
top
hierarchy
formal
authority
group
members
direct
work
clear
organizational
structure
decisions
made
toward
top
hierarchy
implemented
people
lower
Communications
primarily
instructions
senior
staff
people
lower
levels
hierarchy
relatively
little
communication
managers
upper
levels
@@@@@@@@@@
Chapter
Project
management
Hierarchical
groups
work
well
well
understood
problem
easily
broken
software
components
developed
different
parts
hierarchy
grouping
allows
rapid
decision
making
military
organizations
follow
model
However
rarely
works
well
complex
software
engineering
software
development
effective
team
communications
levels
essential
Changes
software
often
require
changes
several
parts
system
requires
discussion
negotiation
levels
hierarchy
Software
technologies
change
fast
junior
staff
know
new
technologies
experienced
staff
Top
communications
mean
project
manager
find
opportunities
using
new
technologies
junior
staff
frustrated
see
old
fashioned
technologies
used
development
major
challenge
facing
project
managers
difference
technical
ability
group
members
best
programmers
times
productive
worst
programmers
makes
sense
use
super
programmers
effective
way
provide
much
support
possible
time
focusing
super
programmers
demotivating
group
members
resentful
given
responsibility
concerned
affect
career
development
Furthermore
superprogrammer
leaves
company
impact
project
huge
Therefore
adopting
group
model
based
individual
experts
pose
significant
risks
Group
communications
absolutely
essential
group
members
communicate
effectively
efficiently
project
stakeholders
Group
members
exchange
information
status
work
design
decisions
made
changes
previous
design
decisions
resolve
problems
arise
stakeholders
inform
stakeholders
changes
system
group
delivery
plans
Good
communication
helps
strengthen
group
cohesiveness
Group
members
come
understand
motivations
strengths
weaknesses
people
group
effectiveness
efficiency
communications
influenced
Group
size
group
gets
bigger
gets
harder
members
communicate
effectively
number
one
way
communication
links
n
n
n
group
size
group
eight
members
possible
communication
pathways
means
quite
possible
people
rarely
communicate
Status
differences
group
members
mean
communications
often
one
way
Managers
experienced
engineers
tend
dominate
communications
less
experienced
staff
reluctant
start
conversation
make
critical
remarks
@@@@@@@@@@
Teamwork
physical
work
environment
Group
communications
individual
productivity
affected
team
s
working
environment
Individual
workspaces
better
concentration
detailed
technical
work
people
less
likely
distracted
interruptions
However
shared
workspaces
better
communications
well
designed
work
environment
takes
needs
account
http
software
engineering
book
com
web
workspace
Group
structure
People
informally
structured
groups
communicate
effectively
people
groups
formal
hierarchical
structure
hierarchical
groups
communications
tend
flow
hierarchy
People
level
talk
particular
problem
large
project
several
development
groups
people
working
different
subsystems
communicate
managers
likely
delays
misunderstandings
Group
composition
People
personality
types
discussed
Section
clash
result
communications
inhibited
Communication
usually
better
mixed
sex
groups
single
sex
groups
Marshall
Heslin
Women
often
interaction
oriented
men
act
interaction
controllers
facilitators
group
physical
work
environment
organization
workplace
major
factor
facilitating
inhibiting
communications
companies
use
standard
open
plan
offices
staff
others
invest
providing
workspace
includes
mixture
private
group
working
areas
allows
collaborative
activities
individual
development
require
high
level
concentration
available
communication
channels
many
different
forms
communication
face
face
email
messages
formal
documents
telephone
technologies
social
networking
wikis
project
teams
increasingly
distributed
team
members
working
remotely
need
make
use
interaction
technologies
conferencing
systems
facilitate
group
communications
Project
managers
usually
work
tight
deadlines
consequently
often
try
use
communication
channels
don
t
take
much
time
rely
meetings
formal
documents
pass
information
project
staff
stakeholders
send
long
emails
project
staff
Unfortunately
efficient
approach
communication
project
manager
s
perspective
usually
effective
often
good
reasons
people
t
attend
meetings
don
t
hear
presentation
People
time
read
long
documents
emails
directly
relevant
work
several
versions
document
produced
readers
find
difficult
keep
track
changes
@@@@@@@@@@
Chapter
Project
management
Effective
communication
achieved
communications
two
way
people
involved
discuss
issues
information
establish
common
understanding
proposals
problems
done
meetings
meetings
often
dominated
powerful
personalities
Informal
discussions
manager
meets
team
coffee
sometimes
effective
project
teams
include
remote
members
makes
meetings
difficult
involve
communications
make
use
wikis
blogs
support
information
exchange
Wikis
support
collaborative
creation
editing
documents
blogs
support
threaded
discussions
questions
comments
made
group
members
Wikis
blogs
allow
project
members
external
stakeholders
exchange
information
irrespective
location
help
manage
information
keep
track
discussion
threads
often
confusing
conducted
email
use
instant
messaging
teleconferences
easily
arranged
resolve
issues
need
discussion
Key
Points
Good
software
project
management
essential
software
engineering
projects
developed
schedule
budget
Software
management
distinct
engineering
management
Software
intangible
Projects
novel
innovative
no
body
experience
guide
management
Software
processes
mature
traditional
engineering
processes
Risk
management
involves
identifying
assessing
major
project
risks
establish
probability
occur
consequences
project
risk
arise
make
plans
avoid
manage
deal
likely
risks
arise
People
management
involves
choosing
right
people
work
project
organizing
team
working
environment
productive
possible
People
motivated
interaction
people
recognition
management
peers
given
opportunities
personal
development
Software
development
groups
fairly
small
cohesive
key
factors
influence
effectiveness
group
people
group
way
organized
communication
group
members
Communications
group
influenced
factors
status
group
members
size
group
gender
composition
group
personalities
available
communication
channels
@@@@@@@@@@
Chapter
Exercises
Reading
Mythical
Man
Month
Essays
Software
Engineering
Anniversary
Edition
problems
software
management
remained
largely
unchanged
since
s
one
best
books
topic
presents
interesting
readable
account
management
one
first
large
software
projects
IBM
OS
operating
system
anniversary
edition
published
years
original
edition
includes
classic
papers
Brooks
F
P
Brooks
Addison
Wesley
Peopleware
Productive
Projects
Teams
nd
ed
now
classic
book
focuses
importance
treating
people
properly
managing
software
projects
one
books
recognizes
place
people
work
influences
communications
productivity
Strongly
recommended
T
DeMarco
T
Lister
Dorset
House
Waltzing
Bears
Managing
Risk
Software
Projects
practical
easy
read
introduction
risks
risk
management
T
DeMarco
T
Lister
Dorset
House
Effective
Project
Management
Traditional
Agile
Extreme
th
ed
textbook
project
management
general
rather
software
project
management
based
called
PMBOK
Project
Management
Body
Knowledge
unlike
books
topic
discusses
PM
techniques
agile
projects
R
K
Wysocki
WebsiTe
PowerPoint
slides
chapter
www
pearsonglobaleditions
com
Sommerville
Links
supporting
videos
http
software
engineering
book
com
videos
software
management
exeRCises
Explain
intangibility
software
systems
poses
special
problems
software
project
management
Explain
company
size
software
size
factors
affect
software
project
management
Using
reported
instances
project
problems
literature
list
management
difficulties
errors
occurred
failed
programming
projects
suggest
start
Mythical
Man
Month
suggested
Reading
addition
risks
shown
Figure
identify
least
six
possible
risks
arise
software
projects
risk
monitoring
risks
monitored
List
examples
types
risks
potential
indicators
@@@@@@@@@@
Chapter
Project
management
Fixed
price
contracts
contractor
bids
fixed
price
complete
system
development
used
move
project
risk
client
contractor
anything
goes
wrong
contractor
pay
Suggest
use
contracts
increase
likelihood
product
risks
arise
Explain
keeping
members
group
informed
progress
technical
decisions
project
improve
group
cohesiveness
qualities
cohesive
group
s
members
make
group
robust
List
key
benefits
creating
cohesive
group
Write
case
study
style
used
illustrate
importance
communications
project
team
Assume
team
members
work
remotely
possible
get
whole
team
together
short
notice
manager
asks
deliver
software
schedule
know
met
asking
project
team
work
unpaid
overtime
team
members
young
children
Discuss
accept
demand
manager
persuade
team
give
time
organization
rather
families
factors
significant
decision
ReFeRenCes
Bass
B
M
G
Dunteman
Behaviour
Groups
Function
Self
Interaction
Task
Orientation
J
Abnorm
Soc
Psychology
doi
h
Boehm
B
W
Spiral
Model
Software
Development
Enhancement
IEEE
Computer
doi
Hall
E
Managing
Risk
Methods
Software
Systems
Development
Reading
MA
Addison
Wesley
Marshall
J
E
R
Heslin
Boys
Girls
Together
Sexual
Composition
Effect
Density
Group
Size
Cohesiveness
J
Personality
Social
Psychology
doi
h
Maslow
Motivation
Personality
New
York
Harper
Row
Ould
M
Managing
Software
Quality
Business
Risk
Chichester
UK
John
Wiley
Sons
@@@@@@@@@@
Project
planning
Objectives
objective
chapter
introduce
project
planning
scheduling
cost
estimation
read
chapter
understand
fundamentals
software
costing
factors
affect
price
software
system
developed
external
clients
know
sections
included
project
plan
created
plan
driven
development
process
understand
involved
project
scheduling
use
bar
charts
present
project
schedule
introduced
agile
project
planning
based
planning
game
understand
cost
estimation
techniques
COCOMO
II
model
used
software
cost
estimation
Contents
Software
pricing
Plan
driven
development
Project
scheduling
Agile
planning
Estimation
techniques
COCOMO
cost
modeling
@@@@@@@@@@
Chapter
Project
planning
Project
planning
one
important
jobs
software
project
manager
manager
break
work
parts
assign
project
team
members
anticipate
problems
arise
prepare
tentative
solutions
problems
project
plan
created
start
project
updated
project
progresses
used
show
work
done
assess
progress
project
Project
planning
takes
place
three
stages
project
life
cycle
proposal
stage
bidding
contract
develop
provide
software
system
need
plan
stage
help
decide
resources
complete
work
work
price
quote
customer
project
startup
phase
plan
work
project
project
broken
increments
resources
allocated
across
company
information
proposal
stage
therefore
refine
initial
effort
estimates
prepared
Periodically
throughout
project
update
plan
reflect
new
information
software
development
learn
system
implemented
capabilities
development
team
software
requirements
change
work
breakdown
altered
schedule
extended
information
allows
make
accurate
estimates
long
work
take
Planning
proposal
stage
inevitably
speculative
complete
set
requirements
software
developed
respond
call
proposals
based
high
level
description
software
functionality
required
plan
often
required
part
proposal
produce
credible
plan
carrying
work
win
contract
re
plan
project
taking
account
changes
since
proposal
made
new
information
system
development
process
development
team
bidding
contract
work
price
propose
customer
developing
software
starting
point
calculating
price
need
draw
estimate
costs
completing
project
work
Estimation
involves
working
much
effort
required
complete
activity
step
calculating
total
cost
activities
calculate
software
costs
objectively
aim
accurately
predicting
cost
developing
software
reasonable
estimate
likely
costs
position
calculate
price
quote
customer
discuss
next
section
many
factors
influence
pricing
software
project
simply
cost
plus
profit
@@@@@@@@@@
Chapter
Project
planning
Overhead
costs
estimate
costs
effort
software
project
don
t
simply
multiply
salaries
people
involved
time
spent
project
take
account
organizational
overheads
office
space
administration
etc
covered
income
project
calculate
costs
computing
overheads
adding
proportion
costs
engineer
working
project
http
software
engineering
book
com
web
overhead
costs
use
three
main
parameters
computing
costs
software
development
project
effort
costs
costs
paying
software
engineers
managers
hardware
software
costs
including
hardware
maintenance
software
support
travel
training
costs
projects
biggest
cost
effort
cost
estimate
total
effort
person
months
likely
required
complete
work
project
Obviously
limited
information
make
estimate
therefore
make
best
possible
estimate
add
contingency
extra
time
effort
case
initial
estimate
optimistic
commercial
systems
normally
use
commodity
hardware
relatively
cheap
However
software
costs
significant
license
middleware
platform
software
Extensive
travel
needed
project
developed
different
sites
travel
costs
usually
small
fraction
effort
costs
time
spent
traveling
often
wasted
adds
significantly
effort
costs
project
use
electronic
meeting
systems
collaborative
software
reduce
travel
time
available
productive
work
contract
develop
system
awarded
outline
project
plan
project
refined
create
project
startup
plan
stage
know
requirements
system
aim
create
project
plan
enough
detail
help
make
decisions
project
staffing
budgeting
use
plan
basis
allocating
resources
project
organization
help
decide
need
hire
new
staff
plan
define
project
monitoring
mechanisms
keep
track
progress
project
compare
actual
planned
progress
costs
companies
formal
procedures
monitoring
good
manager
able
form
clear
picture
going
informal
discussions
project
staff
Informal
monitoring
predict
potential
project
problems
revealing
difficulties
occur
example
daily
discussions
project
@@@@@@@@@@
Chapter
Project
planning
staff
reveal
team
problems
software
fault
communications
systems
project
manager
immediately
assign
communications
expert
problem
help
find
solve
problem
project
plan
evolves
development
process
requirements
changes
technology
issues
development
problems
Development
planning
intended
ensure
project
plan
remains
useful
document
staff
understand
achieved
delivered
Therefore
schedule
cost
estimate
risks
revised
software
developed
agile
method
used
still
need
project
startup
plan
regardless
approach
used
company
still
needs
plan
resources
allocated
project
However
detailed
plan
need
include
essential
information
work
breakdown
project
schedule
development
informal
project
plan
effort
estimates
drawn
release
software
whole
team
involved
planning
process
aspects
agile
planning
already
covered
Chapter
discuss
approaches
Section
Software
pricing
principle
price
software
system
developed
customer
simply
cost
development
plus
profit
developer
practice
however
relationship
project
cost
price
quoted
customer
usually
simple
calculating
price
take
broader
organizational
economic
political
business
considerations
account
Figure
need
think
organizational
concerns
risks
associated
project
type
contract
used
issues
cause
price
adjusted
upward
downward
illustrate
project
pricing
issues
consider
following
scenario
small
software
company
PharmaSoft
employs
software
engineers
finished
large
project
contracts
place
require
five
development
staff
However
bidding
large
contract
major
pharmaceutical
company
requires
person
years
effort
two
years
project
start
least
months
granted
transform
finances
company
PharmaSoft
gets
opportunity
bid
project
requires
six
people
completed
months
costs
including
overheads
project
estimated
million
However
improve
competitive
position
PharmaSoft
decides
bid
price
customer
million
means
loses
money
contract
retain
specialist
staff
profitable
future
projects
likely
come
stream
year
s
time
@@@@@@@@@@
Software
pricing
Factor
Description
Contractual
terms
customer
willing
allow
developer
retain
ownership
source
code
reuse
projects
price
charged
reduced
reflect
value
source
code
developer
Cost
estimate
uncertainty
organization
unsure
cost
estimate
increase
price
contingency
normal
profit
Financial
health
Companies
financial
problems
lower
price
gain
contract
better
make
smaller
normal
profit
break
even
go
business
Cash
flow
important
profit
difficult
economic
times
Market
opportunity
development
organization
quote
low
price
wishes
move
new
segment
software
market
Accepting
low
profit
one
project
give
organization
opportunity
make
greater
profit
later
experience
gained
help
develop
new
products
Requirements
volatility
requirements
likely
change
organization
lower
price
win
contract
contract
awarded
high
prices
charged
changes
requirements
Figure
Factors
affecting
software
pricing
example
approach
software
pricing
called
pricing
win
Pricing
win
means
company
idea
price
customer
expects
pay
makes
bid
contract
based
customer
s
expected
price
seem
unethical
unbusinesslike
advantages
customer
system
provider
project
cost
agreed
basis
outline
proposal
Negotiations
take
place
client
customer
establish
detailed
project
specification
specification
constrained
agreed
cost
buyer
seller
agree
acceptable
system
functionality
fixed
factor
many
projects
project
requirements
cost
requirements
changed
project
costs
remain
budget
example
say
company
OilSoft
bidding
contract
develop
fuel
delivery
system
oil
company
schedules
deliveries
fuel
service
stations
no
detailed
requirements
document
system
OilSoft
estimates
price
likely
competitive
oil
company
s
budget
granted
contract
OilSoft
negotiates
detailed
requirements
system
basic
functionality
delivered
estimates
additional
costs
requirements
approach
advantages
software
developer
customer
requirements
negotiated
avoid
requirements
difficult
implement
potentially
expensive
Flexible
requirements
make
easier
reuse
software
oil
company
awarded
contract
known
company
trust
Furthermore
possible
spread
cost
@@@@@@@@@@
Chapter
Project
planning
project
several
versions
system
reduce
costs
system
deployment
allow
client
budget
project
cost
several
financial
years
Plan
driven
development
Plan
driven
plan
based
development
approach
software
engineering
development
process
planned
detail
project
plan
created
records
work
done
development
schedule
work
products
Managers
use
plan
support
project
decision
making
way
measuring
progress
Plan
driven
development
based
engineering
project
management
techniques
thought
traditional
way
managing
large
software
development
projects
Agile
development
involves
different
planning
process
discussed
Section
decisions
delayed
problem
plan
driven
development
early
decisions
revised
changes
environments
software
developed
used
Delaying
planning
decisions
avoids
unnecessary
rework
However
arguments
favor
plan
driven
approach
early
planning
allows
organizational
issues
availability
staff
projects
etc
taken
account
Potential
problems
dependencies
discovered
project
starts
rather
project
underway
view
best
approach
project
planning
involves
sensible
mixture
plan
based
agile
development
balance
depends
type
project
skills
people
available
one
extreme
large
security
safety
critical
systems
require
extensive
front
analysis
certified
put
use
systems
mostly
plan
driven
extreme
small
medium
size
information
systems
used
rapidly
changing
competitive
environment
mostly
agile
several
companies
involved
development
project
plan
driven
approach
normally
used
coordinate
work
across
development
site
Project
plans
plan
driven
development
project
project
plan
sets
resources
available
project
work
breakdown
schedule
carrying
work
plan
identify
approach
taken
risk
management
well
risks
project
software
development
details
project
plans
vary
depending
type
project
organization
plans
normally
include
following
sections
Introduction
Briefly
describes
objectives
project
sets
constraints
e
g
budget
time
affect
management
project
Project
organization
Describes
way
development
team
organized
people
involved
roles
team
@@@@@@@@@@
Plan
driven
development
Plan
Description
Configuration
management
plan
Describes
configuration
management
procedures
structures
used
Describes
software
associated
hardware
required
deployed
customer
s
environment
include
plan
migrating
data
existing
systems
Figure
Project
plan
supplements
Risk
analysis
Describes
possible
project
risks
likelihood
risks
arising
risk
reduction
strategies
discussed
Chapter
proposed
Deployment
plan
Maintenance
plan
Predicts
maintenance
requirements
costs
effort
Quality
plan
Describes
quality
procedures
standards
used
project
Validation
plan
Describes
approach
resources
schedule
used
system
validation
Hardware
software
resource
requirements
Specifies
hardware
support
software
required
carry
development
hardware
purchased
estimates
prices
delivery
schedule
included
Work
breakdown
Sets
breakdown
project
activities
identifies
inputs
outputs
project
activity
Project
schedule
Shows
dependencies
activities
estimated
time
required
reach
milestone
allocation
people
activities
ways
schedule
presented
discussed
next
section
chapter
Monitoring
reporting
mechanisms
Defines
management
reports
produced
produced
project
monitoring
mechanisms
used
main
project
plan
include
project
risk
assessment
schedule
project
addition
develop
number
supplementary
plans
activities
testing
configuration
management
Figure
shows
supplementary
plans
developed
usually
needed
large
projects
developing
large
complex
systems
planning
process
Project
planning
iterative
process
starts
create
initial
project
plan
project
startup
phase
Figure
UML
activity
diagram
shows
typical
workflow
project
planning
process
Plan
changes
inevitable
information
system
project
team
becomes
available
@@@@@@@@@@
Chapter
Project
planning
system
Project
planner
project
unfinished
finished
work
Monitor
progress
plan
no
problems
minor
problems
slippages
serious
problems
Initiate
risk
mitigation
actions
Identify
risks
Identify
constraints
Define
milestones
deliverables
Define
project
schedule
Replan
project
Figure
project
planning
process
project
regularly
revise
plan
reflect
requirements
schedule
risk
changes
Changing
business
goals
leads
changes
project
plans
business
goals
change
affect
projects
re
planned
beginning
planning
process
assess
constraints
affecting
project
constraints
required
delivery
date
staff
available
overall
budget
available
tools
conjunction
assessment
identify
project
milestones
deliverables
Milestones
points
schedule
assess
progress
example
handover
system
testing
Deliverables
work
products
delivered
customer
example
requirements
document
system
process
enters
loop
terminates
project
complete
draw
estimated
schedule
project
activities
defined
schedule
initiated
approved
continue
time
usually
two
three
weeks
review
progress
note
discrepancies
planned
schedule
initial
estimates
project
parameters
inevitably
approximate
minor
slippages
normal
make
modifications
original
plan
make
realistic
rather
optimistic
assumptions
defining
project
plan
Problems
description
arise
project
lead
project
delays
initial
assumptions
scheduling
therefore
pessimistic
take
unexpected
problems
account
include
contingency
plan
things
go
wrong
delivery
schedule
seriously
disrupted
serious
problems
development
work
likely
lead
significant
delays
need
initiate
risk
mitigation
actions
reduce
risks
project
failure
conjunction
actions
re
plan
project
involve
renegotiating
project
constraints
deliverables
customer
new
schedule
work
completed
established
agreed
customer
@@@@@@@@@@
Project
scheduling
renegotiation
unsuccessful
risk
mitigation
actions
ineffective
arrange
formal
project
technical
review
objectives
review
find
alternative
approach
allow
project
continue
Reviews
check
customer
s
goals
unchanged
project
remains
aligned
goals
outcome
review
decision
cancel
project
result
technical
managerial
failings
often
consequence
external
changes
affect
project
development
time
large
software
project
often
several
years
time
business
objectives
priorities
inevitably
change
changes
mean
software
no
longer
required
original
project
requirements
inappropriate
Management
decide
stop
software
development
make
major
changes
project
reflect
changes
organizational
objectives
Project
scheduling
Project
scheduling
process
deciding
work
project
organized
separate
tasks
tasks
executed
estimate
calendar
time
needed
complete
task
effort
required
suggest
work
tasks
identified
estimate
hardware
software
resources
needed
complete
task
example
developing
embedded
system
estimate
time
need
specialized
hardware
costs
running
system
simulator
terms
planning
stages
introduced
introduction
chapter
initial
project
schedule
usually
created
project
startup
phase
schedule
refined
modified
development
planning
plan
based
agile
processes
need
initial
project
schedule
less
detail
included
agile
project
plan
initial
schedule
used
plan
people
allocated
projects
check
progress
project
contractual
commitments
traditional
development
processes
complete
schedule
initially
developed
modified
project
progresses
agile
processes
overall
schedule
identifies
major
phases
project
completed
iterative
approach
scheduling
used
plan
phase
Scheduling
plan
driven
projects
Figure
involves
breaking
total
work
involved
project
separate
tasks
estimating
time
required
complete
task
Tasks
normally
last
least
week
no
longer
months
Finer
subdivision
means
disproportionate
amount
time
spent
re
planning
updating
project
plan
maximum
amount
time
task
weeks
task
take
longer
split
subtasks
project
planning
scheduling
tasks
carried
parallel
different
people
working
different
components
system
coordinate
parallel
tasks
organize
work
workforce
used
optimally
don
t
introduce
@@@@@@@@@@
Chapter
Project
planning
Estimate
resources
activities
Identify
activity
dependencies
Identify
activities
Allocate
people
activities
Software
requirements
design
information
Bar
charts
describing
project
schedule
Create
project
charts
Figure
project
scheduling
process
unnecessary
dependencies
tasks
important
avoid
situation
whole
project
delayed
critical
task
unfinished
project
technically
advanced
initial
estimates
certainly
optimistic
even
try
consider
eventualities
respect
software
scheduling
no
different
scheduling
type
large
advanced
project
New
aircraft
bridges
even
new
models
cars
frequently
late
unanticipated
problems
Schedules
therefore
continually
updated
better
progress
information
becomes
available
project
scheduled
similar
previous
project
previous
estimates
reused
However
projects
use
different
design
methods
implementation
languages
experience
previous
projects
applicable
planning
new
project
estimating
schedules
take
account
possibility
things
go
wrong
People
working
project
fall
ill
leave
hardware
fail
essential
support
software
hardware
delivered
late
project
new
technically
advanced
parts
turn
difficult
take
longer
originally
anticipated
good
rule
thumb
estimate
nothing
go
wrong
increase
estimate
cover
anticipated
problems
contingency
factor
cover
unanticipated
problems
added
estimate
extra
contingency
factor
depends
type
project
process
parameters
deadline
standards
etc
quality
experience
software
engineers
working
project
Contingency
estimates
add
effort
time
required
project
Schedule
presentation
Project
schedules
simply
documented
table
spreadsheet
showing
tasks
estimated
effort
duration
task
dependencies
Figure
However
style
presentation
makes
difficult
see
relationships
dependencies
different
activities
reason
alternative
graphical
visualizations
project
schedules
developed
often
easier
read
understand
Two
types
visualization
commonly
used
Calendar
based
bar
charts
show
responsible
activity
expected
elapsed
time
activity
scheduled
begin
end
Bar
charts
called
Gantt
charts
inventor
Henry
Gantt
@@@@@@@@@@
Project
scheduling
T
Task
Effort
person
days
Duration
days
Dependencies
T
T
T
M
T
T
T
T
M
T
T
T
M
T
T
M
T
T
M
T
T
T
M
T
T
T
M
T
T
M
T
T
T
M
Figure
Tasks
durations
dependencies
Activity
networks
show
dependencies
different
activities
making
project
networks
described
associated
web
section
Project
activities
basic
planning
element
activity
duration
calendar
days
months
effort
estimate
shows
number
person
days
person
months
complete
work
deadline
activity
complete
defined
endpoint
document
holding
review
meeting
successful
execution
tests
like
planning
project
decide
define
project
milestones
milestone
logical
end
stage
project
progress
work
reviewed
milestone
documented
brief
report
often
simply
email
summarizes
work
done
work
completed
planned
Milestones
associated
single
task
groups
related
activities
example
Figure
milestone
M
associated
task
T
marks
end
activity
Milestone
M
associated
pair
tasks
T
T
no
individual
milestone
end
tasks
@@@@@@@@@@
Chapter
Project
planning
Activity
charts
activity
chart
project
schedule
representation
presents
project
plan
directed
graph
shows
tasks
carried
parallel
executed
sequence
due
dependencies
earlier
activities
task
dependent
several
tasks
tasks
completed
start
critical
path
activity
chart
longest
sequence
dependent
tasks
defines
project
duration
http
software
engineering
book
com
web
planning
activities
activities
create
project
deliverables
outputs
delivered
software
customer
Usually
deliverables
required
specified
project
contract
customer
s
view
project
s
progress
depends
deliverables
Milestones
deliverables
thing
Milestones
short
reports
used
progress
reporting
deliverables
substantial
project
outputs
requirements
document
initial
implementation
system
Figure
shows
hypothetical
set
tasks
estimated
effort
duration
task
dependencies
table
see
task
T
dependent
task
T
means
task
T
completed
T
starts
example
T
selection
system
reuse
T
configuration
selected
system
t
start
system
configuration
chosen
installed
application
system
modified
Notice
estimated
duration
tasks
effort
required
vice
versa
effort
less
duration
people
allocated
task
working
full
time
effort
exceeds
duration
means
several
team
members
working
task
time
Figure
takes
information
Figure
presents
project
schedule
bar
chart
showing
project
calendar
start
finish
dates
tasks
Reading
left
right
bar
chart
clearly
shows
tasks
start
end
milestones
M
M
etc
shown
bar
chart
Notice
tasks
independent
carried
parallel
example
tasks
T
T
T
start
beginning
project
well
planning
delivery
schedule
software
project
managers
allocate
resources
tasks
key
resource
course
software
engineers
work
assigned
project
activities
resource
allocation
analyzed
project
management
tools
bar
chart
generated
showing
staff
working
project
Figure
People
working
one
task
time
sometimes
working
project
holiday
working
projects
attending
training
courses
show
part
time
assignments
using
diagonal
line
crossing
bar
Large
organizations
usually
employ
number
specialists
work
project
needed
Figure
see
Mary
specialist
works
@@@@@@@@@@
Project
scheduling
Week
Start
T
T
T
M
T
T
M
T
T
T
M
T
T
T
T
M
T
T
M
T
T
T
M
T
T
T
M
T
T
M
T
T
T
Finish
Figure
Activity
bar
chart
single
task
T
project
use
specialists
unavoidable
complex
systems
developed
lead
scheduling
problems
one
project
delayed
specialist
working
affect
projects
specialist
required
projects
delayed
specialist
available
task
delayed
later
tasks
dependent
affected
cannot
start
delayed
task
completed
Delays
cause
serious
problems
staff
allocation
especially
people
working
several
projects
time
task
T
delayed
people
allocated
assigned
work
W
complete
work
take
longer
delay
assigned
cannot
simply
reassigned
back
original
task
lead
delays
T
complete
W
Normally
use
project
planning
tool
Basecamp
Microsoft
project
create
update
analyze
project
schedule
information
Project
management
tools
usually
expect
input
project
information
table
create
database
project
information
Bar
charts
activity
charts
generated
automatically
database
@@@@@@@@@@
Chapter
Project
planning
Week
Figure
Staff
allocation
chart
Jane
Ali
Geetha
Maya
Fred
Mary
Hong
T
T
T
T
T
T
T
T
T
T
T
T
T
T
T
T
T
T
T
T
Agile
planning
Agile
methods
software
development
iterative
approaches
software
developed
delivered
customers
increments
Unlike
plan
driven
approaches
functionality
increments
planned
advance
decided
development
decision
include
increment
depends
progress
customer
s
priorities
argument
approach
customer
s
priorities
requirements
change
makes
sense
flexible
plan
accommodate
changes
Cohn
s
book
Cohn
excellent
introduction
agile
planning
Agile
development
methods
Scrum
Rubin
Extreme
Programming
Beck
Andres
two
stage
approach
planning
corresponding
startup
phase
plan
driven
development
development
planning
Release
planning
looks
ahead
several
months
decides
features
included
release
system
Iteration
planning
shorter
term
outlook
focuses
planning
next
increment
system
usually
represents
weeks
work
team
already
explained
Scrum
approach
planning
Chapter
based
project
backlogs
daily
reviews
work
done
primarily
geared
@@@@@@@@@@
Agile
planning
ReleaseplanningInitialestimationStoryidentificationIterationplanningTaskplanning
Figure
planning
game
iteration
planning
Another
approach
agile
planning
developed
part
Extreme
Programming
based
user
stories
called
planning
game
used
release
planning
iteration
planning
basis
planning
game
Figure
set
user
stories
see
Chapter
cover
functionality
included
final
system
development
team
software
customer
work
together
develop
stories
team
members
read
discuss
stories
rank
based
amount
time
think
take
implement
story
stories
large
implement
single
iteration
broken
smaller
stories
problem
ranking
stories
people
often
find
difficult
estimate
much
effort
time
needed
something
make
easier
relative
ranking
used
team
compares
stories
pairs
decides
take
time
effort
without
assessing
exactly
much
effort
required
end
process
list
stories
ordered
stories
top
list
taking
effort
implement
team
allocates
notional
effort
points
stories
list
complex
story
points
simple
story
points
stories
estimated
relative
effort
translated
first
estimate
total
effort
required
using
idea
velocity
Velocity
number
effort
points
implemented
team
per
day
estimated
previous
experience
developing
one
two
stories
see
much
time
required
velocity
estimate
approximate
refined
development
process
velocity
estimate
calculate
total
effort
person
days
implement
system
Release
planning
involves
selecting
refining
stories
reflect
features
implemented
release
system
order
stories
implemented
customer
involved
process
release
date
chosen
stories
examined
see
effort
estimate
consistent
date
stories
added
removed
list
Iteration
planning
first
stage
developing
deliverable
system
increment
Stories
implemented
iteration
chosen
number
stories
reflecting
time
deliver
workable
system
usually
weeks
team
s
velocity
delivery
date
reached
development
iteration
complete
even
stories
implemented
team
considers
stories
implemented
adds
effort
points
velocity
recalculated
measure
used
planning
next
version
system
start
development
iteration
task
planning
stage
developers
break
stories
development
tasks
development
task
take
hours
tasks
completed
implement
stories
iteration
listed
individual
developers
sign
specific
@@@@@@@@@@
Chapter
Project
planning
tasks
implement
developer
knows
individual
velocity
sign
tasks
implement
time
allotted
approach
task
allocation
two
important
benefits
whole
team
gets
overview
tasks
completed
iteration
therefore
understanding
team
members
talk
task
dependencies
identified
Individual
developers
choose
tasks
implement
simply
allocated
tasks
project
manager
therefore
sense
ownership
tasks
likely
motivate
complete
task
Halfway
iteration
progress
reviewed
stage
half
story
effort
points
completed
iteration
involves
story
points
tasks
story
points
tasks
completed
case
discussions
customer
stories
removed
system
increment
developed
approach
planning
advantage
software
increment
delivered
end
project
iteration
features
included
increment
cannot
completed
time
allowed
scope
work
reduced
delivery
schedule
never
extended
However
cause
problems
means
customer
plans
affected
Reducing
scope
create
extra
work
customers
use
incomplete
system
change
way
work
one
release
system
another
major
difficulty
agile
planning
relies
customer
involvement
availability
involvement
difficult
arrange
customer
representatives
sometimes
prioritize
work
available
planning
game
Furthermore
customers
familiar
traditional
project
plans
find
difficult
engage
agile
planning
process
Agile
planning
works
well
small
stable
development
teams
get
together
discuss
stories
implemented
However
teams
large
geographically
distributed
team
membership
changes
frequently
practically
impossible
everyone
involved
collaborative
planning
essential
agile
project
management
Consequently
large
projects
usually
planned
using
traditional
approaches
project
management
Estimation
techniques
Estimating
project
schedules
difficult
make
initial
estimates
basis
incomplete
user
requirements
definition
software
run
unfamiliar
platforms
use
new
development
technology
people
involved
project
skills
probably
known
many
uncertainties
impossible
estimate
system
development
costs
accurately
early
@@@@@@@@@@
Figure
Estimate
uncertainty
Estimation
techniques
x
x
x
x
x
Feasibility
Requirements
Design
Code
Delivery
stages
project
Nevertheless
organizations
need
make
software
effort
cost
estimates
Two
types
techniques
used
making
estimates
Experience
based
techniques
estimate
future
effort
requirements
based
manager
s
experience
past
projects
application
domain
Essentially
manager
makes
informed
judgment
effort
requirements
likely
Algorithmic
cost
modeling
approach
formulaic
approach
used
compute
project
effort
based
estimates
product
attributes
size
process
characteristics
experience
staff
involved
cases
need
use
judgment
estimate
effort
directly
project
product
characteristics
startup
phase
project
estimates
wide
margin
error
Based
data
collected
large
number
projects
Boehm
et
al
B
Boehm
et
al
discovered
startup
estimates
vary
significantly
initial
estimate
effort
required
x
months
effort
found
range
x
x
actual
effort
measured
system
delivered
development
planning
estimates
accurate
project
progresses
Figure
Experience
based
techniques
rely
manager
s
experience
past
projects
actual
effort
expended
projects
activities
related
software
development
Typically
identify
deliverables
produced
project
different
software
components
systems
developed
document
spreadsheet
estimate
individually
compute
total
effort
required
usually
helps
get
group
people
involved
effort
estimation
ask
member
group
explain
estimate
often
reveals
factors
others
considered
iterate
toward
agreed
group
estimate
@@@@@@@@@@
Chapter
Project
planning
difficulty
experience
based
techniques
new
software
project
much
common
previous
projects
Software
development
changes
quickly
project
often
use
unfamiliar
techniques
web
services
application
system
configuration
HTML
worked
techniques
previous
experience
help
estimate
effort
required
making
difficult
produce
accurate
costs
schedule
estimates
impossible
say
experience
based
algorithmic
approaches
accurate
Project
estimates
often
self
fulfilling
estimate
used
define
project
budget
product
adjusted
budget
figure
realized
project
budget
achieved
expense
features
software
developed
make
comparison
accuracy
techniques
number
controlled
experiments
required
several
techniques
used
independently
estimate
project
effort
costs
No
changes
project
allowed
final
effort
compared
project
manager
know
effort
estimates
no
bias
introduced
However
scenario
completely
impossible
real
projects
never
objective
comparison
approaches
Algorithmic
cost
modeling
Algorithmic
cost
modeling
uses
mathematical
formula
predict
project
costs
based
estimates
project
size
type
software
developed
team
process
product
factors
Algorithmic
cost
models
developed
analyzing
costs
attributes
completed
projects
finding
closest
fit
formula
actual
costs
incurred
Algorithmic
cost
models
primarily
used
make
estimates
software
development
costs
However
Boehm
collaborators
B
W
Boehm
et
al
discuss
range
uses
models
preparation
estimates
investors
software
companies
alternative
strategies
help
assess
risks
inform
decisions
reuse
redevelopment
outsourcing
algorithmic
models
estimating
effort
software
project
based
simple
formula
Effort
SizeB
M
constant
factor
depends
local
organizational
practices
type
software
developed
Size
assessment
code
size
software
functionality
estimate
expressed
function
application
points
B
represents
complexity
software
usually
lies
M
factor
takes
account
process
product
development
attributes
dependability
requirements
software
experience
development
team
attributes
increase
decrease
overall
difficulty
developing
system
@@@@@@@@@@
Estimation
techniques
number
lines
source
code
SLOC
delivered
system
fundamental
size
metric
used
many
algorithmic
cost
models
estimate
number
lines
code
system
use
combination
approaches
Compare
system
developed
similar
systems
use
code
size
basis
estimate
Estimate
number
function
application
points
system
see
following
section
formulaically
convert
lines
code
programming
language
used
Rank
system
components
using
judgment
relative
sizes
use
known
reference
component
translate
ranking
code
sizes
algorithmic
estimation
models
exponential
component
B
equation
increases
size
complexity
system
reflects
fact
costs
usually
increase
linearly
project
size
size
complexity
software
increase
extra
costs
incurred
communication
overhead
larger
teams
complex
configuration
management
difficult
system
integration
complex
system
factors
affect
cost
idea
using
scientific
objective
approach
cost
estimation
attractive
one
algorithmic
cost
models
suffer
two
key
problems
practically
impossible
estimate
Size
accurately
early
stage
project
specification
available
Function
point
application
point
estimates
see
later
easier
produce
estimates
code
size
usually
inaccurate
estimates
complexity
process
factors
contributing
B
M
subjective
Estimates
vary
one
person
another
depending
background
experience
type
system
developed
Accurate
code
size
estimation
difficult
early
stage
project
size
final
program
depends
design
decisions
made
estimate
required
example
application
requires
high
performance
data
management
implement
data
management
system
use
commercial
database
system
initial
cost
estimation
unlikely
know
commercial
database
system
performs
well
enough
meet
performance
requirements
therefore
don
t
know
much
data
management
code
included
system
programming
language
used
system
development
affects
number
lines
code
developed
language
like
Java
mean
lines
code
necessary
C
say
used
However
extra
code
allows
compile
time
checking
validation
costs
likely
reduced
clear
taken
account
estimation
process
Code
reuse
@@@@@@@@@@
Chapter
Project
planning
Software
productivity
Software
productivity
estimate
average
amount
development
work
software
engineers
complete
week
month
therefore
expressed
lines
code
month
function
points
month
forth
However
productivity
easily
measured
tangible
outcome
e
g
administrator
processes
N
travel
claims
day
software
productivity
difficult
define
Different
people
implement
functionality
different
ways
using
different
numbers
lines
code
quality
code
important
extent
subjective
Therefore
t
really
compare
productivity
individual
engineers
makes
sense
use
productivity
measures
large
groups
http
software
engineering
book
com
web
productivity
makes
difference
models
explicitly
estimate
number
lines
code
reused
However
application
systems
external
services
reused
difficult
compute
number
lines
source
code
replace
Algorithmic
cost
models
systematic
way
estimate
effort
required
develop
system
However
models
complex
difficult
use
many
attributes
considerable
scope
uncertainty
estimating
values
complexity
means
practical
application
algorithmic
cost
modeling
limited
relatively
small
number
large
companies
mostly
working
defense
aerospace
systems
engineering
Another
barrier
discourages
use
algorithmic
models
need
calibration
Model
users
calibrate
model
attribute
values
using
historical
project
data
reflects
local
practice
experience
However
organizations
collected
enough
data
past
projects
form
supports
model
calibration
Practical
use
algorithmic
models
therefore
start
published
values
model
parameters
practically
impossible
modeler
know
closely
relate
organization
use
algorithmic
cost
estimation
model
develop
range
estimates
worst
expected
best
rather
single
estimate
apply
costing
formula
Estimates
likely
accurate
understand
type
software
developed
calibrated
costing
model
using
local
data
programming
language
hardware
choices
predefined
COCOMO
cost
modeling
best
known
algorithmic
cost
modeling
technique
tool
COCOMO
II
model
empirical
model
derived
collecting
data
large
number
software
projects
different
sizes
data
analyzed
discover
formulas
best
fit
observations
formulas
linked
size
@@@@@@@@@@
COCOMO
cost
modeling
Number
application
points
Based
Application
composition
model
Used
Number
function
points
Used
Used
Used
Based
Based
Based
Number
lines
code
reused
generated
Number
lines
source
code
Early
design
model
Reuse
model
Post
architecture
model
Systems
developed
using
dynamic
languages
DB
programming
etc
Initial
effort
estimation
based
system
requirements
design
options
Effort
integrate
reusable
components
automatically
generated
code
Development
effort
based
system
design
specification
Figure
COCOMO
estimation
models
system
product
project
team
factors
effort
develop
system
COCOMO
II
freely
available
model
supported
open
source
tools
COCOMO
II
developed
earlier
COCOMO
Constructive
Cost
Modeling
cost
estimation
models
largely
based
original
code
development
B
W
Boehm
B
Boehm
Royce
COCOMO
II
model
takes
account
modern
approaches
software
development
rapid
development
using
dynamic
languages
development
reuse
database
programming
COCOMO
II
embeds
several
submodels
based
techniques
produce
increasingly
detailed
estimates
submodels
Figure
part
COCOMO
II
model
application
composition
model
models
effort
required
develop
systems
created
reusable
components
scripting
database
programming
Software
size
estimates
based
application
points
simple
size
productivity
formula
used
estimate
effort
required
early
design
model
model
used
early
stages
system
design
requirements
established
estimate
based
standard
estimation
formula
discussed
introduction
chapter
simplified
set
seven
multipliers
Estimates
based
function
points
converted
number
lines
source
code
Function
points
language
independent
way
quantifying
program
functionality
compute
total
number
function
points
program
measuring
estimating
number
external
inputs
outputs
user
interactions
external
interfaces
files
database
tables
used
system
@@@@@@@@@@
Chapter
Project
planning
reuse
model
model
used
compute
effort
required
integrate
reusable
components
automatically
generated
program
code
normally
used
conjunction
post
architecture
model
post
architecture
model
system
architecture
designed
accurate
estimate
software
size
made
model
uses
standard
formula
cost
estimation
discussed
However
includes
extensive
set
multipliers
reflecting
personnel
capability
product
project
characteristics
course
large
systems
different
parts
system
developed
using
different
technologies
estimate
parts
system
level
accuracy
cases
use
appropriate
submodel
part
system
combine
results
create
composite
estimate
COCOMO
II
model
complex
model
make
easier
explain
simplified
presentation
use
models
explained
simple
cost
estimation
However
use
COCOMO
properly
refer
Boehm
s
book
manual
COCOMO
II
model
B
W
Boehm
et
al
Abts
et
al
application
composition
model
application
composition
model
introduced
COCOMO
II
support
estimation
effort
required
prototyping
projects
projects
software
developed
composing
existing
components
based
estimate
weighted
application
points
sometimes
called
object
points
divided
standard
estimate
application
point
productivity
B
W
Boehm
et
al
number
application
points
program
derived
four
simpler
estimates
number
separate
screens
web
pages
displayed
number
reports
produced
number
modules
imperative
programming
languages
Java
number
lines
scripting
language
database
programming
code
estimate
adjusted
according
difficulty
developing
application
point
Productivity
depends
developer
s
experience
capability
well
capabilities
software
tools
ICASE
used
support
development
Figure
shows
levels
application
point
productivity
suggested
COCOMO
model
developers
Application
composition
usually
relies
reusing
existing
software
configuring
application
systems
application
points
system
therefore
implemented
using
reusable
components
Consequently
adjust
@@@@@@@@@@
COCOMO
cost
modeling
Developer
s
low
Low
Nominal
High
high
experience
capability
ICASE
maturity
capability
low
Low
Nominal
High
high
PROD
NAP
month
Figure
Application
point
productivity
estimate
take
account
percentage
reuse
expected
Therefore
final
formula
effort
computation
system
prototypes
PM
NAP
reuse
PROD
PM
effort
estimate
person
months
NAP
total
number
application
points
delivered
system
reuse
estimate
amount
reused
code
development
PROD
application
point
productivity
shown
Figure
early
design
model
model
used
early
stages
project
detailed
architectural
design
system
available
early
design
model
assumes
user
requirements
agreed
initial
stages
system
design
process
underway
goal
stage
make
quick
approximate
cost
estimate
Therefore
make
simplifying
assumptions
assumption
no
effort
involved
integrating
reusable
code
Early
design
estimates
useful
option
exploration
need
compare
different
ways
implementing
user
requirements
estimates
produced
stage
based
standard
formula
algorithmic
models
namely
Effort
SizeB
M
Based
large
dataset
Boehm
proposed
co
efficient
size
system
expressed
KSLOC
number
thousands
lines
source
code
calculate
KSLOC
estimating
number
function
points
software
use
standard
tables
relate
software
size
function
points
different
programming
languages
QSM
compute
initial
estimate
system
size
KSLOC
exponent
B
reflects
increased
effort
required
size
project
increases
vary
depending
novelty
project
development
flexibility
risk
resolution
processes
used
cohesion
development
team
process
maturity
level
see
web
Chapter
organization
discuss
value
exponent
calculated
using
parameters
description
COCOMO
II
post
architecture
model
@@@@@@@@@@
Chapter
Project
planning
results
effort
computation
follows
PM
Size
M
M
PERS
PREX
RCPX
RUSE
PDIF
SCED
FSIL
PERS
personnel
capability
PREX
personnel
experience
RCPX
product
reliability
complexity
RUSE
reuse
required
PDIF
platform
difficulty
SCED
schedule
FSIL
support
facilities
multiplier
M
based
seven
project
process
attributes
increase
decrease
estimate
explain
attributes
book
s
web
pages
estimate
values
attributes
using
six
point
scale
corresponds
low
corresponds
high
example
PERS
means
expert
staff
available
work
project
reuse
model
COCOMO
reuse
model
used
estimate
effort
required
integrate
reusable
generated
code
discussed
Chapter
software
reuse
now
norm
software
development
large
systems
include
significant
amount
code
reused
previous
development
projects
COCOMO
II
considers
two
types
reused
code
Black
box
code
code
reused
without
understanding
code
making
changes
Examples
black
box
code
components
automatically
generated
UML
models
application
libraries
graphics
libraries
assumed
development
effort
black
box
code
zero
size
taken
account
overall
effort
computation
White
box
code
reusable
code
adapted
integrate
new
code
reused
components
Development
effort
required
reuse
code
understood
modified
work
correctly
system
White
box
code
automatically
generated
code
needs
manual
changes
additions
Alternatively
reused
components
systems
modified
system
developed
Three
factors
contribute
effort
involved
reusing
white
box
code
components
effort
involved
assessing
component
reused
system
developed
effort
required
understand
code
reused
effort
required
modify
reused
code
adapt
integrate
system
developed
@@@@@@@@@@
COCOMO
cost
modeling
development
effort
reuse
model
calculated
using
COCOMO
early
design
model
based
total
number
lines
code
system
code
size
includes
new
code
developed
components
reused
plus
additional
factor
allows
effort
involved
reusing
integrating
existing
code
additional
factor
called
ESLOC
equivalent
number
lines
new
source
code
express
reuse
effort
effort
involved
developing
additional
source
code
formula
used
calculate
source
code
equivalence
ESLOC
ASLOC
AAM
ESLOC
equivalent
number
lines
new
source
code
ASLOC
estimate
number
lines
code
reused
components
changed
percentage
reused
code
modified
automatically
AAM
Adaptation
Adjustment
Multiplier
reflects
additional
effort
required
reuse
components
cases
adjustments
required
reuse
code
syntactic
implemented
automated
tool
involve
significant
effort
estimate
fraction
changes
made
reused
code
automated
reduces
total
number
lines
code
adapted
Adaptation
Adjustment
Multiplier
AAM
adjusts
estimate
reflect
additional
effort
required
reuse
code
COCOMO
model
documentation
Abts
et
al
discusses
detail
AAM
calculated
Simplistically
AAM
sum
three
components
assessment
factor
referred
AA
represents
effort
involved
deciding
reuse
components
AA
varies
depending
amount
time
need
spend
looking
assessing
potential
candidates
reuse
understanding
component
referred
SU
represents
costs
understanding
code
reused
familiarity
engineer
code
reused
SU
ranges
complex
unstructured
code
well
written
object
oriented
code
adaptation
component
referred
AAF
represents
costs
making
changes
reused
code
include
design
code
integration
changes
calculated
value
ESLOC
apply
standard
estimation
formula
calculate
total
effort
required
Size
parameter
ESLOC
Therefore
formula
estimate
reuse
effort
Effort
ESLOCB
M
B
M
values
used
early
design
model
@@@@@@@@@@
Chapter
Project
planning
COCOMO
cost
drivers
COCOMO
II
cost
drivers
attributes
reflect
product
team
process
organizational
factors
affect
amount
effort
needed
develop
software
system
example
high
level
reliability
required
extra
effort
needed
need
rapid
delivery
extra
effort
required
team
members
change
extra
effort
required
attributes
COCOMO
II
model
assigned
estimated
values
model
developers
http
software
engineering
book
com
web
cost
drivers
post
architecture
level
post
architecture
model
detailed
COCOMO
II
models
used
initial
architectural
design
system
starting
point
estimates
produced
post
architecture
level
basic
formula
used
early
design
estimates
PM
SizeB
M
stage
process
able
make
accurate
estimate
project
size
know
system
decomposed
subsystems
components
make
estimate
overall
code
size
adding
three
code
size
estimates
estimate
total
number
lines
new
code
developed
SLOC
estimate
reuse
costs
based
equivalent
number
source
lines
code
ESLOC
calculated
using
reuse
model
estimate
number
lines
code
changed
changes
system
requirements
final
component
estimate
number
lines
modified
code
reflects
fact
software
requirements
change
leads
rework
development
extra
code
take
account
course
often
even
uncertainty
figure
estimates
new
code
developed
exponent
term
B
effort
computation
formula
related
levels
project
complexity
projects
complex
effects
increasing
system
size
significant
value
exponent
B
based
five
factors
shown
Figure
factors
rated
six
point
scale
means
extra
high
means
low
calculate
B
add
ratings
divide
add
result
get
exponent
used
@@@@@@@@@@
COCOMO
cost
modeling
Scale
factor
Explanation
Architecture
risk
resolution
Reflects
extent
risk
analysis
carried
low
means
little
analysis
extra
high
means
complete
thorough
risk
analysis
Reflects
degree
flexibility
development
process
low
means
prescribed
process
used
extra
high
means
client
sets
general
goals
Reflects
previous
experience
organization
type
project
low
means
no
previous
experience
extra
high
means
organization
completely
familiar
application
domain
Reflects
well
development
team
knows
works
together
low
means
difficult
interactions
extra
high
means
integrated
effective
team
no
communication
problems
Reflects
process
maturity
organization
discussed
web
chapter
computation
value
depends
CMM
Maturity
Questionnaire
estimate
achieved
subtracting
CMM
process
maturity
level
Figure
Scale
factors
used
example
imagine
organization
taking
project
domain
exponent
computation
little
previous
experience
project
client
defined
process
used
post
architecture
model
allowed
time
project
schedule
significant
risk
analysis
new
development
team
put
together
implement
system
organization
recently
put
place
process
improvement
program
rated
Level
organization
according
SEI
capability
assessment
discussed
Chapter
web
chapter
characteristics
lead
estimates
ratings
used
exponent
calculation
follows
Development
flexibility
Precedentedness
Team
cohesion
Process
maturity
Precedentedness
rated
low
new
project
organization
Development
flexibility
rated
high
no
client
involvement
development
process
externally
imposed
changes
Architecture
risk
resolution
rated
low
no
risk
analysis
carried
Team
cohesion
rated
nominal
new
team
no
information
available
cohesion
Process
maturity
rated
nominal
process
control
place
sum
values
calculate
final
value
exponent
dividing
sum
adding
result
adjusted
value
B
therefore
overall
effort
estimate
refined
using
extensive
set
product
process
organizational
attributes
see
breakout
box
rather
seven
attributes
used
early
design
model
estimate
values
attributes
information
software
non
functional
requirements
development
team
development
process
@@@@@@@@@@
Chapter
Project
planning
Exponent
value
Figure
effect
cost
drivers
effort
estimates
System
size
including
factors
reuse
requirements
volatility
KLOC
Initial
COCOMO
estimate
without
cost
drivers
person
months
Reliability
high
multiplier
Complexity
high
multiplier
Memory
constraint
High
multiplier
Tool
use
Low
multiplier
Schedule
Accelerated
multiplier
Adjusted
COCOMO
estimate
person
months
Reliability
low
multiplier
Complexity
low
multiplier
Memory
constraint
None
multiplier
Tool
use
high
multiplier
Schedule
Normal
multiplier
Adjusted
COCOMO
estimate
person
months
Figure
shows
cost
driver
attributes
influence
effort
estimates
Assume
exponent
value
discussed
example
Reliability
RELY
complexity
CPLX
storage
STOR
tools
TOOL
schedule
SCED
key
cost
drivers
project
cost
drivers
nominal
value
affect
effort
computation
Figure
assigned
maximum
minimum
values
key
cost
drivers
show
influence
effort
estimate
values
used
COCOMO
II
reference
manual
Abts
et
al
see
high
values
cost
drivers
lead
effort
estimate
three
times
initial
estimate
low
values
reduce
estimate
one
third
original
highlights
significant
differences
different
types
project
difficulties
transferring
experience
one
application
domain
another
Project
duration
staffing
well
estimating
overall
costs
project
effort
required
develop
software
system
project
managers
estimate
long
software
take
develop
staff
needed
work
project
Increasingly
organizations
demanding
shorter
development
schedules
products
brought
market
competitor
s
@@@@@@@@@@
COCOMO
cost
modeling
COCOMO
model
includes
formula
estimate
calendar
time
required
complete
project
TDEV
PM
B
TDEV
nominal
schedule
project
calendar
months
ignoring
multiplier
related
project
schedule
PM
effort
computed
COCOMO
model
B
complexity
related
exponent
discussed
section
B
PM
TDEV
months
nominal
project
schedule
predicted
COCOMO
model
necessarily
correspond
schedule
required
software
customer
deliver
software
earlier
rarely
later
date
suggested
nominal
schedule
schedule
compressed
e
software
developed
quickly
increases
effort
required
project
taken
account
SCED
multiplier
effort
estimation
computation
Assume
project
estimated
TDEV
months
suggested
actual
schedule
required
months
represents
schedule
compression
approximately
Using
values
SCED
multiplier
derived
Boehm
s
team
see
effort
multiplier
level
schedule
compression
Therefore
actual
effort
required
accelerated
schedule
met
effort
required
deliver
software
according
nominal
schedule
complex
relationship
number
people
working
project
effort
devoted
project
project
delivery
schedule
four
people
complete
project
months
e
person
months
effort
think
adding
one
person
complete
work
months
person
months
effort
However
COCOMO
model
suggests
fact
need
six
people
finish
work
months
person
months
effort
reason
adding
people
project
reduces
productivity
existing
team
members
project
team
increases
size
team
members
spend
time
communicating
defining
interfaces
parts
system
developed
people
Doubling
number
staff
example
therefore
mean
duration
project
halved
Consequently
add
extra
person
actual
increment
effort
added
less
one
person
others
less
productive
development
team
large
adding
people
project
sometimes
increases
rather
reduces
development
schedule
overall
effect
productivity
cannot
simply
estimate
number
people
required
project
team
dividing
total
effort
required
project
schedule
Usually
small
number
people
needed
start
project
carry
initial
design
team
@@@@@@@@@@
Chapter
Project
planning
builds
peak
development
testing
system
declines
size
system
prepared
deployment
rapid
build
project
staff
shown
correlate
project
schedule
slippage
project
manager
therefore
avoid
adding
many
staff
project
early
lifetime
Key
Points
price
charged
system
depend
estimated
development
costs
profit
required
development
company
Organizational
factors
mean
price
increased
compensate
increased
risk
decreased
gain
competitive
advantage
Software
often
priced
gain
contract
functionality
system
adjusted
meet
estimated
price
Plan
driven
development
organized
around
complete
project
plan
defines
project
activities
planned
effort
activity
schedule
responsible
activity
Project
scheduling
involves
creation
various
graphical
representations
part
project
plan
Bar
charts
show
activity
duration
staffing
timelines
commonly
used
schedule
representations
project
milestone
predictable
outcome
activity
set
activities
milestone
formal
report
progress
presented
management
deliverable
work
product
delivered
project
customer
agile
planning
game
involves
whole
team
project
planning
plan
developed
incrementally
problems
arise
adjusted
software
functionality
reduced
instead
delaying
delivery
increment
Estimation
techniques
software
experience
based
managers
judge
effort
required
algorithmic
effort
required
computed
estimated
project
parameters
COCOMO
II
costing
model
mature
algorithmic
cost
model
takes
project
product
hardware
personnel
attributes
account
formulating
cost
estimate
rEAding
reading
suggested
Chapter
relevant
chapter
Ten
Unmyths
Project
Estimation
pragmatic
article
discusses
practical
difficulties
project
estimation
challenges
fundamental
assumptions
area
P
Armour
Comm
ACM
November
http
dx
doi
org
@@@@@@@@@@
Chapter
Exercises
Agile
Estimating
Planning
book
comprehensive
description
story
based
planning
used
XP
well
rationale
using
agile
approach
project
planning
book
includes
good
general
introduction
project
planning
issues
M
Cohn
Prentice
Hall
Achievements
Challenges
COCOMO
based
Software
Resource
Estimation
article
presents
history
COCOMO
models
influences
models
discusses
variants
models
developed
identifies
possible
developments
COCOMO
approach
B
W
Boehm
R
Valeridi
IEEE
Software
September
October
http
dx
doi
org
MS
Agile
Agile
Planning
website
agile
methods
includes
excellent
set
articles
agile
planning
number
different
authors
http
www
allaboutagile
com
category
agile
planning
Project
Management
Knowhow
Project
Planning
website
number
useful
articles
project
management
general
aimed
people
don
t
previous
experience
area
P
Stoemmer
http
www
project
management
knowhow
com
project
planning
html
WEbSitE
PowerPoint
slides
chapter
www
pearsonglobaleditions
com
Sommerville
Links
supporting
videos
http
software
engineering
book
com
videos
software
management
ExErCiSES
Describe
factors
affect
software
pricing
Define
pricing
win
approach
software
pricing
Explain
process
project
planning
iterative
plan
continually
reviewed
software
project
Define
project
scheduling
things
considered
estimating
schedules
algorithmic
cost
modeling
problems
suffer
compared
approaches
cost
estimation
Figure
sets
number
tasks
durations
dependencies
Draw
bar
chart
showing
project
schedule
@@@@@@@@@@
Chapter
Project
planning
Task
Duration
Dependencies
T
Figure
Scheduling
example
T
T
T
T
T
T
T
T
T
T
T
T
T
T
T
T
T
T
T
T
T
T
T
T
T
T
T
T
T
T
T
T
T
T
Figure
shows
task
durations
software
project
activities
Assume
serious
unanticipated
setback
occurs
instead
taking
days
task
T
takes
days
Draw
new
bar
charts
showing
project
reorganized
planning
game
based
notion
planning
implement
stories
represent
system
requirements
Explain
potential
problems
approach
software
high
performance
dependability
requirements
software
manager
charge
development
safety
critical
software
system
designed
control
radiotherapy
machine
treat
patients
suffering
cancer
system
embedded
machine
run
special
purpose
processor
fixed
amount
memory
Mbytes
machine
communicates
patient
database
system
obtain
details
patient
treatment
automatically
records
radiation
dose
delivered
treatment
details
database
COCOMO
method
used
estimate
effort
required
develop
system
estimate
person
months
computed
cost
driver
multipliers
set
making
estimate
@@@@@@@@@@
Chapter
References
Explain
estimate
adjusted
take
project
personnel
product
organizational
factors
account
Suggest
four
factors
significant
effects
initial
COCOMO
estimate
propose
possible
values
factors
Justify
included
factor
large
software
projects
involve
writing
millions
lines
code
Explain
effort
estimation
models
COCOMO
work
well
applied
large
systems
ethical
company
quote
low
price
software
contract
knowing
requirements
ambiguous
charge
high
price
subsequent
changes
requested
customer
rEFErEnCES
Abts
C
B
Clark
S
Devnani
Chulani
B
W
Boehm
COCOMO
II
Model
Definition
Manual
Center
Software
Engineering
University
Southern
California
http
csse
usc
edu
csse
research
COCOMOII
cocomo
CII
modelman
pdf
Beck
K
C
Andres
Extreme
Programming
Explained
nd
ed
Boston
Addison
Wesley
Boehm
B
B
Clark
E
Horowitz
C
Westland
R
Madachy
R
Selby
Cost
Models
Future
Software
Life
Cycle
Processes
COCOMO
Annals
Software
Engineering
doi
BF
Boehm
B
W
Royce
Ada
COCOMO
Ada
Process
Model
Proc
th
COCOMO
Users
Group
Meeting
Pittsburgh
Software
Engineering
Institute
http
www
dtic
mil
dtic
tr
fulltext
u
pdf
Boehm
B
W
Software
Engineering
Economics
Englewood
Cliffs
NJ
Prentice
Hall
Boehm
B
W
C
Abts
W
Brown
S
Chulani
B
K
Clark
E
Horowitz
R
Madachy
D
Reifer
B
Steece
Software
Cost
Estimation
COCOMO
II
Englewood
Cliffs
NJ
Prentice
Hall
Cohn
M
Agile
Estimating
Planning
Englewood
Cliffs
NJ
Prentice
Hall
QSM
Function
Point
Languages
Table
http
www
qsm
com
resources
function
point
languages
table
Rubin
K
S
Essential
Scrum
Boston
Addison
Wesley
@@@@@@@@@@
Quality
management
Objectives
objectives
chapter
introduce
software
quality
management
software
measurement
read
chapter
introduced
quality
management
process
know
quality
planning
important
aware
importance
standards
quality
management
process
know
standards
used
quality
assurance
understand
reviews
inspections
used
mechanism
software
quality
assurance
understand
quality
management
agile
methods
based
development
team
quality
culture
understand
measurement
helpful
assessing
software
quality
attributes
notion
software
analytics
limitations
software
measurement
Contents
Software
quality
Software
standards
Reviews
inspections
Quality
management
agile
development
Software
measurement
@@@@@@@@@@
Chapter
Quality
management
Software
quality
management
concerned
ensuring
developed
software
systems
fit
purpose
systems
meet
needs
users
perform
efficiently
reliably
delivered
time
budget
use
quality
management
techniques
along
new
software
technologies
testing
methods
led
significant
improvements
level
software
quality
past
years
Formalized
quality
management
QM
particularly
important
teams
developing
large
long
lifetime
systems
take
several
years
develop
systems
developed
external
clients
usually
using
plan
based
process
systems
quality
management
organizational
individual
project
issue
organizational
level
quality
management
concerned
establishing
framework
organizational
processes
standards
lead
high
quality
software
QM
team
take
responsibility
defining
software
development
processes
used
standards
apply
software
related
documentation
including
system
requirements
design
code
project
level
quality
management
involves
application
specific
quality
processes
checking
planned
processes
followed
ensuring
project
outputs
meet
defined
project
standards
Project
quality
management
involve
defining
quality
plan
project
quality
plan
set
quality
goals
project
define
processes
standards
used
Software
quality
management
techniques
roots
methods
techniques
developed
manufacturing
industries
terms
quality
assurance
quality
control
widely
used
Quality
assurance
definition
processes
standards
lead
high
quality
products
introduction
quality
processes
manufacturing
process
Quality
control
application
quality
processes
weed
products
required
level
quality
quality
assurance
quality
control
part
quality
management
software
industry
companies
see
quality
assurance
definition
procedures
processes
standards
ensure
software
quality
achieved
companies
quality
assurance
includes
configuration
management
verification
validation
activities
applied
product
handed
development
team
Quality
management
provides
independent
check
software
development
process
QM
team
checks
project
deliverables
ensure
consistent
organizational
standards
goals
Figure
check
process
documentation
records
tasks
completed
team
working
project
QM
team
uses
documentation
check
important
tasks
forgotten
one
group
made
incorrect
assumptions
groups
done
QM
team
large
companies
usually
responsible
managing
release
testing
process
discussed
Chapter
means
manage
testing
software
released
customers
addition
responsible
@@@@@@@@@@
Software
development
D
D
D
D
D
process
Quality
management
process
Standards
Quality
Quality
review
reports
procedures
plan
Figure
Quality
management
software
development
checking
system
tests
provide
coverage
requirements
proper
records
testing
process
maintained
QM
team
independent
part
software
development
group
take
objective
view
quality
software
report
software
quality
without
influenced
software
development
issues
Ideally
QM
team
organization
wide
responsibility
quality
management
report
management
project
manager
level
project
managers
maintain
project
budget
schedule
tempted
compromise
product
quality
meet
schedule
independent
QM
team
ensures
organizational
goals
quality
influenced
short
term
budget
schedule
considerations
smaller
companies
however
practically
impossible
Quality
management
software
development
inevitably
intertwined
people
development
quality
responsibilities
Formalized
quality
planning
integral
part
plan
based
development
processes
process
developing
quality
plan
project
quality
plan
set
desired
software
qualities
describe
qualities
assessed
defines
high
quality
software
means
particular
system
Engineers
therefore
shared
understanding
important
software
quality
attributes
Humphrey
Humphrey
classic
book
software
management
suggests
outline
structure
quality
plan
outline
includes
following
Product
introduction
description
product
intended
market
quality
expectations
product
Product
plans
critical
release
dates
responsibilities
product
along
plans
distribution
product
servicing
Process
descriptions
development
service
processes
standards
used
product
development
management
Quality
goals
quality
goals
plans
product
including
identification
justification
critical
product
quality
attributes
Risks
risk
management
key
risks
affect
product
quality
actions
taken
address
risks
@@@@@@@@@@
Quality
plans
developed
part
general
project
planning
process
differ
detail
depending
size
type
system
developed
However
writing
quality
plans
try
keep
short
possible
document
long
people
read
defeating
purpose
producing
quality
plan
Traditional
quality
management
formal
process
relies
maintaining
extensive
documentation
testing
system
validation
processes
followed
respect
diametrically
opposed
agile
development
aim
spend
little
time
possible
writing
documents
formalizing
development
work
done
QM
techniques
therefore
evolve
agile
methods
used
discuss
QM
agile
development
Section
Software
quality
manufacturing
industry
established
fundamentals
quality
management
drive
improve
quality
products
made
part
effort
industry
developed
definition
quality
based
conformance
detailed
product
specification
underlying
assumption
products
completely
specified
procedures
established
check
manufactured
product
specification
course
products
never
exactly
meet
specification
tolerance
allowed
product
right
classed
acceptable
Software
quality
directly
comparable
quality
manufacturing
idea
tolerances
applicable
analog
systems
apply
software
Furthermore
often
impossible
come
objective
conclusion
software
system
meets
specification
difficult
write
complete
unambiguous
software
requirements
Software
developers
customers
interpret
requirements
different
ways
impossible
reach
agreement
software
conforms
specification
Specifications
usually
integrate
requirements
several
classes
stakeholder
requirements
inevitably
compromise
include
requirements
stakeholder
groups
excluded
stakeholders
therefore
perceive
system
poor
quality
system
even
though
implements
agreed
requirements
impossible
measure
certain
quality
characteristics
e
g
maintainability
directly
cannot
specified
unambiguous
way
discuss
difficulties
measurement
Section
problems
assessment
software
quality
subjective
process
quality
management
team
uses
judgment
decide
acceptable
level
quality
achieved
decide
software
fit
@@@@@@@@@@
Safety
Understandability
Portability
Security
Testability
Usability
Reliability
Adaptability
Reusability
Resilience
Modularity
Efficiency
Robustness
Complexity
Learnability
Figure
Software
quality
attributes
intended
purpose
decision
involves
answering
questions
system
s
characteristics
example
software
properly
tested
shown
requirements
implemented
software
sufficiently
dependable
put
use
performance
software
acceptable
normal
use
software
usable
software
well
structured
understandable
programming
documentation
standards
followed
development
process
general
assumption
software
quality
management
system
tested
requirements
judgment
delivers
required
functionality
based
results
tests
Therefore
QM
team
review
tests
developed
examine
test
records
check
testing
properly
carried
companies
QM
group
carries
final
system
testing
others
dedicated
system
testing
team
reports
system
quality
manager
subjective
quality
software
system
largely
based
non
functional
characteristics
reflects
practical
user
experience
software
s
functionality
expected
users
often
work
around
deficiency
find
ways
want
However
software
unreliable
slow
practically
impossible
achieve
goals
Therefore
software
quality
software
functionality
correctly
implemented
depends
non
functional
system
attributes
shown
Figure
attributes
reflect
software
dependability
usability
efficiency
maintainability
possible
system
optimized
attributes
example
improving
security
lead
loss
performance
quality
plan
therefore
define
important
quality
attributes
software
developed
efficiency
critical
factors
sacrificed
achieve
emphasized
importance
efficienty
quality
plan
engineers
working
development
work
together
achieve
plan
include
definition
quality
assessment
process
@@@@@@@@@@
Define
process
Develop
product
Assess
product
quality
Standardize
process
Improve
process
Quality
No
Define
process
Develop
product
Assess
product
quality
Standardize
process
Improve
process
Quality
No
Figure
Process
based
quality
process
agreed
way
assessing
quality
maintainability
robustness
present
product
Traditional
software
quality
management
based
assumption
quality
software
directly
related
quality
software
development
process
assumption
comes
manufacturing
systems
product
quality
intimately
related
production
process
manufacturing
process
involves
configuring
setting
operating
machines
involved
process
machines
operating
correctly
product
quality
naturally
follows
measure
quality
product
change
process
achieve
quality
level
need
Figure
illustrates
process
based
approach
achieving
product
quality
clear
link
process
product
quality
manufacturing
process
relatively
easy
standardize
monitor
manufacturing
systems
calibrated
run
output
high
quality
products
However
software
designed
rather
manufactured
relationship
process
quality
product
quality
complex
Software
design
creative
process
influence
individual
skills
experience
significant
External
factors
novelty
application
commercial
pressure
early
product
release
affect
product
quality
irrespective
process
used
Without
doubt
development
process
used
significant
influence
quality
software
good
processes
likely
lead
good
quality
software
Process
quality
management
improvement
result
fewer
defects
software
developed
However
difficult
assess
software
quality
attributes
reliability
maintainability
without
using
software
long
period
Consequently
hard
tell
process
characteristics
influence
attributes
Furthermore
role
design
creativity
software
process
process
standardization
sometimes
stifle
creativity
lead
poorer
rather
better
quality
software
Defined
processes
important
quality
managers
aim
develop
quality
culture
everyone
responsible
software
development
committed
achieving
high
level
product
quality
encourage
teams
take
responsibility
quality
work
develop
new
approaches
quality
improvement
standards
procedures
basis
quality
management
good
quality
managers
recognize
intangible
aspects
software
quality
elegance
readability
etc
cannot
embodied
standards
support
people
interested
intangible
aspects
quality
encourage
professional
behavior
team
members
@@@@@@@@@@
Documentation
standards
Project
documents
tangible
way
describing
different
representations
software
system
requirements
UML
code
etc
production
process
Documentation
standards
define
organization
different
types
document
well
document
format
important
make
easier
check
important
material
omitted
documents
ensure
project
documents
common
look
feel
Standards
developed
process
writing
documents
documents
document
exchange
http
software
engineering
book
com
web
documentation
standards
Software
standards
Software
standards
play
important
role
plan
based
software
quality
management
discussed
important
part
quality
assurance
definition
selection
standards
apply
software
development
process
software
product
part
process
tools
methods
support
use
standards
chosen
standards
selected
use
project
specific
processes
defined
monitor
use
standards
check
followed
Software
standards
important
three
reasons
Standards
capture
wisdom
value
organization
based
knowledge
best
appropriate
practice
company
knowledge
often
acquired
great
deal
trial
error
Building
standard
helps
company
reuse
experience
avoid
previous
mistakes
Standards
provide
framework
defining
quality
means
particular
setting
discussed
software
quality
subjective
using
standards
establish
basis
deciding
required
level
quality
achieved
course
depends
setting
standards
reflect
user
expectations
software
dependability
usability
performance
Standards
assist
continuity
work
carried
one
person
taken
continued
another
Standards
ensure
engineers
organization
adopt
practices
Consequently
learning
effort
required
starting
new
work
reduced
Two
related
types
software
engineering
standard
defined
used
software
quality
management
Product
standards
apply
software
product
developed
include
document
standards
structure
requirements
documents
documentation
standards
standard
comment
header
object
class
definition
coding
standards
define
programming
language
used
@@@@@@@@@@
Product
standards
Process
standards
Product
standards
Process
standards
Design
review
form
Design
review
conduct
Requirements
document
structure
Submission
new
code
system
building
Method
header
format
Version
release
process
Java
programming
style
Project
plan
approval
process
Project
plan
format
Change
control
process
Change
request
form
Test
recording
process
Figure
Product
process
standards
Process
standards
define
processes
followed
software
development
encapsulate
good
development
practice
Process
standards
include
definitions
specification
design
validation
processes
process
support
tools
description
documents
written
processes
Examples
product
process
standards
used
shown
Figure
Standards
deliver
value
form
increased
product
quality
no
point
defining
standards
expensive
terms
time
effort
apply
lead
marginal
improvements
quality
Product
standards
designed
applied
checked
cost
effective
way
process
standards
include
definition
processes
check
product
standards
followed
software
engineering
standards
used
company
usually
adapted
broader
national
international
standards
National
international
standards
developed
covering
software
engineering
terminology
programming
languages
Java
C
notations
charting
symbols
procedures
deriving
writing
software
requirements
quality
assurance
procedures
software
verification
validation
processes
IEEE
specialized
standards
developed
safety
security
critical
systems
Software
engineers
sometimes
consider
standards
overprescriptive
irrelevant
technical
activity
software
development
particularly
likely
project
standards
require
tedious
documentation
work
recording
usually
agree
general
need
standards
engineers
often
find
good
reasons
standards
necessarily
appropriate
particular
project
Quality
managers
set
standards
therefore
consider
possible
actions
convince
engineers
value
standards
Involve
software
engineers
selection
product
standards
developers
understand
standards
selected
likely
committed
standards
Ideally
standards
document
set
standard
followed
include
commentary
explaining
standardization
decisions
made
@@@@@@@@@@
Review
modify
standards
regularly
reflect
changing
technologies
Standards
expensive
develop
tend
enshrined
company
standards
handbook
costs
discussion
required
often
reluctance
change
standards
handbook
essential
evolve
reflect
changing
circumstances
technology
Make
sure
tool
support
available
support
standards
based
development
Developers
often
find
standards
bugbear
conformance
involves
tedious
manual
work
done
software
tool
tool
support
available
standards
followed
without
much
extra
effort
example
program
layout
standards
defined
implemented
syntax
directed
program
editing
system
Different
types
software
need
different
development
processes
standards
adaptable
no
point
prescribing
particular
way
working
inappropriate
project
project
team
project
manager
authority
modify
process
standards
according
individual
circumstances
However
changes
made
important
ensure
changes
lead
loss
product
quality
project
manager
quality
manager
avoid
problems
inappropriate
standards
careful
quality
planning
early
project
decide
organizational
standards
used
without
change
modified
ignored
New
standards
created
response
customer
project
requirements
example
standards
formal
specifications
required
standards
used
previous
projects
ISO
standards
framework
international
set
standards
used
development
quality
management
systems
industries
called
ISO
ISO
standards
applied
range
organizations
manufacturing
service
industries
ISO
general
standards
applies
organizations
design
develop
maintain
products
including
software
ISO
standard
originally
developed
explain
version
standard
standard
change
new
version
scheduled
release
ISO
standard
standard
software
development
rather
framework
developing
software
standards
sets
general
quality
principles
describes
quality
processes
general
lays
organizational
standards
procedures
defined
documented
organizational
quality
manual
major
revision
ISO
standard
reoriented
standard
around
nine
core
processes
Figure
organization
ISO
conformant
document
processes
relate
core
processes
define
maintain
records
demonstrating
defined
organizational
processes
@@@@@@@@@@
Figure
ISO
core
processes
Product
delivery
processes
Business
acquisition
Design
development
TestProduction
delivery
Service
support
Business
management
Inventory
management
Configuration
management
Supplier
management
Supporting
processes
followed
company
quality
manual
describe
relevant
processes
process
data
collected
maintained
ISO
standard
define
prescribe
specific
quality
processes
company
use
conformant
ISO
company
define
types
process
shown
Figure
procedures
place
demonstrating
quality
processes
followed
allows
flexibility
across
industrial
sectors
company
sizes
Quality
standards
defined
appropriate
type
software
developed
Small
companies
simple
processes
without
much
documentation
still
ISO
compliant
However
flexibility
means
cannot
make
assumptions
similarities
differences
processes
different
ISO
compliant
companies
companies
rigid
quality
processes
keep
detailed
records
others
much
less
formal
minimal
additional
documentation
relationships
ISO
organizational
quality
manuals
individual
project
quality
plans
shown
Figure
diagram
adapted
model
given
Ince
Ince
explains
general
ISO
standard
used
basis
software
quality
management
processes
Bamford
Deibler
Bamford
Deibler
explain
later
ISO
standard
applied
software
companies
software
customers
demand
suppliers
ISO
certified
customers
confident
software
development
company
approved
quality
management
system
place
Independent
accreditation
authorities
examine
quality
management
processes
process
documentation
decide
processes
cover
areas
specified
ISO
certify
company
s
quality
processes
defined
quality
manual
conform
ISO
standard
people
mistakenly
think
ISO
certification
means
quality
software
produced
certified
companies
better
@@@@@@@@@@
Project
quality
plan
Project
quality
plan
Project
quality
plan
Project
quality
management
Organization
quality
manual
ISO
quality
models
Organization
quality
process
used
develop
instantiated
instantiated
documents
Figure
ISO
quality
Project
quality
plan
Project
quality
plan
Project
quality
plan
Project
quality
management
Organization
quality
manual
ISO
quality
models
Organization
quality
process
used
develop
instantiated
instantiated
documents
Figure
ISO
quality
Supports
management
uncertified
companies
ISO
standard
focuses
ensuring
organization
quality
management
procedures
place
follows
procedures
no
guarantee
ISO
certified
companies
use
best
software
development
practices
processes
lead
high
quality
software
ISO
certification
inadequate
view
defines
quality
conformance
standards
takes
no
account
quality
experienced
users
software
example
company
define
test
coverage
standards
specifying
methods
objects
called
least
Unfortunately
standard
met
incomplete
software
testing
include
tests
different
method
parameters
long
defined
testing
procedures
followed
test
records
maintained
company
ISO
certified
Reviews
inspections
Reviews
inspections
quality
assurance
activities
check
quality
project
deliverables
involves
checking
software
documentation
records
process
discover
errors
omissions
well
standards
violations
explained
Chapter
reviews
inspections
used
alongside
program
testing
part
general
process
software
verification
validation
review
several
people
examine
software
associated
documentation
looking
potential
problems
nonconformance
standards
review
team
makes
informed
judgments
level
quality
software
project
documents
Project
managers
use
assessments
make
planning
decisions
allocate
resources
development
process
Quality
reviews
based
documents
produced
soft
ware
development
process
well
software
specifications
designs
code
pro
cess
models
test
plans
configuration
management
procedures
process
standards
@@@@@@@@@@
Review
meeting
Individual
preparation
Group
preparation
Planning
Follow
checks
Improvement
Error
correctionReview
meeting
Individual
preparation
Group
preparation
Planning
Follow
checks
Improvement
Error
correction
Figure
software
review
process
Pre
review
activities
Post
review
activities
user
manuals
reviewed
review
check
consistency
completeness
documents
code
review
standards
defined
make
sure
quality
standards
followed
Reviews
checking
conformance
standards
used
help
discover
problems
omissions
software
project
documentation
conclusions
review
formally
recorded
part
quality
management
process
problems
discovered
reviewers
comments
passed
author
software
responsible
correcting
errors
omissions
purpose
reviews
inspections
improve
software
quality
assess
performance
people
development
team
Reviewing
public
process
error
detection
compared
private
component
testing
process
Inevitably
mistakes
made
individuals
revealed
whole
programming
team
ensure
developers
engage
constructively
review
process
project
managers
sensitive
individual
concerns
develop
working
culture
provides
support
without
blame
errors
discovered
Quality
reviews
management
progress
reviews
information
software
quality
used
making
management
decisions
Progress
reviews
compare
actual
progress
software
project
planned
progress
prime
concern
project
deliver
useful
software
time
budget
Progress
reviews
take
external
factors
account
changed
circumstances
mean
software
development
no
longer
required
radically
changed
Projects
developed
high
quality
software
canceled
changes
business
operating
environment
review
process
many
variations
details
reviews
review
processes
Figure
structured
three
phases
Pre
review
activities
preparatory
activities
essential
review
effective
Typically
pre
review
activities
concerned
review
planning
review
preparation
Review
planning
involves
setting
review
team
arranging
time
place
review
distributing
documents
reviewed
review
preparation
team
meet
get
overview
software
reviewed
Individual
review
team
members
read
understand
software
documents
relevant
standards
@@@@@@@@@@
Roles
inspection
process
program
inspection
established
IBM
Fagan
number
formal
roles
defined
members
inspection
team
included
moderator
code
reader
scribe
users
inspections
modified
roles
generally
accepted
inspection
involve
code
author
inspector
scribe
chaired
moderator
http
software
engineering
book
com
web
qm
roles
work
independently
find
errors
omissions
departures
standards
Reviewers
supply
written
comments
software
cannot
attend
review
meeting
review
meeting
review
meeting
author
document
program
reviewed
walk
document
review
team
review
relatively
short
two
hours
One
team
member
chair
review
another
formally
record
review
decisions
actions
taken
review
chair
responsible
ensuring
submitted
comments
considered
review
chair
sign
record
comments
actions
agreed
review
Post
review
activities
review
meeting
ended
issues
problems
raised
review
addressed
Actions
involve
fixing
software
bugs
refactoring
software
conforms
quality
standards
rewriting
documents
Sometimes
problems
discovered
quality
review
management
review
necessary
decide
resources
made
available
correct
changes
made
review
chair
check
review
comments
taken
account
Sometimes
review
required
check
changes
made
cover
previous
review
comments
Review
teams
normally
core
three
four
people
selected
principal
reviewers
One
member
experienced
designer
take
responsibility
making
significant
technical
decisions
principal
reviewers
invite
project
members
designers
related
subsystems
contribute
review
involved
reviewing
whole
document
concentrate
sections
affect
work
Alternatively
review
team
circulate
document
ask
written
comments
broad
spectrum
project
members
project
manager
need
involved
review
unless
problems
anticipated
require
changes
project
plan
processes
suggested
reviews
assume
review
team
face
toface
meeting
discuss
software
documents
reviewing
However
project
teams
now
often
distributed
sometimes
across
countries
continents
impractical
team
members
meet
face
face
Remote
reviewing
supported
using
shared
documents
review
team
member
annotate
document
comments
Face
face
meetings
impossible
@@@@@@@@@@
work
schedules
fact
people
work
different
time
zones
review
chair
responsible
coordinating
comments
discussing
changes
individually
review
team
members
Program
inspections
Program
inspections
peer
reviews
team
members
collaborate
find
bugs
program
developed
discussed
Chapter
inspections
part
software
verification
validation
processes
complement
testing
require
program
executed
Incomplete
versions
system
verified
representations
UML
models
checked
Program
tests
reviewed
Test
reviews
often
find
problems
tests
improve
effectiveness
detecting
program
bugs
Program
inspections
involve
team
members
different
backgrounds
make
careful
line
line
review
program
source
code
look
defects
problems
describe
inspection
meeting
Defects
logical
errors
anomalies
code
indicate
erroneous
condition
features
omitted
code
review
team
examines
design
models
program
code
detail
highlights
anomalies
problems
repair
inspection
checklist
common
programming
errors
often
used
focus
search
bugs
checklist
based
examples
books
knowledge
defects
common
particular
application
domain
use
different
checklists
different
programming
languages
language
characteristic
errors
Humphrey
Humphrey
comprehensive
discussion
inspections
gives
number
examples
inspection
checklists
Possible
checks
made
inspection
process
shown
Figure
Organizations
develop
inspection
checklists
based
local
standards
practices
checklists
regularly
updated
new
types
defects
found
items
checklist
vary
according
programming
language
different
levels
checking
possible
compile
time
example
Java
compiler
checks
functions
correct
number
parameters
C
compiler
Companies
use
inspections
found
effective
finding
bugs
early
work
Fagan
Fagan
reported
errors
program
detected
using
informal
program
inspections
McConnell
McConnell
compares
unit
testing
defect
detection
rate
inspections
defect
detection
rate
comparisons
made
widespread
automated
testing
don
t
know
inspections
compare
approach
spite
well
publicized
cost
effectiveness
many
software
development
companies
reluctant
use
inspections
peer
reviews
Software
engineers
experience
program
testing
sometimes
unwilling
accept
fact
inspections
effective
defect
detection
testing
Managers
suspicious
inspections
require
additional
costs
design
development
want
take
risk
no
corresponding
savings
program
testing
costs
@@@@@@@@@@
Fault
class
Inspection
check
Fault
class
Inspection
check
Data
faults
program
variables
initialized
values
used
constants
named
upper
bound
arrays
equal
size
array
Size
character
strings
used
delimiter
explicitly
assigned
possibility
buffer
overflow
Control
faults
conditional
statement
condition
correct
loop
certain
terminate
compound
statements
correctly
bracketed
case
statements
possible
cases
accounted
break
required
case
case
statements
included
Input
output
faults
input
variables
used
output
variables
assigned
value
output
unexpected
inputs
cause
corruption
Interface
faults
function
method
calls
correct
number
parameters
formal
actual
parameter
types
match
parameters
right
order
components
access
shared
memory
model
shared
memory
structure
Storage
management
faults
linked
structure
modified
links
correctly
reassigned
dynamic
storage
used
space
allocated
correctly
space
explicitly
de
allocated
no
longer
required
Exception
management
faults
possible
error
conditions
taken
account
Figure
inspection
checklist
Quality
management
agile
development
Agile
methods
software
engineering
focus
development
code
minimize
documentation
processes
directly
concerned
code
development
emphasize
importance
informal
communications
among
team
members
rather
communications
based
project
documents
Quality
agile
development
means
code
quality
practices
refactoring
test
driven
development
used
ensure
high
quality
code
produced
Quality
management
agile
development
informal
rather
document
based
relies
establishing
quality
culture
team
members
feel
responsible
software
quality
take
actions
ensure
quality
maintained
agile
community
fundamentally
opposed
sees
bureaucratic
overhead
standards
based
approaches
quality
processes
embodied
ISO
Companies
use
agile
development
methods
rarely
concerned
ISO
certification
agile
development
quality
management
based
shared
good
practice
rather
formal
documentation
examples
good
practice
Check
check
Programmers
responsible
organizing
code
reviews
team
members
code
checked
build
system
@@@@@@@@@@
Never
break
build
acceptable
team
members
check
code
causes
system
whole
fail
Therefore
individuals
test
code
changes
whole
system
confident
codes
work
expected
build
broken
person
responsible
expected
give
top
priority
fixing
problem
Fix
problems
see
code
system
belongs
team
rather
individuals
Therefore
programmer
discovers
problems
obscurities
code
developed
someone
fix
problems
directly
rather
referring
back
original
developer
Agile
processes
rarely
use
formal
inspection
review
processes
Scrum
development
team
meets
iteration
discuss
quality
issues
problems
team
decide
changes
way
work
avoid
quality
problems
emerged
collective
decision
made
focus
refactoring
quality
improvement
sprint
rather
addition
new
system
functionality
Code
reviews
responsibility
individuals
check
check
rely
use
pair
programming
discussed
Chapter
pair
programming
approach
two
people
responsible
code
development
work
together
achieve
Code
developed
individual
therefore
constantly
examined
reviewed
another
team
member
Two
people
look
every
line
code
check
accepted
Pair
programming
leads
deep
knowledge
program
programmers
understand
program
detail
continue
development
depth
knowledge
sometimes
difficult
achieve
inspection
processes
pair
programming
find
bugs
sometimes
discovered
formal
inspections
However
two
people
involved
cannot
objective
external
inspection
team
inasmuch
examining
work
Potential
problems
Mutual
misunderstandings
members
pair
make
mistake
understanding
system
requirements
Discussions
reinforce
errors
Pair
reputation
Pairs
reluctant
look
errors
want
slow
progress
project
Working
relationships
pair
s
ability
discover
defects
likely
compromised
close
working
relationship
often
leads
reluctance
criticize
work
partners
informal
approach
quality
management
adopted
agile
methods
particularly
effective
software
product
development
company
developing
software
controls
specification
no
need
deliver
quality
reports
external
customer
need
integrate
quality
management
teams
However
large
system
developed
@@@@@@@@@@
external
customer
agile
approaches
quality
management
minimal
documentation
impractical
customer
large
company
quality
management
processes
expect
software
development
company
report
progress
way
compatible
processes
Therefore
development
team
produce
formal
quality
plan
quality
reports
required
customer
several
geographically
distributed
teams
involved
development
perhaps
different
companies
informal
communications
impractical
Different
companies
different
approaches
quality
management
agree
produce
formal
documentation
long
lifetime
systems
team
involved
development
change
time
no
documentation
new
team
members
find
impossible
understand
development
decisions
made
Consequently
informal
approach
quality
management
agile
methods
adapted
quality
documentation
processes
introduced
Generally
approach
integrated
iterative
development
process
Instead
developing
software
one
sprints
iterations
focus
producing
essential
software
documentation
Software
measurement
Software
measurement
concerned
quantifying
attribute
software
system
complexity
reliability
comparing
measured
values
standards
apply
across
organization
able
draw
conclusions
quality
software
assess
effectiveness
software
processes
tools
methods
ideal
world
quality
management
rely
measurements
attributes
affect
software
quality
objectively
assess
process
tool
changes
aim
improve
software
quality
example
say
work
company
plans
introduce
new
software
testing
tool
introducing
tool
record
number
software
defects
discovered
given
time
baseline
assessing
effectiveness
tool
using
tool
time
repeat
process
defects
found
amount
time
tool
introduced
decide
provides
useful
support
software
validation
process
long
term
goal
software
measurement
use
measurement
make
judgments
software
quality
Ideally
system
assessed
using
range
metrics
measure
attributes
measurements
made
value
quality
system
inferred
software
reached
required
quality
threshold
approved
without
review
appropriate
measurement
tools
highlight
areas
software
improved
@@@@@@@@@@
Management
decisions
Control
metric
measurements
Software
process
Predictor
metric
measurements
Software
product
Management
decisions
Control
metric
measurements
Software
process
Predictor
metric
measurements
Software
product
Figure
Predictor
control
measurements
However
still
long
way
ideal
situation
automated
quality
assessment
unlikely
reality
near
future
software
metric
characteristic
software
system
system
documentation
development
process
objectively
measured
Examples
metrics
include
size
product
lines
code
Fog
index
measure
readability
narrative
text
number
reported
faults
delivered
software
product
number
person
days
required
develop
system
component
Software
metrics
control
metrics
predictor
metrics
names
imply
control
metrics
support
process
management
predictor
metrics
help
predict
characteristics
software
Control
metrics
usually
associated
software
processes
Examples
control
process
metrics
average
effort
time
required
repair
reported
defects
Three
kinds
process
metrics
used
time
taken
particular
process
completed
total
time
devoted
process
calendar
time
time
spent
process
particular
engineers
resources
required
particular
process
Resources
include
total
effort
person
days
travel
costs
computer
resources
number
occurrences
particular
event
Examples
events
monitored
include
number
defects
discovered
code
inspection
number
requirements
changes
requested
number
bug
reports
delivered
system
average
number
lines
code
modified
response
requirements
change
Predictor
metrics
sometimes
called
product
metrics
associated
software
Examples
predictor
metrics
cyclomatic
complexity
module
average
length
identifiers
program
number
attributes
operations
associated
object
classes
design
control
predictor
metrics
influence
management
decision
making
shown
Figure
Managers
use
process
measurements
decide
process
changes
made
predictor
metrics
decide
software
changes
necessary
software
ready
release
@@@@@@@@@@
External
quality
attributes
Internal
attributes
Reliability
Maintainability
Usability
Reusability
Depth
inheritance
tree
Cyclomatic
complexity
Program
size
lines
code
Number
error
messages
Length
user
manual
Figure
Relationships
internal
external
software
attributes
chapter
focus
predictor
metrics
values
automatically
assessed
analyzing
code
documents
discuss
control
metrics
used
process
improvement
web
Chapter
Measurements
software
system
used
two
ways
assign
value
system
quality
attributes
measuring
characteristics
system
components
aggregating
measurements
able
assess
system
quality
attributes
maintainability
identify
system
components
quality
substandard
Measurements
identify
individual
components
characteristics
deviate
norm
example
measure
components
discover
highest
complexity
components
likely
contain
bugs
complexity
makes
likely
component
developer
made
mistakes
difficult
make
direct
measurements
many
software
quality
attributes
shown
Figure
Quality
attributes
maintainability
understandability
usability
external
attributes
relate
developers
users
experience
software
affected
subjective
factors
user
experience
education
cannot
therefore
measured
objectively
make
judgment
attributes
measure
internal
attributes
software
size
complexity
assume
related
quality
characteristics
concerned
Figure
shows
external
software
quality
attributes
internal
attributes
intuitively
related
diagram
suggests
relationships
external
internal
attributes
say
attributes
related
Kitchenham
Kitchenham
suggested
measure
internal
attribute
useful
predictor
external
software
characteristic
three
conditions
hold
@@@@@@@@@@
internal
attribute
measured
accurately
However
measurement
straightforward
require
specially
developed
tools
relationship
exist
attribute
measured
external
quality
attribute
interest
value
quality
attribute
related
way
value
attribute
measured
relationship
internal
external
attributes
understood
validated
expressed
terms
formula
model
Model
formulation
involves
identifying
functional
form
model
linear
exponential
etc
analysis
collected
data
identifying
parameters
included
model
calibrating
parameters
using
existing
data
Recent
work
area
software
analytics
Zhang
et
al
used
data
mining
machine
learning
techniques
analyze
repositories
software
product
process
data
idea
behind
software
analytics
Menzies
Zimmermann
fact
need
model
reflects
relationships
software
quality
collected
data
Rather
enough
data
correlations
discovered
predictions
made
software
attributes
discuss
software
analytics
Section
little
published
information
systematic
software
measurement
industry
Many
companies
collect
information
software
number
requirements
change
requests
number
defects
discovered
testing
However
clear
use
measurements
systematically
compare
software
products
processes
assess
impact
changes
software
processes
tools
several
reasons
difficult
impossible
quantify
return
investment
introducing
organizational
metrics
software
analytics
program
seen
significant
improvements
software
quality
past
years
without
use
metrics
difficult
justify
initial
costs
introducing
systematic
software
measurement
assessment
no
standards
software
metrics
standardized
processes
measurement
analysis
Many
companies
reluctant
introduce
measurement
programs
standards
supporting
tools
available
Measurement
require
development
maintenance
specialized
software
tools
difficult
justify
costs
tool
development
returns
measurement
unknown
many
companies
software
processes
standardized
poorly
defined
controlled
much
process
variability
company
measurements
used
meaningful
way
Much
research
software
measurement
metrics
focused
code
based
metrics
plan
driven
development
processes
However
software
now
developed
reusing
configuring
existing
application
@@@@@@@@@@
systems
using
agile
methods
don
t
know
previous
research
metrics
applies
software
development
techniques
Introducing
measurement
adds
overhead
processes
contradicts
aims
agile
methods
recommend
elimination
process
activities
directly
related
program
development
Companies
adopted
agile
methods
therefore
likely
adopt
metrics
program
Software
measurement
metrics
basis
empirical
software
engineering
research
area
experiments
software
systems
collection
data
real
projects
used
form
validate
hypotheses
software
engineering
methods
techniques
Researchers
working
area
argue
confident
value
software
engineering
methods
techniques
provide
concrete
evidence
provide
benefits
inventors
suggest
However
research
empirical
software
engineering
significant
impact
software
engineering
practice
difficult
relate
generic
research
individual
project
differs
research
study
Many
local
factors
likely
important
general
empirical
results
reason
researchers
software
analytics
argue
analysts
try
draw
general
conclusions
provide
analyses
data
specific
systems
Product
metrics
Product
metrics
predictor
metrics
used
quantify
internal
attributes
software
system
Examples
product
metrics
include
system
size
measured
lines
code
number
methods
associated
object
class
Unfortunately
explained
earlier
section
software
characteristics
easily
measured
size
cyclomatic
complexity
clear
consistent
relationship
quality
attributes
understandability
maintainability
relationships
vary
depending
development
processes
technology
used
type
system
developed
Product
metrics
fall
two
classes
Dynamic
metrics
collected
measurements
made
program
execution
metrics
collected
system
testing
system
gone
use
example
number
bug
reports
time
taken
complete
computation
Static
metrics
collected
measurements
made
representations
system
design
program
documentation
Examples
static
metrics
shown
Figure
types
metrics
related
different
quality
attributes
Dynamic
metrics
help
assess
efficiency
reliability
system
Static
metrics
help
assess
complexity
understandability
maintainability
system
components
@@@@@@@@@@
Software
metric
Description
Software
metric
Description
Fan
Fan
Length
code
Cyclomatic
complexity
Length
identifiers
Depth
conditional
nesting
measure
depth
nesting
statements
program
Deeply
nested
statements
hard
understand
potentially
error
prone
Fog
index
Figure
Static
software
product
metrics
Fan
measure
number
functions
methods
call
another
function
method
say
X
Fan
number
functions
called
function
X
high
value
fan
means
X
tightly
coupled
rest
design
changes
X
extensive
knock
effects
high
value
fan
suggests
overall
complexity
X
high
complexity
control
logic
needed
coordinate
called
components
measure
size
program
Generally
larger
size
code
component
complex
error
prone
component
likely
Length
code
shown
one
reliable
metrics
predicting
error
proneness
components
measure
control
complexity
program
control
complexity
related
program
understandability
discuss
cyclomatic
complexity
Chapter
measure
average
length
identifiers
names
variables
classes
methods
etc
program
longer
identifiers
likely
meaningful
understandable
program
measure
average
length
words
sentences
documents
higher
value
document
s
Fog
index
difficult
document
understand
clear
relationship
usually
exists
dynamic
metrics
software
quality
characteristics
fairly
easy
measure
execution
time
required
particular
functions
assess
time
required
start
system
functions
relate
directly
system
s
efficiency
Similarly
number
system
failures
type
failure
logged
related
directly
reliability
software
explained
reliability
measured
Chapter
Static
metrics
shown
Figure
indirect
relationship
quality
attributes
large
number
different
metrics
proposed
many
experiments
tried
derive
validate
relationships
metrics
attributes
system
complexity
maintainability
None
experiments
conclusive
program
size
control
complexity
appear
reliable
predictors
understandability
system
complexity
maintainability
metrics
Figure
applicable
program
specific
object
oriented
metrics
proposed
Figure
summarizes
Chidamber
Kemerer
s
suite
sometimes
called
CK
suite
six
object
oriented
metrics
Chidamber
Kemerer
metrics
originally
proposed
early
s
still
widely
used
object
oriented
OO
metrics
UML
design
tools
automatically
collect
values
metrics
UML
diagrams
created
El
Amam
s
review
object
oriented
metrics
discussed
CK
metrics
OO
metrics
El
Amam
concluded
insufficient
evidence
understand
object
oriented
metrics
relate
external
software
@@@@@@@@@@
Object
oriented
metric
Description
Object
oriented
metric
Description
Weighted
methods
per
class
WMC
qualities
situation
really
changed
since
analysis
still
don
t
know
use
measurements
object
oriented
programs
draw
reliable
conclusions
quality
Depth
inheritance
tree
DIT
Number
children
NOC
Coupling
object
classes
CBO
Response
class
RFC
Lack
cohesion
methods
LCOM
Figure
CK
object
oriented
metrics
suite
Software
component
analysis
number
methods
class
weighted
complexity
method
Therefore
simple
method
complexity
large
complex
method
much
higher
value
larger
value
metric
complex
object
class
Complex
objects
likely
difficult
understand
logically
cohesive
cannot
reused
effectively
superclasses
inheritance
tree
represents
number
discrete
levels
inheritance
tree
subclasses
inherit
attributes
operations
methods
superclasses
deeper
inheritance
tree
complex
design
Many
object
classes
understood
understand
object
classes
leaves
tree
measure
number
immediate
subclasses
class
measures
breadth
class
hierarchy
DIT
measures
depth
high
value
NOC
indicate
greater
reuse
mean
effort
made
validating
base
classes
number
subclasses
depend
Classes
coupled
methods
one
class
use
methods
instance
variables
defined
different
class
CBO
measure
much
coupling
exists
high
value
CBO
means
classes
highly
dependent
Therefore
likely
changing
one
class
affect
classes
program
RFC
measure
number
methods
potentially
executed
response
message
received
object
class
RFC
related
complexity
higher
value
RFC
complex
class
likely
include
errors
LCOM
calculated
considering
pairs
methods
class
LCOM
difference
number
method
pairs
without
shared
attributes
number
method
pairs
shared
attributes
value
metric
widely
debated
exists
several
variations
clear
really
adds
additional
useful
information
provided
metrics
measurement
process
part
software
quality
assessment
process
shown
Figure
system
component
analyzed
separately
using
range
metrics
values
metrics
compared
different
components
perhaps
historical
measurement
data
collected
previous
projects
Anomalous
measurements
deviate
significantly
norm
usually
indicate
problems
quality
components
key
stages
component
measurement
process
Choose
measurements
made
questions
measurement
intended
answer
formulated
measurements
required
@@@@@@@@@@
Measure
component
characteristics
Identify
anomalous
measurements
Analyze
anomalous
components
Select
components
assessed
Choose
measurements
made
Figure
process
product
measurement
Measure
component
characteristics
Identify
anomalous
measurements
Analyze
anomalous
components
Select
components
assessed
Choose
measurements
made
Figure
process
product
measurement
answer
questions
defined
Measurements
directly
relevant
questions
need
collected
Select
components
assessed
need
assess
metric
values
components
software
system
Sometimes
select
representative
selection
components
measurement
allowing
make
overall
assessment
system
quality
times
wish
focus
core
components
system
constant
use
quality
components
important
quality
components
infrequently
executed
Measure
component
characteristics
selected
components
measured
associated
metric
values
computed
step
normally
involves
processing
component
representation
design
code
etc
using
automated
data
collection
tool
tool
specially
written
feature
design
tools
already
use
Identify
anomalous
measurements
component
measurements
made
compare
previous
measurements
recorded
measurement
database
look
unusually
high
low
values
metric
suggest
problems
component
exhibiting
values
Analyze
anomalous
components
identified
components
anomalous
values
chosen
metrics
examine
decide
anomalous
metric
values
mean
quality
component
compromised
anomalous
metric
value
complexity
say
necessarily
mean
poor
quality
component
reason
high
value
component
quality
problems
possible
maintain
collected
data
organizational
resource
keep
historical
records
projects
even
data
used
particular
project
sufficiently
large
measurement
database
established
make
comparisons
software
quality
across
projects
validate
relations
internal
component
attributes
quality
characteristics
@@@@@@@@@@
Measurement
ambiguity
collect
quantitative
data
software
software
processes
analyze
data
understand
meaning
easy
misinterpret
data
make
incorrect
inferences
cannot
simply
look
data
consider
context
data
collected
illustrate
collected
data
interpreted
different
ways
consider
following
scenario
concerned
number
change
requests
made
system
s
users
manager
decides
measure
number
change
requests
submitted
customers
based
assumption
relationship
change
requests
product
usability
suitability
assumes
higher
number
change
requests
less
software
meets
needs
customer
Handling
change
requests
changing
software
expensive
organization
therefore
decides
modify
process
aim
improving
customer
satisfaction
time
reducing
costs
making
changes
intent
process
changes
result
better
products
fewer
change
requests
Processes
changed
increase
customer
involvement
software
design
process
Beta
testing
products
introduced
customer
requested
modifications
incorporated
delivered
product
process
changes
made
measurement
change
requests
continues
New
versions
products
developed
modified
process
delivered
cases
number
change
requests
reduced
others
increased
manager
baffled
finds
impossible
understand
effects
process
changes
product
quality
understand
kind
ambiguity
occur
understand
users
make
change
requests
software
good
enough
customers
want
therefore
request
changes
deliver
functionality
require
Alternatively
software
good
widely
heavily
used
Change
requests
generated
many
software
users
creatively
think
new
things
done
software
Increasing
customer
s
involvement
process
reduce
number
change
requests
products
customers
unhappy
process
changes
effective
made
software
usable
suitable
Alternatively
however
process
changes
worked
customers
decided
look
alternative
system
number
change
requests
decrease
product
lost
market
share
rival
product
consequently
fewer
product
users
@@@@@@@@@@
hand
process
changes
lead
many
new
happy
customers
wish
participate
product
development
process
therefore
generate
change
requests
Changes
process
handling
change
requests
contribute
increase
company
responsive
customers
generate
change
requests
know
requests
taken
seriously
believe
suggestions
probably
incorporated
later
versions
software
Alternatively
number
change
requests
increased
beta
test
sites
typical
usage
program
analyze
change
request
data
simply
need
know
number
change
requests
need
know
made
request
software
used
request
made
need
information
external
factors
modifications
change
request
procedure
market
changes
effect
information
better
position
find
process
changes
effective
increasing
product
quality
illustrates
difficulties
understanding
effects
changes
scientific
approach
problem
reduce
number
factors
affect
measurements
made
However
processes
products
measured
insulated
environment
business
environment
constantly
changing
impossible
avoid
changes
work
practice
make
comparisons
data
invalid
quantitative
data
human
activities
cannot
taken
face
value
reasons
measured
value
changes
often
ambiguous
reasons
investigated
detail
conclusions
drawn
measurements
Software
analytics
past
years
notion
big
data
analysis
emerged
means
discovering
insights
automatically
mining
analyzing
large
volumes
automatically
collected
data
possible
discover
relationships
data
items
found
manual
data
analysis
modeling
Software
analytics
application
techniques
data
software
software
processes
Two
factors
made
software
analytics
possible
automated
collection
user
data
software
product
companies
product
used
software
fails
information
failure
state
system
sent
Internet
user
s
computer
servers
run
product
developer
result
large
volumes
data
individual
products
Internet
Explorer
Photoshop
available
analysis
use
open
source
software
available
platforms
Sourceforge
GitHub
open
source
repositories
software
engineering
data
Menzies
Zimmermann
source
code
open
source
software
available
automated
analysis
sometimes
linked
data
open
source
repository
@@@@@@@@@@
Menzies
Zimmerman
Menzies
Zimmermann
define
software
analytics
Software
analytics
analytics
software
data
managers
software
engineers
aim
empowering
software
development
individuals
teams
gain
share
insight
data
make
better
decisions
Menzies
Zimmermann
emphasize
point
analytics
derive
general
theories
software
identify
specific
issues
interest
software
developers
managers
Analytics
aims
provide
information
issues
real
time
actions
taken
response
information
provided
analysis
study
managers
Microsoft
Buse
Zimmermann
Buse
Zimmermann
identified
information
needs
target
testing
inspections
refactoring
release
software
understand
needs
software
customers
range
different
data
mining
analysis
tools
used
software
analytics
Witten
Frank
Hall
general
impossible
know
best
analysis
tools
use
particular
situation
experiment
several
tools
discover
effective
Buse
Zimmerman
suggest
number
guidelines
tool
use
Tools
easy
use
managers
unlikely
experience
analysis
Tools
run
quickly
produce
concise
outputs
rather
large
volumes
information
Tools
make
many
measurements
using
many
parameters
possible
impossible
predict
advance
insights
emerge
Tools
interactive
allow
managers
developers
explore
analyses
recognize
managers
developers
interested
different
things
predictive
support
decision
making
based
analysis
past
current
data
Zhang
colleagues
Zhang
et
al
describe
excellent
practical
application
software
analytics
performance
debugging
User
software
instrumented
collect
data
response
times
associated
system
state
response
time
greater
expected
data
sent
analysis
automated
analysis
highlighted
performance
bottlenecks
software
development
team
improve
algorithms
eliminate
bottleneck
performance
improved
later
software
release
time
writing
software
analytics
immature
early
say
effect
general
problems
big
data
processing
Harford
case
knowledge
depends
collected
data
large
companies
data
primarily
software
products
unclear
tools
techniques
appropriate
products
used
custom
software
Small
companies
unlikely
invest
data
collection
systems
required
automated
analysis
able
use
software
analytics
@@@@@@@@@@
Chapter
Reading
Key
Points
Software
quality
management
concerned
ensuring
software
low
number
defects
reaches
required
standards
maintainability
reliability
portability
forth
includes
defining
standards
processes
products
establishing
processes
check
standards
followed
Software
standards
important
quality
assurance
represent
identification
best
practice
developing
software
standards
provide
solid
foundation
building
good
quality
software
Reviews
software
process
deliverables
involve
team
people
check
quality
standards
followed
Reviews
widely
used
technique
assessing
quality
program
inspection
peer
review
small
team
systematically
checks
code
read
code
detail
look
possible
errors
omissions
problems
detected
discussed
code
review
meeting
Agile
quality
management
usually
rely
separate
quality
management
team
Instead
relies
establishing
quality
culture
development
team
works
together
improve
software
quality
Software
measurement
used
gather
quantitative
data
software
software
process
able
use
values
software
metrics
collected
make
inferences
product
process
quality
Product
quality
metrics
particularly
useful
highlighting
anomalous
components
quality
problems
components
analyzed
detail
Software
analytics
automated
analysis
large
volumes
software
product
process
data
discover
relationships
provide
insights
project
managers
developers
Reading
Software
Quality
Assurance
Theory
Implementation
excellent
still
relevant
book
principles
practice
software
quality
assurance
includes
discussion
standards
ISO
D
Galin
Addison
Wesley
Misleading
Metrics
Unsound
Analyses
excellent
article
leading
metrics
researchers
discusses
difficulties
understanding
measurements
really
mean
B
Kitchenham
R
Jeffrey
C
Connaughton
IEEE
Software
March
April
http
dx
doi
org
MS
Practical
Guide
Implementing
Agile
QA
Process
Scrum
Projects
slide
set
presents
overview
integrate
software
quality
assurance
agile
development
using
Scrum
S
Rayhan
https
www
scrumalliance
org
system
resource
files
agileqa
pdf
Software
Analytics
good
introductory
article
explains
software
analytics
increasingly
important
introduction
special
issue
software
analytics
find
several
articles
issue
helpful
understanding
software
analytics
T
Menzies
T
Zimmermann
IEEE
Software
July
August
http
dx
doi
org
MS
@@@@@@@@@@
Chapter
Quality
management
WebSite
PowerPoint
slides
chapter
www
pearsonglobaleditions
com
Sommerville
Links
supporting
videos
http
software
engineering
book
com
videos
software
management
exeRCiSeS
Define
terms
quality
assurance
quality
control
List
key
points
included
Humphrey
s
outline
structure
software
management
Explain
standards
used
capture
organizational
wisdom
effective
methods
software
development
Suggest
four
types
knowledge
captured
organizational
standards
Discuss
assessment
software
quality
according
quality
attributes
shown
Figure
consider
attribute
turn
explain
assessed
Briefly
describe
possible
standards
used
use
control
constructs
C
C
Java
reports
submitted
term
project
university
process
making
approving
program
changes
web
Chapter
process
purchasing
installing
new
computer
Assume
work
organization
develops
database
products
individuals
small
businesses
organization
interested
quantifying
software
development
Write
report
suggesting
appropriate
metrics
suggest
collected
Briefly
explain
happens
software
quality
review
process
software
quality
inspection
process
problems
likely
arise
formalized
program
inspections
introduced
company
software
developed
using
agile
methods
software
metric
Define
different
types
software
metrics
examples
work
software
product
company
manager
read
article
software
analytics
asks
research
area
Survey
literature
analytics
write
short
report
summarizes
work
software
analytics
issues
considered
analytics
introduced
colleague
good
programmer
produces
software
low
number
defects
consistently
ignores
organizational
quality
standards
managers
react
behavior
@@@@@@@@@@
Chapter
References
ReFeRenCeS
Bamford
R
W
J
Deibler
ISO
Software
Systems
Providers
Engi
neering
Approach
Boca
Raton
FL
CRC
Press
Buse
R
P
L
T
Zimmermann
Information
Needs
Software
Development
Analytics
Int
Conf
Software
Engineering
doi
ICSE
Chidamber
S
C
Kemerer
Metrics
Suite
Object
Oriented
Design
IEEE
Trans
Software
Eng
doi
El
Amam
K
Object
Oriented
Metrics
Review
Theory
Practice
National
Research
Council
Canada
http
seg
iit
nrc
ca
English
abstracts
NRC
html
Fagan
M
E
Advances
Software
Inspections
IEEE
Trans
Software
Eng
SE
doi
TSE
Harford
T
Big
Data
Making
Big
Mistake
Financial
Times
March
http
timharford
com
big
data
making
big
mistake
Humphrey
W
Managing
Software
Process
Reading
MA
Addison
Wesley
IEEE
IEEE
Software
Engineering
Standards
Collection
CD
ROM
Los
Alamitos
CA
IEEE
Computer
Society
Press
Ince
D
ISO
Software
Quality
Assurance
London
McGraw
Hill
Kitchenham
B
Software
Development
Cost
Models
Software
Reliability
Handbook
edited
P
Rook
Amsterdam
Elsevier
McConnell
S
Code
Complete
Practical
Handbook
Software
Construction
nd
ed
Seattle
WA
Microsoft
Press
Menzies
T
T
Zimmermann
Software
Analytics
IEEE
Software
doi
MS
Witten
H
E
Frank
M
Hall
Data
Mining
Practical
Machine
Learning
Tools
Techniques
Burlington
MA
Morgan
Kaufmann
Zhang
D
S
Han
Y
Dang
J
G
Lou
H
Zhang
T
Xie
Software
Analytics
Practice
IEEE
Software
doi
MS
@@@@@@@@@@
Configuration
management
Objectives
objective
chapter
introduce
software
configuration
management
processes
tools
read
chapter
know
essential
functionality
provided
version
control
system
realized
centralized
distributed
systems
understand
challenges
system
building
benefits
continuous
integration
system
building
understand
software
change
management
important
essential
activities
change
management
process
understand
basics
software
release
management
differs
version
management
Contents
Version
management
System
building
Change
management
Release
management
@@@@@@@@@@
Chapter
Configuration
management
Software
systems
constantly
changing
development
use
Bugs
discovered
fixed
System
requirements
change
implement
changes
new
version
system
New
versions
hardware
system
platforms
released
adapt
systems
work
Competitors
introduce
new
features
system
match
changes
made
software
new
version
system
created
systems
therefore
thought
set
versions
maintained
managed
Configuration
management
CM
concerned
policies
processes
tools
managing
changing
software
systems
Aiello
Sachs
need
manage
evolving
systems
easy
lose
track
changes
component
versions
incorporated
system
version
Versions
implement
proposals
change
corrections
faults
adaptations
different
hardware
operating
systems
Several
versions
development
use
time
don
t
effective
configuration
management
procedures
place
waste
effort
modifying
wrong
version
system
delivering
wrong
version
system
customers
forgetting
software
source
code
particular
version
system
component
stored
Configuration
management
useful
individual
projects
easy
one
person
forget
changes
made
essential
team
projects
several
developers
working
time
software
system
Sometimes
developers
working
place
increasingly
development
teams
distributed
members
different
locations
across
world
configuration
management
system
provides
team
members
access
system
developed
manages
changes
make
code
configuration
management
software
system
product
involves
four
closely
related
activities
Figure
Version
control
involves
keeping
track
multiple
versions
system
components
ensuring
changes
made
components
different
developers
interfere
System
building
process
assembling
program
components
data
libraries
compiling
linking
create
executable
system
Change
management
involves
keeping
track
requests
changes
delivered
software
customers
developers
working
costs
impact
making
changes
deciding
changes
implemented
Release
management
involves
preparing
software
external
release
keeping
track
system
versions
released
customer
use
large
volume
information
managed
relationships
configuration
items
tool
support
essential
configuration
management
Configuration
management
tools
used
store
versions
system
components
build
systems
components
track
releases
system
versions
@@@@@@@@@@
Chapter
Configuration
management
ComponentversionsReleasemanagementChangeproposalsSystemreleasesChangemanagementSystemversionsVersionmanagementSystembuildingFigure
Configuration
management
activities
customers
keep
track
change
proposals
CM
tools
range
simple
tools
support
single
configuration
management
task
bug
tracking
integrated
environments
support
configuration
management
activities
Agile
development
components
systems
changed
several
times
day
impossible
without
using
CM
tools
definitive
versions
components
held
shared
project
repository
developers
copy
workspace
make
changes
code
use
system
building
tools
create
new
system
computer
testing
happy
changes
made
return
modified
components
project
repository
makes
modified
components
available
team
members
development
software
product
custom
software
system
takes
place
three
distinct
phases
development
phase
development
team
responsible
managing
software
configuration
new
functionality
added
software
development
team
decides
changes
made
system
system
testing
phase
version
system
released
internally
testing
responsibility
quality
management
team
individual
group
development
team
stage
no
new
functionality
added
system
changes
made
stage
bug
fixes
performance
improvements
security
vulnerability
repairs
customer
involvement
beta
testers
phase
release
phase
software
released
customers
use
release
distributed
customers
submit
bug
reports
change
requests
New
versions
released
system
developed
repair
bugs
vulnerabilities
include
new
features
suggested
customers
large
systems
never
one
working
version
system
several
versions
system
different
stages
development
Several
@@@@@@@@@@
Chapter
Configuration
management
Releases
Development
Pre
release
versions
versions
R
R
Version
V
V
V
V
V
V
Version
Version
V
V
V
V
Figure
Multiversion
system
development
teams
involved
development
different
system
versions
Figure
shows
situations
three
versions
system
developed
Version
system
developed
repair
bug
fixes
improve
performance
first
release
system
basis
second
system
release
R
Version
tested
view
becoming
release
system
No
new
features
added
stage
Version
development
system
new
features
added
response
change
requests
customers
development
team
eventually
released
release
different
versions
many
common
components
well
components
component
versions
unique
system
version
CM
system
keeps
track
components
part
version
includes
required
system
build
large
software
projects
configuration
management
sometimes
part
software
quality
management
covered
Chapter
quality
manager
responsible
quality
management
configuration
management
pre
release
version
software
ready
development
team
hands
quality
management
team
QM
team
checks
system
quality
acceptable
becomes
controlled
system
means
changes
system
agreed
recorded
implemented
Many
specialized
terms
used
configuration
management
Unfortunately
standardized
Military
software
systems
first
systems
software
CM
used
terminology
systems
reflected
processes
terminology
used
hardware
configuration
management
Commercial
systems
developers
know
military
procedures
terminology
often
invented
terms
Agile
methods
devised
new
terminology
order
distinguish
agile
approach
traditional
CM
methods
@@@@@@@@@@
Chapter
Configuration
management
Term
Explanation
Baseline
collection
component
versions
make
system
Baselines
controlled
means
component
versions
used
baseline
cannot
changed
possible
re
create
baseline
constituent
components
Branching
creation
new
codeline
version
existing
codeline
new
codeline
existing
codeline
develop
independently
Codeline
set
versions
software
component
configuration
items
component
depends
Configuration
version
control
process
ensuring
versions
systems
components
recorded
maintained
changes
managed
versions
components
identified
stored
lifetime
system
Configuration
item
software
configuration
item
SCI
Anything
associated
software
project
design
code
test
data
document
etc
placed
configuration
control
Configuration
items
unique
identifier
Mainline
sequence
baselines
representing
different
versions
system
Merging
creation
new
version
software
component
merging
separate
versions
different
codelines
codelines
created
previous
branch
one
codelines
involved
Release
version
system
released
customers
users
organization
use
Repository
shared
database
versions
software
components
meta
information
changes
components
System
building
creation
executable
system
version
compiling
linking
appropriate
versions
components
libraries
making
system
Version
instance
configuration
item
differs
way
instances
item
Versions
unique
identifier
Workspace
private
work
area
software
modified
without
affecting
developers
using
modifying
software
Figure
CM
terminology
definition
use
configuration
management
standards
essential
quality
certification
ISO
SEI
s
capability
maturity
model
Bamford
Deibler
Chrissis
Konrad
Shrum
CM
standards
company
based
generic
standards
IEEE
IEEE
standard
configuration
management
standards
focus
CM
processes
documents
produced
CM
process
IEEE
Using
external
standards
starting
point
companies
develop
detailed
company
specific
standards
tailored
specific
needs
However
agile
methods
rarely
use
standards
documentation
overhead
involved
@@@@@@@@@@
Version
management
Version
management
Version
management
process
keeping
track
different
versions
software
components
systems
components
used
involves
ensuring
changes
made
different
developers
versions
interfere
words
version
management
process
managing
code
lines
baselines
Figure
illustrates
differences
codelines
baselines
codeline
sequence
versions
source
code
later
versions
sequence
derived
earlier
versions
Codelines
normally
apply
components
systems
different
versions
component
baseline
definition
specific
system
baseline
specifies
component
versions
included
system
identifies
libraries
used
configuration
files
system
information
Figure
see
different
baselines
use
different
versions
components
code
line
diagram
shaded
boxes
representing
components
baseline
definition
indicate
references
components
codeline
mainline
sequence
system
versions
developed
original
baseline
Baselines
specified
using
configuration
language
define
components
included
specific
version
system
possible
explicitly
specify
individual
component
version
X
say
simply
specify
component
identifier
X
simply
include
component
identifier
configuration
description
recent
version
component
used
Baselines
important
often
re
create
individual
version
system
example
product
line
instantiated
specific
system
versions
system
customer
re
create
version
delivered
customer
report
bugs
system
repaired
Version
control
VC
systems
identify
store
control
access
different
versions
components
two
types
modern
version
control
system
Centralized
systems
single
master
repository
maintains
versions
software
components
developed
Subversion
Pilato
Collins
Sussman
Fitzpatrick
widely
used
example
centralized
VC
system
Distributed
systems
multiple
versions
component
repository
exist
time
Git
Loeliger
McCullough
widely
used
example
distributed
VC
system
Centralized
distributed
VC
systems
provide
comparable
functionality
implement
functionality
different
ways
Key
features
systems
include
Version
release
identification
Managed
versions
component
assigned
unique
identifiers
submitted
system
identifiers
allow
different
versions
component
managed
without
changing
component
name
Versions
assigned
attributes
set
attributes
used
uniquely
identify
version
@@@@@@@@@@
Chapter
Configuration
management
Figure
Codelines
baselines
Baseline
V
Codeline
Codeline
B
B
B
B
B
Baseline
V
B
C
L
L
Ex
Codeline
C
C
C
C
C
Libraries
external
components
B
C
L
L
Ex
L
L
Ex
Ex
Mainline
Change
history
recording
VC
system
keeps
records
changes
made
create
new
version
component
earlier
version
systems
changes
used
select
particular
system
version
involves
tagging
components
keywords
describing
changes
made
use
tags
select
components
included
baseline
Independent
development
Different
developers
working
component
time
version
control
system
keeps
track
components
checked
editing
ensures
changes
made
component
different
developers
interfere
Project
support
version
control
system
support
development
several
projects
share
components
usually
possible
check
check
files
associated
project
rather
work
one
file
directory
time
Storage
management
Rather
maintain
separate
copies
versions
component
version
control
system
use
efficient
mechanisms
ensure
duplicate
copies
identical
files
maintained
small
differences
files
VC
system
store
differences
rather
maintain
multiple
copies
files
specific
version
automatically
re
created
applying
differences
master
version
software
development
team
activity
several
team
members
often
work
component
time
example
let
s
say
Alice
making
changes
system
involves
changing
components
B
C
time
Bob
working
changes
require
making
changes
components
X
Y
C
Alice
Bob
therefore
changing
C
s
important
avoid
situations
changes
interfere
Bob
s
changes
C
overwriting
Alice
s
vice
versa
support
independent
development
without
interference
version
control
systems
use
concept
project
repository
private
workspace
project
repository
maintains
master
version
components
used
create
baselines
system
building
modifying
components
developers
copy
@@@@@@@@@@
Version
management
Workspace
Alice
Workspace
Bob
Version
management
system
Alice
Bob
check
incheck
B
B
C
C
X
X
Y
Y
Q
P
C
Z
R
B
B
C
C
X
X
Y
Y
C
C
check
incheck
Figure
Check
check
centralized
version
repository
check
repository
workspace
work
copies
completed
changes
changed
components
returned
checked
repository
However
centralized
distributed
VC
systems
support
independent
development
shared
components
different
ways
centralized
systems
developers
check
components
directories
components
project
repository
private
workspace
work
copies
private
workspace
changes
complete
check
components
back
repository
creates
new
component
version
shared
illustration
see
Figure
Alice
checked
versions
B
C
worked
versions
created
new
versions
B
C
checks
new
versions
repository
Bob
checks
X
Y
C
creates
new
versions
components
checks
back
repository
However
Alice
already
created
new
version
C
Bob
working
check
therefore
creates
another
version
C
Alice
s
changes
overwritten
two
people
working
component
time
check
component
repository
component
checked
version
control
system
warns
users
wanting
check
component
checked
someone
system
ensure
modified
components
checked
different
versions
assigned
different
version
identifiers
stored
separately
distributed
VC
system
Git
different
approach
used
master
repository
created
server
maintains
code
produced
development
team
Instead
simply
checking
files
need
developer
creates
clone
project
repository
downloaded
installed
computer
Developers
work
files
required
maintain
new
versions
private
repository
computer
finished
making
changes
commit
changes
update
private
server
repository
push
changes
project
repository
tell
integration
manager
changed
versions
available
pull
files
project
repository
see
Figure
example
Bob
Alice
cloned
project
repository
updated
files
pushed
back
project
repository
@@@@@@@@@@
Chapter
Configuration
management
Master
repository
Alice
Bob
B
C
X
Y
Q
P
Z
R
Alice
s
repository
B
C
X
Y
Q
P
Z
R
Bob
s
repository
B
C
X
Y
Q
P
Z
R
B
C
C
X
Y
clone
clone
Figure
Repository
cloning
model
development
number
advantages
provides
backup
mechanism
repository
repository
corrupted
work
continue
project
repository
restored
local
copies
allows
offline
working
developers
commit
changes
network
connection
Project
support
default
way
working
Developers
compile
test
entire
system
local
machines
test
changes
made
Distributed
version
control
essential
open
source
development
several
people
working
simultaneously
system
without
central
coordination
no
way
open
source
system
manager
know
changes
made
case
well
private
repository
computer
developers
maintain
public
server
repository
push
new
versions
components
changed
open
source
system
manager
decide
pull
changes
definitive
system
organization
shown
Figure
example
Charlie
integration
manager
open
source
system
Alice
Bob
work
independently
system
development
clone
definitive
project
repository
well
private
repositories
Alice
Bob
maintain
public
repository
server
accessed
Charlie
made
tested
changes
push
changed
versions
private
repositories
personal
public
repositories
tell
Charlie
repositories
available
Charlie
pulls
repositories
@@@@@@@@@@
Version
management
Definitive
project
repository
Alice
s
public
repository
Alice
s
private
repository
Bob
s
public
repository
Bob
s
private
repository
Charlie
s
private
repository
Figure
Open
source
development
Charlie
Alice
Bob
private
repository
testing
satisfied
changes
acceptable
updates
definitive
project
repository
consequence
independent
development
component
codelines
branch
Rather
linear
sequence
versions
reflect
changes
component
time
several
independent
sequences
shown
Figure
normal
system
development
different
developers
work
independently
different
versions
source
code
change
different
ways
generally
recommended
working
system
new
branch
created
changes
accidentally
break
working
system
stage
necessary
merge
codeline
branches
create
new
version
component
includes
changes
made
shown
Figure
component
versions
merged
create
version
changes
made
involve
completely
different
parts
code
component
versions
merged
automatically
version
control
system
combining
code
changes
normal
mode
operation
new
features
added
code
changes
merged
master
copy
system
However
changes
made
different
developers
sometimes
overlap
changes
incompatible
interfere
case
developer
check
clashes
make
changes
components
resolve
incompatibilities
different
versions
version
control
systems
first
developed
storage
management
one
important
functions
Disk
space
expensive
important
Codeline
branch
V
merge
V
V
V
V
V
V
V
Codeline
branch
V
V
Figure
Branching
merging
Codeline
@@@@@@@@@@
Chapter
Configuration
management
Creation
date
Version
sequence
Figure
Storage
management
using
deltas
Version
Version
Version
Version
D
D
D
recent
V
source
code
Storage
structure
minimize
disk
space
used
different
copies
components
Instead
keeping
complete
copy
version
system
stores
list
differences
deltas
one
version
another
applying
master
version
usually
recent
version
target
version
re
created
illustrated
Figure
new
version
created
system
simply
stores
delta
list
differences
new
version
older
version
used
create
new
version
Figure
shaded
boxes
represent
earlier
versions
component
automatically
re
created
recent
component
version
Deltas
usually
stored
lists
changed
lines
applying
automatically
one
version
component
created
another
recent
version
component
likely
one
used
systems
store
version
full
deltas
define
re
create
earlier
system
versions
One
problems
delta
based
approach
storage
management
take
long
time
apply
deltas
disk
storage
now
relatively
cheap
Git
uses
alternative
faster
approach
Git
use
deltas
applies
standard
compression
algorithm
stored
files
associated
meta
information
store
duplicate
copies
files
Retrieving
file
simply
involves
decompressing
no
need
apply
chain
operations
Git
uses
notion
packfiles
several
smaller
files
combined
indexed
single
file
reduces
overhead
associated
lots
small
files
Deltas
used
packfiles
reduce
size
System
building
System
building
process
creating
complete
executable
system
compiling
linking
system
components
external
libraries
configuration
files
information
System
building
tools
version
control
tools
integrated
build
process
takes
component
versions
repository
managed
version
control
system
System
building
involves
assembling
large
amount
information
software
operating
environment
Therefore
makes
sense
use
automated
build
tool
create
system
build
Figure
Notice
don
t
need
source
code
files
involved
build
link
externally
provided
libraries
data
files
file
error
messages
configuration
files
define
target
installation
specify
versions
@@@@@@@@@@
System
building
Automated
build
system
Source
code
files
Data
files
Libraries
Configuration
files
Executable
tests
Executable
target
system
Test
results
Compilers
tools
Figure
System
building
compiler
software
tools
used
build
Ideally
able
build
complete
system
single
command
mouse
click
Tools
system
integration
building
include
following
features
Build
script
generation
build
system
analyze
program
built
identify
dependent
components
automatically
generate
build
script
configuration
file
system
support
manual
creation
editing
build
scripts
Version
control
system
integration
build
system
check
required
versions
components
version
control
system
Minimal
recompilation
build
system
work
source
code
needs
recompiled
set
compilations
required
Executable
system
creation
build
system
link
compiled
object
code
files
required
files
libraries
configuration
files
create
executable
system
Test
automation
build
systems
automatically
run
automated
tests
using
test
automation
tools
JUnit
check
build
broken
changes
Reporting
build
system
provide
reports
success
failure
build
tests
run
Documentation
generation
build
system
able
generate
release
notes
build
system
help
pages
build
script
definition
system
built
includes
information
components
dependencies
versions
tools
used
compile
link
system
configuration
language
used
define
build
script
includes
constructs
describe
system
components
included
build
dependencies
Building
complex
process
potentially
error
prone
three
different
system
platforms
involved
Figure
development
system
includes
development
tools
compilers
source
code
editors
Developers
check
code
version
control
system
@@@@@@@@@@
Chapter
Configuration
management
Development
system
Target
system
Development
tools
Private
workspace
Build
server
Version
management
system
co
Version
management
build
server
Check
co
Check
Figure
Development
build
target
platforms
Executable
system
Target
platform
private
workspace
making
changes
system
wish
build
version
system
testing
development
environment
committing
changes
made
version
control
system
involves
using
local
build
tools
use
checked
versions
components
private
workspace
build
server
used
build
definitive
executable
versions
system
server
maintains
definitive
versions
system
system
developers
check
code
version
control
system
build
server
system
building
target
environment
platform
system
executes
type
computer
used
development
build
systems
However
real
time
embedded
systems
target
environment
often
smaller
simpler
development
environment
e
g
cell
phone
large
systems
target
environment
include
databases
application
systems
cannot
installed
development
machines
situations
possible
build
test
system
development
computer
build
server
Agile
methods
recommend
frequent
system
builds
carried
automated
testing
used
discover
software
problems
Frequent
builds
part
process
continuous
integration
shown
Figure
keeping
agile
methods
notion
making
many
small
changes
continuous
integration
involves
rebuilding
mainline
frequently
small
source
code
changes
made
steps
continuous
integration
Extract
mainline
system
VC
system
developer
s
private
workspace
Build
system
run
automated
tests
ensure
built
system
passes
tests
build
broken
inform
checked
last
baseline
system
responsible
repairing
problem
Make
changes
system
components
Build
system
private
workspace
rerun
system
tests
tests
fail
continue
editing
@@@@@@@@@@
System
building
Check
mainline
Build
test
system
Build
test
system
Make
changes
Check
build
server
Build
test
system
Commit
changes
VM
Version
management
system
Version
management
system
Build
server
Private
workspace
Tests
fail
Tests
Tests
fail
Figure
Continuous
integration
system
passed
tests
check
build
system
server
commit
new
system
baseline
VC
system
Build
system
build
server
run
tests
Alternatively
using
Git
pull
recent
changes
server
private
workspace
need
case
others
modified
components
since
checked
system
case
check
components
failed
edit
tests
pass
private
workspace
system
passes
tests
build
system
commit
changes
made
new
baseline
system
mainline
Tools
Jenkins
Smart
used
support
continuous
integration
tools
set
build
system
soon
developer
completed
repository
update
advantage
continuous
integration
allows
problems
caused
interactions
different
developers
discovered
repaired
soon
possible
recent
system
mainline
definitive
working
system
However
continuous
integration
good
idea
possible
implement
approach
system
building
system
large
take
long
time
build
test
especially
integration
application
systems
involved
impractical
build
system
developed
several
times
per
day
development
platform
different
target
platform
possible
run
system
tests
developer
s
private
workspace
differences
hardware
operating
system
installed
software
Therefore
time
required
testing
system
large
systems
systems
execution
platform
development
platform
continuous
integration
usually
impossible
circumstances
frequent
system
building
supported
using
daily
build
system
@@@@@@@@@@
Chapter
Configuration
management
development
organization
sets
delivery
time
say
p
m
system
components
developers
new
versions
components
writing
deliver
time
Components
incomplete
provide
basic
functionality
tested
new
version
system
built
components
compiling
linking
form
complete
system
system
delivered
testing
team
carries
set
predefined
system
tests
Faults
discovered
system
testing
documented
returned
system
developers
repair
faults
subsequent
version
component
advantages
using
frequent
builds
software
chances
finding
problems
stemming
component
interactions
early
process
increased
Frequent
building
encourages
thorough
unit
testing
components
Psychologically
developers
put
pressure
break
build
try
avoid
checking
versions
components
cause
whole
system
fail
therefore
reluctant
deliver
new
component
versions
properly
tested
Consequently
less
time
spent
system
testing
discovering
coping
software
faults
found
developer
compilation
computationally
intensive
process
tools
support
system
building
designed
minimize
amount
compilation
required
checking
compiled
version
component
available
no
need
recompile
component
Therefore
way
unambiguously
linking
source
code
component
equivalent
object
code
linking
accomplished
associating
unique
signature
file
source
code
component
stored
corresponding
object
code
compiled
source
code
related
signature
signature
identifies
source
code
version
changed
source
code
edited
comparing
signatures
source
object
code
files
possible
decide
source
code
component
used
generate
object
code
component
Two
types
signature
used
shown
Figure
Modification
timestamps
signature
source
code
file
time
date
file
modified
source
code
file
component
modified
related
object
code
file
system
assumes
recompilation
create
new
object
code
file
necessary
example
say
components
Comp
java
Comp
class
modification
signatures
respectively
means
Java
code
modified
minutes
seconds
past
th
February
compiled
version
modified
minutes
seconds
past
th
February
case
system
automatically
recompile
Comp
java
compiled
version
earlier
modification
date
recent
version
component
@@@@@@@@@@
Change
management
Timestamp
Checksum
Checksum
Comp
java
Comp
java
Comp
class
V
V
Compile
Compile
Timestamp
Timestamp
Checksum
Checksum
Comp
java
Comp
java
Comp
class
V
Comp
class
V
Compile
Time
based
identification
Checksum
based
identification
Figure
Linking
source
object
Source
code
checksums
signature
source
code
file
checksum
calcucode
lated
data
file
checksum
function
calculates
unique
number
using
source
text
input
change
source
code
even
one
character
generate
different
checksum
therefore
confident
source
code
files
different
checksums
different
checksum
assigned
source
code
compilation
uniquely
identifies
source
file
build
system
tags
generated
object
code
file
checksum
signature
no
object
code
file
signature
source
code
file
included
system
recompilation
source
code
necessary
object
code
files
normally
versioned
first
approach
means
recently
compiled
object
code
file
maintained
system
normally
related
source
code
file
name
name
source
code
file
different
suffix
Therefore
source
file
Comp
Java
generate
object
file
Comp
class
source
object
files
linked
name
usually
possible
build
different
versions
source
code
component
directory
time
compiler
generate
object
files
name
recently
compiled
version
available
checksum
approach
advantage
allowing
many
different
versions
object
code
component
maintained
time
signature
rather
filename
link
source
object
code
source
code
object
code
files
signature
Therefore
recompile
component
overwrite
object
code
normally
case
timestamp
used
Rather
generates
new
object
code
file
tags
source
code
signature
Parallel
compilation
possible
different
versions
component
compiled
time
Change
management
Change
fact
life
large
software
systems
Organizational
needs
requirements
change
lifetime
system
bugs
repaired
systems
adapt
changes
environment
ensure
changes
applied
@@@@@@@@@@
Chapter
Configuration
management
Figure
change
management
process
Customer
support
Customer
Change
requests
Submit
CR
Check
CR
Close
CR
Implementation
analysis
Cost
impact
analysisAssess
CRs
Select
CRs
Modify
software
Test
software
Close
CR
Close
CRs
Valid
Invalid
Pass
Fail
Development
Product
development
CCB
Register
CR
system
controlled
way
need
set
tool
supported
change
management
processes
Change
management
intended
ensure
evolution
system
controlled
urgent
cost
effective
changes
prioritized
Change
management
process
analyzing
costs
benefits
proposed
changes
approving
changes
cost
effective
tracking
components
system
changed
Figure
model
change
management
process
shows
main
change
management
activities
process
come
effect
software
handed
release
customers
deployment
organization
Many
variants
process
use
depending
software
custom
system
product
line
off
shelf
product
size
company
makes
difference
small
companies
use
less
formal
process
large
companies
working
corporate
government
customers
However
change
management
processes
include
way
checking
costing
approving
changes
Tools
support
change
management
relatively
simple
issue
bug
tracking
systems
software
integrated
configuration
management
package
large
scale
systems
Rational
Clearcase
Issue
tracking
systems
allow
anyone
report
bug
make
suggestion
system
change
keep
track
development
team
responded
issues
systems
impose
process
users
used
many
different
settings
complex
systems
built
around
process
model
change
management
process
@@@@@@@@@@
Change
management
Figure
partially
completed
change
request
form
Change
Request
Form
Project
SICSA
AppProcessing
Number
Change
requester
Sommerville
Date
Requested
change
status
applicants
rejected
accepted
etc
shown
visually
displayed
list
applicants
Change
analyzer
R
Looek
Analysis
date
Components
affected
ApplicantListDisplay
StatusUpdater
Associated
components
StudentDatabase
Change
assessment
Relatively
simple
implement
changing
display
color
according
status
table
added
relate
status
colors
No
changes
associated
components
required
Change
priority
Medium
Change
implementation
Estimated
effort
hours
Date
SGA
app
team
CCB
decision
date
Decision
Accept
change
Change
implemented
Release
Change
implementor
Date
change
Date
submitted
QM
QM
decision
Date
submitted
CM
Comments
automate
entire
process
handling
change
requests
initial
customer
proposal
final
change
approval
change
submission
development
team
change
management
process
initiated
system
stakeholder
completes
submits
change
request
describing
change
required
system
bug
report
symptoms
bug
described
request
additional
functionality
added
system
companies
handle
bug
reports
new
requirements
separately
principle
simply
change
requests
Change
requests
submitted
using
change
request
form
CRF
Stakeholders
system
owners
users
beta
testers
developers
marketing
department
company
Electronic
change
request
forms
record
information
shared
groups
involved
change
management
change
request
processed
information
added
CRF
record
decisions
made
stage
process
time
therefore
represents
snapshot
state
change
request
addition
recording
change
required
CRF
records
recommendations
regarding
change
estimated
costs
change
dates
change
requested
approved
implemented
validated
CRF
include
section
developer
outlines
change
implemented
degree
formality
CRF
varies
depending
size
type
organization
developing
system
Figure
example
type
CRF
used
large
complex
systems
engineering
project
smaller
projects
recommend
change
requests
formally
recorded
CRF
focus
describing
@@@@@@@@@@
Chapter
Configuration
management
Customers
changes
Agile
methods
emphasize
importance
involving
customers
change
prioritization
process
customer
representative
helps
team
decide
changes
implemented
next
development
iteration
effective
systems
development
single
customer
problem
product
development
no
real
customer
working
team
cases
team
make
decisions
change
prioritization
http
software
engineering
book
com
web
agile
changes
change
required
less
emphasis
implementation
issues
System
developers
decide
implement
change
estimate
time
required
complete
change
implementation
change
request
submitted
checked
ensure
valid
checker
customer
application
support
team
internal
requests
member
development
team
change
request
rejected
stage
change
request
bug
report
bug
already
reported
repaired
Sometimes
people
believe
problems
misunderstandings
system
expected
occasions
people
request
features
already
implemented
don
t
know
features
true
issue
closed
form
updated
reason
closure
valid
change
request
logged
outstanding
request
subsequent
analysis
valid
change
requests
next
stage
process
change
assessment
costing
function
usually
responsibility
development
maintenance
team
work
involved
implementing
change
impact
change
rest
system
checked
identify
components
affected
change
making
change
means
changes
elsewhere
system
needed
obviously
increase
cost
change
implementation
Next
required
changes
system
modules
assessed
Finally
cost
making
change
estimated
taking
account
costs
changing
related
components
Following
analysis
separate
group
decides
cost
effective
business
make
change
software
military
government
systems
group
often
called
change
control
board
CCB
industry
called
something
like
product
development
group
responsible
making
decisions
software
system
evolve
group
review
approve
change
requests
unless
changes
simply
involve
correcting
minor
errors
screen
displays
web
pages
documents
small
requests
passed
development
team
immediate
implementation
CCB
product
development
group
considers
impact
change
strategic
organizational
rather
technical
point
view
decides
change
question
economically
justified
prioritizes
accepted
changes
implementation
Accepted
changes
passed
back
development
group
@@@@@@@@@@
Change
management
rejected
change
requests
closed
no
action
taken
factors
influence
decision
implement
change
include
consequences
making
change
assessing
change
request
consider
happen
change
implemented
change
associated
reported
system
failure
seriousness
failure
taken
account
system
failure
causes
system
crash
serious
failure
make
change
disrupt
operational
use
system
hand
failure
minor
effect
incorrect
colors
display
important
fix
problem
quickly
change
therefore
low
priority
benefits
change
change
benefit
many
users
system
benefit
change
proposer
number
users
affected
change
users
affected
change
assigned
low
priority
fact
making
change
inadvisable
means
majority
system
users
adapt
costs
making
change
making
change
affects
many
system
components
increasing
chances
introducing
new
bugs
takes
lot
time
implement
change
rejected
product
release
cycle
new
version
software
released
customers
make
sense
delay
implementation
change
next
planned
release
see
Section
Change
management
software
products
e
g
CAD
system
product
rather
custom
systems
specifically
developed
certain
customer
handled
different
way
software
products
customer
directly
involved
decisions
system
evolution
relevance
change
customer
s
business
issue
Change
requests
products
come
customer
support
team
company
marketing
team
developers
requests
reflect
suggestions
feedback
customers
analyses
offered
competing
products
customer
support
team
submit
change
requests
associated
bugs
discovered
reported
customers
software
released
Customers
use
web
page
email
report
bugs
bug
management
team
checks
bug
reports
valid
translates
formal
system
change
requests
Marketing
staff
meet
customers
investigate
competitive
products
suggest
changes
included
make
easier
sell
new
version
system
new
existing
customers
system
developers
good
ideas
new
features
added
system
change
request
process
shown
Figure
initiated
system
released
customers
development
new
versions
system
created
daily
frequent
system
builds
no
need
formal
change
management
process
Problems
requested
changes
recorded
issue
tracking
system
discussed
daily
meetings
Changes
affect
individual
components
passed
directly
system
developer
accepts
makes
case
required
However
independent
@@@@@@@@@@
Chapter
Configuration
management
Figure
Derivation
history
SICSA
project
XEP
APP
SYSTEM
AUTH
RBAC
USER
ROLE
Object
currentRole
Author
R
Looek
Creation
date
St
Andrews
University
Modification
history
Version
Modifier
Date
Change
Reason
J
Jones
Add
header
Submitted
CM
R
Looek
New
field
Change
req
R
authority
system
architect
assess
prioritize
changes
cut
across
system
modules
produced
different
development
teams
agile
methods
customers
directly
involved
deciding
change
implemented
propose
change
system
requirements
work
team
assess
impact
change
decide
change
take
priority
features
planned
next
increment
system
However
changes
involve
software
improvement
left
discretion
programmers
working
system
Refactoring
software
continually
improved
seen
overhead
necessary
part
development
process
development
team
changes
software
components
maintain
record
changes
made
component
sometimes
called
derivation
history
component
good
way
keep
derivation
history
standardized
comment
beginning
component
source
code
Figure
comment
reference
change
request
triggered
software
change
comments
processed
scripts
scan
components
derivation
histories
generate
component
change
reports
documents
records
changes
incorporated
version
usually
maintained
separate
page
front
document
discuss
web
chapter
documentation
Chapter
Release
management
system
release
version
software
system
distributed
customers
mass
market
software
usually
possible
identify
two
types
release
major
releases
deliver
significant
new
functionality
minor
releases
repair
bugs
fix
customer
problems
reported
example
book
written
Apple
Mac
computer
operating
system
OS
means
minor
release
major
release
OS
Major
releases
important
economically
software
vendor
customers
usually
pay
Minor
releases
usually
distributed
free
charge
@@@@@@@@@@
Release
management
software
product
release
executable
code
system
release
include
configuration
files
defining
release
configured
particular
installations
data
files
files
error
messages
different
languages
needed
successful
system
operation
installation
program
used
help
install
system
target
hardware
electronic
paper
documentation
describing
system
packaging
associated
publicity
designed
release
Preparing
distributing
system
release
mass
market
products
expensive
process
addition
technical
work
involved
creating
release
distribution
advertising
publicity
material
prepared
Marketing
strategies
designed
convince
customers
buy
new
release
system
Careful
thought
given
release
timing
releases
frequent
require
hardware
upgrades
customers
move
new
release
especially
pay
system
releases
infrequent
market
share
lost
customers
move
alternative
systems
various
technical
organizational
factors
take
account
deciding
release
new
version
software
product
shown
Figure
Release
creation
process
creating
collection
files
documentation
include
components
system
release
process
involves
several
steps
executable
code
programs
associated
data
files
identified
version
control
system
tagged
release
identifier
Configuration
descriptions
written
different
hardware
operating
systems
Updated
instructions
written
customers
need
configure
systems
Scripts
installation
program
written
Web
pages
created
describing
release
links
system
documentation
Finally
information
available
executable
master
image
software
prepared
handed
distribution
customers
sales
outlets
custom
software
software
product
lines
complexity
system
release
management
process
depends
number
system
customers
Special
releases
system
produced
customer
Individual
customers
running
several
different
releases
system
time
different
hardware
software
part
complex
system
systems
several
@@@@@@@@@@
Chapter
Configuration
management
Factor
Description
Competition
mass
market
software
new
system
release
necessary
competing
product
introduced
new
features
market
share
lost
provided
existing
customers
Marketing
requirements
marketing
department
organization
made
commitment
releases
available
particular
date
marketing
reasons
necessary
include
new
features
system
users
persuaded
upgrade
previous
release
Platform
changes
create
new
release
software
application
new
version
operating
system
platform
released
Technical
quality
system
serious
system
faults
reported
affect
way
many
customers
use
system
necessary
correct
new
system
release
Figure
Factors
influencing
system
release
planning
Minor
system
faults
repaired
issuing
patches
distributed
Internet
applied
current
release
system
different
variants
individual
systems
created
example
specialized
fire
fighting
vehicles
type
vehicle
version
software
system
adapted
equipment
vehicle
software
company
manage
tens
even
hundreds
different
releases
software
configuration
management
systems
processes
designed
provide
information
customers
releases
system
relationship
releases
system
versions
event
problem
delivered
system
able
recover
component
versions
used
specific
system
Therefore
system
release
produced
documented
ensure
re
created
exactly
future
particularly
important
customized
long
lifetime
embedded
systems
military
systems
control
complex
machines
systems
long
lifetime
years
cases
Customers
use
single
release
systems
many
years
require
specific
changes
release
long
superseded
document
release
record
specific
versions
source
code
components
used
create
executable
code
keep
copies
source
code
files
corresponding
executables
data
configuration
files
necessary
keep
copies
older
operating
systems
support
software
still
operational
use
Fortunately
no
longer
means
old
hardware
maintained
older
operating
systems
run
virtual
machine
record
versions
operating
system
libraries
compilers
tools
used
build
software
tools
required
order
build
exactly
system
later
date
Accordingly
store
copies
platform
software
tools
used
create
system
version
control
system
along
source
code
target
system
planning
installation
new
system
releases
cannot
assume
customers
install
new
system
releases
system
users
happy
@@@@@@@@@@
Chapter
Key
Points
existing
system
consider
worthwhile
absorb
cost
changing
new
release
New
releases
system
cannot
therefore
rely
installation
previous
releases
illustrate
problem
consider
following
scenario
Release
system
distributed
put
use
Release
requires
installation
new
data
files
customers
need
facilities
release
remain
release
Release
requires
data
files
installed
release
no
new
data
files
software
distributor
cannot
assume
files
required
release
already
installed
sites
sites
go
directly
release
release
skipping
release
sites
modified
data
files
associated
release
reflect
local
circumstances
Therefore
data
files
distributed
installed
release
system
One
benefit
delivering
software
service
SaaS
avoids
problems
simplifies
release
management
system
installation
customers
software
developer
responsible
replacing
existing
release
system
new
release
made
available
customers
time
However
approach
requires
servers
running
services
updated
time
support
server
updates
specialized
distribution
management
tools
Puppet
Loope
developed
pushing
new
software
servers
Key
Points
Configuration
management
management
evolving
software
system
maintaining
system
CM
team
put
place
ensure
changes
incorporated
system
controlled
way
records
maintained
details
changes
implemented
main
configuration
management
processes
concerned
version
control
system
building
change
management
release
management
Software
tools
available
support
processes
Version
control
involves
keeping
track
different
versions
software
components
created
changes
made
System
building
process
assembling
system
components
executable
program
run
target
computer
system
Software
frequently
rebuilt
tested
immediately
new
version
built
makes
easier
detect
bugs
problems
introduced
since
last
build
Change
management
involves
assessing
proposals
changes
system
customers
stakeholders
deciding
cost
effective
implement
changes
new
release
system
@@@@@@@@@@
Chapter
Configuration
management
System
releases
include
executable
code
data
files
configuration
files
documentation
Release
management
involves
making
decisions
system
release
dates
preparing
information
distribution
documenting
system
release
Reading
Software
Configuration
Management
Patterns
Effective
Teamwork
Practical
Integration
relatively
short
easy
read
book
gives
good
practical
advice
configuration
management
practice
especially
agile
methods
development
S
P
Berczuk
B
Appleton
Addison
Wesley
Agile
Configuration
Management
Large
Organizations
web
article
describes
configuration
management
practices
used
agile
development
processes
particular
emphasis
scale
large
projects
companies
P
Schuh
http
www
ibm
com
developerworks
rational
library
mar
schuh
index
html
Configuration
Management
Best
Practices
nicely
written
book
presents
broader
view
configuration
management
discussed
including
hardware
configuration
management
s
geared
large
systems
projects
really
cover
agile
development
issues
Bob
Aiello
Leslie
Sachs
Addison
Wesley
Behind
Scenes
Look
Facebook
Release
Engineering
interesting
article
covers
problems
releasing
new
versions
large
systems
cloud
something
haven
t
discussed
chapter
challenge
make
sure
servers
updated
time
users
don
t
see
different
versions
system
P
Ryan
arstechnica
com
http
arstechnica
com
business
exclusive
behind
scenes
look
facebook
release
engineering
Git
SVn
Comparison
wiki
compares
Git
Subversion
version
control
systems
https
git
wiki
kernel
org
index
php
GitSvnComparsion
WebSite
PowerPoint
slides
chapter
www
pearsonglobaleditions
com
Sommerville
Links
supporting
videos
http
software
engineering
book
com
videos
software
management
exeRCiSeS
Suggest
five
possible
problems
arise
company
develop
effective
configuration
management
policies
processes
version
management
codeline
baseline
terminologies
stand
List
features
included
version
control
system
@@@@@@@@@@
Chapter
References
Imagine
situation
two
developers
simultaneously
modifying
three
different
software
components
difficulties
arise
try
merge
changes
made
Software
now
often
developed
distributed
teams
team
members
working
different
locations
different
time
zones
Suggest
features
version
control
system
included
support
distributed
software
development
Describe
difficulties
arise
building
system
components
particular
problems
occur
system
built
host
computer
target
machine
reference
system
building
explain
sometimes
maintain
obsolete
computers
large
software
systems
developed
common
problem
system
building
occurs
physical
filenames
incorporated
system
code
file
structure
implied
names
differs
target
machine
Write
set
programmer
s
guidelines
helps
avoid
system
building
problems
think
factors
influence
decision
change
implemented
Describe
six
essential
features
included
tool
support
change
management
processes
Explain
preparing
distributing
system
release
mass
market
products
expensive
process
ReFeRenCeS
Aiello
B
L
Sachs
Configuration
Management
Best
Practices
Boston
Addison
Wesley
Bamford
R
W
J
Deibler
ISO
Software
Systems
Providers
Engineering
Approach
Boca
Raton
FL
CRC
Press
Chrissis
M
B
M
Konrad
S
Shrum
CMMI
Development
Guidelines
Process
Integration
Product
Improvement
rd
ed
Boston
Addison
Wesley
IEEE
IEEE
Standard
Configuration
Management
Systems
Software
Engineering
IEEE
Std
doi
IEEESTD
Loeliger
J
M
McCullough
Version
Control
Git
Powerful
Tools
Techniques
Collaborative
Software
Development
Sebastopol
CA
O
Reilly
Associates
Loope
J
Managing
Infrastructure
Puppet
Sebastopol
CA
O
Reilly
Associates
Pilato
C
B
Collins
Sussman
B
Fitzpatrick
Version
Control
Subversion
Sebastopol
CA
O
Reilly
Associates
Smart
J
F
Jenkins
Definitive
Guide
Sebastopol
CA
O
Reilly
Associates
@@@@@@@@@@
page
intentionally
left
blank
@@@@@@@@@@
Glossary
abstract
data
type
type
defined
operations
rather
representation
representation
private
accessed
defined
operations
acceptance
testing
Customer
tests
system
decide
adequate
meet
needs
accepted
supplier
activity
chart
chart
used
project
managers
show
dependencies
tasks
completed
chart
shows
tasks
time
expected
complete
tasks
task
dependencies
critical
path
longest
path
terms
time
required
complete
tasks
activity
chart
critical
path
defines
minimum
time
required
complete
project
Sometimes
called
PERT
chart
Ada
programming
language
developed
US
Department
Defense
s
standard
language
developing
military
software
based
programming
language
research
s
includes
constructs
abstract
data
types
support
concurrency
still
used
large
complex
military
aerospace
systems
agile
manifesto
set
principles
encapsulating
ideas
underlying
agile
methods
software
development
agile
methods
Methods
software
development
geared
rapid
software
delivery
software
developed
delivered
increments
process
documentation
@@@@@@@@@@
Glossary
bureaucracy
minimized
focus
development
code
rather
supporting
documents
algorithmic
cost
modeling
approach
software
cost
estimation
formula
used
estimate
project
cost
parameters
formula
attributes
project
software
application
family
set
software
application
programs
common
architecture
generic
functionality
tailored
needs
specific
customers
modifying
components
program
parameters
application
framework
set
reusable
concrete
abstract
classes
implement
features
common
many
applications
domain
e
g
user
interfaces
classes
application
framework
specialized
instantiated
create
application
application
program
interface
API
interface
generally
specified
set
operations
allows
access
application
program
s
functionality
means
functionality
called
directly
programs
accessed
user
interface
architectural
pattern
style
abstract
description
software
architecture
tried
tested
number
different
software
systems
pattern
description
includes
information
appropriate
use
pattern
organization
components
architecture
architectural
view
description
software
architecture
particular
perspective
availability
readiness
system
deliver
services
requested
Availability
usually
expressed
decimal
number
availability
means
system
deliver
services
time
units
B
formal
method
software
development
based
implementing
system
systematic
transformation
formal
system
specification
bar
chart
Gantt
chart
chart
used
project
managers
show
project
tasks
schedule
associated
tasks
people
work
shows
tasks
start
end
dates
staff
allocations
timeline
black
box
testing
approach
testing
testers
no
access
source
code
system
components
tests
derived
system
specification
@@@@@@@@@@
Glossary
BPMN
Business
Process
Modeling
Notation
notation
defining
workflows
describe
business
processes
service
composition
brownfield
software
development
development
software
environment
several
existing
systems
software
developed
integrate
programming
language
originally
developed
implement
Unix
system
C
relatively
low
level
system
implementation
language
allows
access
system
hardware
compiled
efficient
code
widely
used
low
level
systems
programming
embedded
systems
development
C
object
oriented
programming
language
superset
C
C
object
oriented
programming
language
developed
Microsoft
much
common
C
includes
features
allow
compile
time
type
checking
Capability
Maturity
Model
CMM
Software
Engineering
Institute
s
Capability
Maturity
Model
used
assess
level
software
development
maturity
organization
now
superseded
CMMI
still
widely
used
Computer
Aided
Software
Engineering
CASE
term
invented
s
describe
process
developing
software
using
automated
tool
support
Virtually
software
development
now
reliant
tool
support
term
CASE
no
longer
widely
used
CASE
tool
software
tool
design
editor
program
debugger
used
support
activity
software
development
process
CASE
workbench
integrated
set
CASE
tools
work
together
support
major
process
activity
software
design
configuration
management
Now
often
called
programming
environment
change
management
process
record
check
analyze
estimate
implement
proposed
changes
software
system
class
diagram
UML
diagram
types
shows
object
classes
system
relationships
@@@@@@@@@@
Glossary
client
server
architecture
architectural
model
distributed
systems
system
functionality
offered
set
services
provided
server
accessed
client
computers
make
use
services
Variants
approach
three
tier
client
server
architectures
use
multiple
servers
cloud
computing
provision
computing
application
services
Internet
using
cloud
servers
external
provider
cloud
implemented
using
large
number
commodity
computers
virtualization
technology
make
effective
use
systems
CMMI
integrated
approach
process
capability
maturity
modeling
based
adoption
good
software
engineering
practice
integrated
quality
management
supports
discrete
continuous
maturity
modeling
integrates
systems
software
engineering
process
maturity
models
Developed
original
Capability
Maturity
Model
COCOMO
II
See
Constructive
Cost
Modeling
code
ethics
professional
practice
set
guidelines
set
expected
ethical
professional
behavior
software
engineers
defined
major
US
professional
societies
ACM
IEEE
defines
ethical
behavior
eight
headings
public
client
employer
product
judgment
management
colleagues
profession
self
Common
Request
Broker
Architecture
CORBA
set
standards
proposed
Object
Management
Group
OMG
defines
distributed
component
models
communications
Influential
development
distributed
systems
no
longer
widely
used
component
deployable
independent
unit
software
completely
defined
accessed
set
interfaces
component
model
set
standards
component
implementation
documentation
deployment
cover
specific
interfaces
provided
component
component
naming
component
interoperation
component
composition
Component
models
provide
basis
middleware
support
executing
components
component
based
software
engineering
CBSE
development
software
composing
independent
deployable
software
components
consistent
component
model
@@@@@@@@@@
Glossary
conceptual
design
development
high
level
vision
complex
system
description
essential
capabilities
Designed
understood
people
systems
engineers
configurable
application
system
application
system
product
developed
system
vendor
offers
functionality
configured
use
different
companies
environments
configuration
item
machine
readable
unit
document
source
code
file
subject
change
change
controlled
configuration
management
system
configuration
management
process
managing
changes
evolving
software
product
Configuration
management
involves
version
management
system
building
change
management
release
management
Constructive
Cost
Modeling
COCOMO
family
algorithmic
cost
estimation
models
COCOMO
first
proposed
early
s
modified
updated
since
reflect
new
technology
changing
software
engineering
practice
COCOMO
II
latest
instantiation
freely
available
algorithmic
cost
estimation
model
supported
open
source
software
tools
CORBA
See
Common
Request
Broker
Architecture
control
metric
software
metric
allows
managers
make
planning
decisions
based
information
software
process
software
product
developed
control
metrics
process
metrics
critical
system
computer
system
failure
result
significant
economic
human
environmental
losses
COTS
system
Commercial
Off
Shelf
system
term
COTS
now
mostly
used
military
systems
See
configurable
application
system
CVS
widely
used
open
source
software
tool
used
version
management
data
processing
system
system
aims
process
large
amounts
structured
data
systems
usually
process
data
batches
follow
input
process
output
model
Examples
data
processing
systems
billing
invoicing
systems
payment
systems
@@@@@@@@@@
Glossary
denial
service
attack
attack
web
based
software
system
attempts
overload
system
cannot
provide
normal
service
users
dependability
dependability
system
aggregate
property
takes
account
system
s
safety
reliability
availability
security
resilience
attributes
dependability
system
reflects
extent
trusted
users
dependability
requirement
system
requirement
included
help
achieve
required
dependability
system
Non
functional
dependability
requirements
specify
dependability
attribute
values
functional
dependability
requirements
functional
requirements
specify
avoid
detect
tolerate
recover
system
faults
failures
dependability
case
structured
document
used
back
claims
made
system
developer
dependability
system
Specific
types
dependability
case
safety
cases
security
cases
design
pattern
well
tried
solution
common
problem
captures
experience
good
practice
form
reused
abstract
representation
instantiated
number
ways
digital
learning
environment
integrated
set
software
tools
educational
applications
content
geared
support
learning
distributed
system
software
system
software
sub
systems
components
execute
different
processors
domain
specific
problem
business
area
software
systems
used
Examples
domains
include
real
time
control
business
data
processing
telecommunications
switching
domain
model
definition
domain
abstractions
policies
procedures
objects
relationships
events
serves
base
knowledge
problem
area
DSDM
Dynamic
System
Development
Method
Claimed
one
first
agile
development
methods
embedded
system
software
system
embedded
hardware
device
e
g
software
system
cell
phone
Embedded
systems
usually
real
time
systems
respond
timely
way
events
occurring
environment
@@@@@@@@@@
Glossary
emergent
property
property
becomes
apparent
components
system
integrated
create
system
Enterprise
Java
Beans
EJB
Java
based
component
model
enterprise
resource
planning
ERP
system
large
scale
software
system
includes
range
capabilities
support
operation
business
enterprises
provides
means
sharing
information
across
capabilities
example
ERP
system
include
support
supply
chain
management
manufacturing
distribution
ERP
systems
configured
requirements
company
using
system
ethnography
observational
technique
used
requirements
elicitation
analysis
ethnographer
immerses
users
environment
observes
day
day
work
habits
Requirements
software
support
inferred
observations
event
based
systems
Systems
control
operation
determined
events
generated
system
s
environment
real
time
systems
event
based
systems
extreme
programming
XP
widely
used
agile
method
software
development
includes
practices
scenario
based
requirements
test
first
development
pair
programming
fault
avoidance
Developing
software
way
faults
introduced
software
fault
detection
use
processes
run
time
checking
detect
remove
faults
program
result
system
failure
fault
tolerance
ability
system
continue
execution
even
faults
occurred
fault
tolerant
architectures
System
architectures
designed
allow
recovery
software
faults
based
redundant
diverse
software
components
formal
methods
Methods
software
development
software
modeled
using
formal
mathematical
constructs
predicates
sets
Formal
transformation
converts
model
code
Mostly
used
specification
development
critical
systems
Gantt
chart
See
bar
chart
@@@@@@@@@@
Glossary
Git
distributed
version
management
system
building
tool
developers
take
complete
copies
project
repository
allow
concurrent
working
GitHub
server
maintains
large
number
Git
repositories
Repositories
private
public
repositories
many
open
source
projects
maintained
GitHub
hazard
condition
state
system
potential
cause
contribute
accident
host
target
development
mode
software
development
software
developed
separate
computer
executed
normal
approach
development
embedded
mobile
systems
iLearn
system
digital
learning
environment
support
learning
schools
Used
case
study
book
incremental
development
approach
software
development
software
delivered
deployed
increments
information
hiding
Using
programming
language
constructs
conceal
representation
data
structures
control
external
access
structures
inspection
See
program
inspection
insulin
pump
software
controlled
medical
device
deliver
controlled
doses
insulin
people
suffering
diabetes
Used
case
study
book
integrated
application
system
application
system
created
integrating
two
configurable
application
systems
legacy
systems
interface
specification
attributes
operations
associated
software
component
interface
used
means
accessing
component
s
functionality
ISO
set
standards
quality
management
processes
defined
International
Standards
Organization
ISO
ISO
ISO
standard
applicable
software
development
used
certify
quality
management
processes
organization
@@@@@@@@@@
Glossary
iterative
development
approach
software
development
processes
specification
design
programming
testing
interleaved
J
EE
Java
Platform
Enterprise
Edition
complex
middleware
system
supports
development
component
based
web
applications
Java
includes
component
model
Java
components
APIs
services
etc
Java
widely
used
object
oriented
programming
language
designed
Sun
now
Oracle
aim
platform
independence
language
processing
system
system
translates
one
language
another
example
compiler
language
processing
system
translates
program
source
code
object
code
legacy
system
socio
technical
system
useful
essential
organization
developed
using
obsolete
technology
methods
legacy
systems
often
perform
critical
business
functions
maintained
Lehman
s
Laws
set
hypotheses
factors
influence
evolution
complex
software
systems
maintenance
process
making
changes
system
put
operation
mean
time
failure
MTTF
average
time
observed
system
failures
Used
reliability
specification
Mentcare
system
Mental
Health
Care
Patient
Management
System
system
used
record
information
consultations
treatments
prescribed
people
suffering
mental
health
problems
Used
case
study
book
middleware
infrastructure
software
distributed
system
helps
manage
interactions
distributed
entities
system
system
databases
Examples
middleware
object
request
broker
transaction
management
system
misuse
case
description
possible
attack
system
associated
system
use
case
model
driven
architecture
MDA
approach
software
development
based
construction
set
system
models
automatically
semi
automatically
processed
generate
executable
system
@@@@@@@@@@
Glossary
model
checking
method
static
verification
state
model
system
exhaustively
analyzed
attempt
discover
unreachable
states
model
driven
development
MDD
approach
software
engineering
centered
around
system
models
expressed
UML
rather
programming
language
code
extends
MDA
consider
activities
development
requirements
engineering
testing
multi
tenant
databases
Databases
information
several
different
organizations
stored
database
Used
implementation
software
service
mutual
exclusion
mechanism
ensure
concurrent
process
maintains
control
memory
updates
accesses
completed
NET
extensive
framework
used
develop
applications
Microsoft
Windows
systems
Includes
component
model
defines
standards
components
Windows
systems
associated
middleware
support
component
execution
object
class
object
class
defines
attributes
operations
objects
Objects
created
run
time
instantiating
class
definition
object
class
name
used
type
name
object
oriented
languages
object
model
model
software
system
structured
organized
set
object
classes
relationships
classes
Various
different
perspectives
model
exist
state
perspective
sequence
perspective
object
oriented
OO
development
approach
software
development
fundamental
abstractions
system
independent
objects
type
abstraction
used
specification
design
development
object
constraint
language
OCL
language
part
UML
used
define
predicates
apply
object
classes
interactions
UML
model
use
OCL
specify
components
fundamental
part
model
driven
development
Object
Management
Group
OMG
group
companies
formed
develop
standards
object
oriented
development
Examples
standards
promoted
OMG
CORBA
UML
MDA
open
source
approach
software
development
source
code
system
made
public
external
users
encouraged
participate
development
system
@@@@@@@@@@
Glossary
operational
profile
set
artificial
system
inputs
reflect
pattern
inputs
processed
operational
system
Used
reliability
testing
pair
programming
development
situation
programmers
work
pairs
rather
individually
develop
code
fundamental
part
extreme
programming
peer
peer
system
distributed
system
no
distinction
clients
servers
Computers
system
act
clients
servers
Peer
peer
applications
include
file
sharing
instant
messaging
cooperation
support
systems
People
Capability
Maturity
Model
P
CMM
process
maturity
model
reflects
effective
organization
managing
skills
training
experience
people
organization
plan
driven
process
software
process
process
activities
planned
software
developed
planning
game
approach
project
planning
based
estimating
time
required
implement
user
stories
Used
agile
methods
predictor
metric
software
metric
used
basis
making
predictions
characteristics
software
system
reliability
maintainability
probability
failure
demand
POFOD
reliability
metric
based
likelihood
software
system
failing
demand
services
made
process
improvement
Changing
software
development
process
aim
making
process
efficient
improving
quality
outputs
example
aim
reduce
number
defects
delivered
software
improve
process
adding
new
validation
activities
process
model
abstract
representation
process
Process
models
developed
various
perspectives
show
activities
involved
process
artifacts
used
process
constraints
apply
process
roles
people
enacting
process
process
maturity
model
model
extent
process
includes
good
practice
reflective
measurement
capabilities
geared
process
improvement
@@@@@@@@@@
Glossary
program
evolution
dynamics
study
ways
evolving
software
system
changes
claimed
Lehman
s
Laws
govern
dynamics
program
evolution
program
generator
program
generates
another
program
high
level
abstract
specification
generator
embeds
knowledge
reused
generation
activity
program
inspection
review
group
inspectors
examine
program
line
line
aim
detecting
program
errors
checklist
common
programming
errors
often
drives
inspections
Python
programming
language
dynamic
types
particularly
well
suited
development
web
based
systems
quality
management
QM
set
processes
concerned
defining
software
quality
achieved
organization
developing
software
knows
software
met
required
level
quality
quality
plan
plan
defines
quality
processes
procedures
used
involves
selecting
instantiating
standards
products
processes
defining
system
quality
attributes
important
rapid
application
development
RAD
approach
software
development
aimed
rapid
delivery
software
often
involves
use
database
programming
development
support
tools
screen
report
generators
rate
occurrence
failure
ROCOF
reliability
metric
based
number
observed
failures
system
given
time
period
Rational
Unified
Process
RUP
generic
software
process
model
presents
software
development
four
phase
iterative
activity
phases
inception
elaboration
construction
transition
Inception
establishes
business
case
system
elaboration
defines
architecture
construction
implements
system
transition
deploys
system
customer
s
environment
real
time
system
system
recognize
process
external
events
real
time
correctness
system
depend
quickly
Real
time
systems
usually
organized
set
concurrent
processes
@@@@@@@@@@
Glossary
reductionism
engineering
approach
relies
breaking
problem
sub
problems
solving
sub
problems
independently
integrating
solutions
create
solution
larger
problem
reengineering
modification
software
system
make
easier
understand
change
Reengineering
often
involves
software
data
restructuring
organization
program
simplification
redocumentation
reengineering
business
process
Changing
business
process
meet
new
organizational
objective
reduced
cost
faster
execution
refactoring
Modifying
program
improve
structure
readability
without
changing
functionality
reference
architecture
generic
idealized
architecture
includes
features
systems
incorporate
way
informing
designers
general
structure
class
system
rather
basis
creating
specific
system
architecture
release
version
software
system
made
available
system
customers
reliability
ability
system
deliver
services
specified
Reliability
specified
quantitatively
probability
failure
demand
rate
occurrence
failure
reliability
growth
modeling
development
model
reliability
system
changes
improves
tested
program
defects
removed
requirement
functional
statement
function
feature
implemented
system
requirement
non
functional
statement
constraint
expected
behavior
applies
system
constraint
refer
emergent
properties
software
developed
development
process
requirements
management
process
managing
changes
requirements
ensure
changes
made
properly
analyzed
tracked
system
resilience
judgement
well
system
maintain
continuity
critical
services
presence
disruptive
events
equipment
failure
cyberattacks
@@@@@@@@@@
Glossary
REST
REST
Representational
State
Transfer
style
development
based
around
simple
client
server
interaction
uses
HTTP
protocol
communications
REST
based
around
idea
identifiable
resource
URI
interaction
resources
based
HTTP
POST
GET
PUT
DELETE
Widely
used
implementing
low
overhead
web
services
RESTful
services
revision
control
systems
See
version
control
systems
risk
undesirable
outcome
poses
threat
achievement
objective
process
risk
threatens
schedule
cost
process
product
risk
risk
mean
system
requirements
achieved
safety
risk
measure
probability
hazard
lead
accident
risk
management
process
identifying
risks
assessing
severity
planning
measures
put
place
risks
arise
monitoring
software
software
process
risks
Ruby
programming
language
dynamic
types
particularly
well
suited
web
application
programming
SaaS
See
software
service
safety
ability
system
operate
without
behavior
injure
kill
people
damage
system
s
environment
safety
case
body
evidence
structured
argument
evidence
system
safe
secure
Many
critical
systems
associated
safety
cases
assessed
approved
external
regulators
system
certified
use
SAP
German
company
developed
well
known
widely
used
ERP
system
refers
name
given
ERP
system
scenario
description
one
typical
way
system
used
user
carries
activity
scenario
testing
approach
software
testing
test
cases
derived
scenario
system
use
@@@@@@@@@@
Glossary
Scrum
agile
method
development
based
sprints
short
development
cycles
Scrum
used
basis
agile
project
management
alongside
agile
methods
XP
security
ability
system
protect
accidental
deliberate
intrusion
Security
includes
confidentiality
integrity
availability
SEI
Software
Engineering
Institute
software
engineering
research
technology
transfer
center
founded
aim
improving
standard
software
engineering
US
companies
sequence
diagram
diagram
shows
sequence
interactions
required
complete
operation
UML
sequence
diagrams
associated
use
cases
server
program
provides
service
client
programs
service
See
web
service
socio
technical
system
system
including
hardware
software
components
defined
operational
processes
followed
human
operators
operates
organization
therefore
influenced
organizational
policies
procedures
structures
software
analytics
Automated
analysis
static
dynamic
data
software
systems
discover
relationships
data
relationships
provide
insights
possible
ways
improve
quality
software
software
architecture
model
fundamental
structure
organization
software
system
software
service
SaaS
Software
applications
accessed
remotely
web
browser
rather
installed
local
computers
Increasingly
used
deliver
application
services
end
users
software
development
life
cycle
Often
used
another
name
software
process
Originally
coined
refer
waterfall
model
software
process
software
metric
attribute
software
system
process
expressed
numerically
measured
Process
metrics
attributes
process
time
taken
complete
task
product
metrics
attributes
software
size
complexity
@@@@@@@@@@
Glossary
software
process
activities
processes
involved
developing
evolving
software
system
software
product
line
See
application
family
spiral
model
model
development
process
process
represented
spiral
round
spiral
incorporating
different
stages
process
move
one
round
spiral
another
repeat
stages
process
state
diagram
UML
diagram
type
shows
states
system
events
trigger
transition
one
state
another
static
analysis
Tool
based
analysis
program
s
source
code
discover
errors
anomalies
Anomalies
successive
assignments
variable
no
intermediate
use
indicators
programming
errors
structured
method
method
software
design
defines
system
models
developed
rules
guidelines
apply
models
process
followed
developing
design
Structured
Query
Language
SQL
standard
language
used
relational
database
programming
Subversion
widely
used
open
source
version
control
system
building
tool
available
range
platforms
Swiss
cheese
model
model
system
defenses
operator
failure
cyberattack
takes
vulnerabilities
defenses
account
system
system
purposeful
collection
interrelated
components
different
kinds
work
together
deliver
set
services
system
owner
users
system
building
process
compiling
components
units
make
system
linking
components
create
executable
program
System
building
normally
automated
recompilation
minimized
automation
built
language
processing
system
Java
involve
software
tools
support
system
building
systems
engineering
process
concerned
specifying
system
integrating
components
testing
system
meets
requirements
System
engineering
concerned
@@@@@@@@@@
Glossary
whole
socio
technical
system
software
hardware
operational
processes
system
software
system
systems
system
created
integrating
two
existing
systems
system
testing
testing
completed
system
delivered
customers
test
coverage
effectiveness
system
tests
testing
code
entire
system
companies
standards
test
coverage
e
g
system
tests
shall
ensure
program
statements
executed
least
test
driven
development
approach
software
development
executable
tests
written
program
code
set
tests
run
automatically
every
change
program
TOGAF
architectural
framework
supported
Object
Management
Group
intended
support
development
enterprise
architectures
systems
systems
transaction
unit
interaction
computer
system
Transactions
independent
atomic
broken
smaller
units
fundamental
unit
recovery
consistency
concurrency
transaction
processing
system
system
ensures
transactions
processed
way
interfere
individual
transaction
failure
affect
transactions
system
s
data
Unified
Modeling
Language
UML
graphical
language
used
object
oriented
development
includes
several
types
system
model
provide
different
views
system
UML
de
facto
standard
object
oriented
modeling
unit
testing
testing
individual
program
units
software
developer
development
team
use
case
specification
one
type
interaction
system
use
case
diagram
UML
diagram
type
used
identify
use
cases
graphically
depict
users
involved
supplemented
additional
information
completely
describe
use
cases
@@@@@@@@@@
Glossary
user
interface
design
process
designing
way
system
users
access
system
functionality
way
information
produced
system
displayed
user
story
natural
language
description
situation
explains
system
systems
used
interactions
systems
take
place
validation
process
checking
system
meets
needs
expectations
customer
verification
process
checking
system
meets
specification
version
control
process
managing
changes
software
system
components
possible
know
changes
implemented
version
component
system
recover
recreate
previous
versions
component
system
version
control
VC
systems
Software
tools
developed
support
processes
version
control
based
centralized
distributed
repositories
waterfall
model
software
process
model
involves
discrete
development
stages
specification
design
implementation
testing
maintenance
principle
one
stage
complete
progress
next
stage
possible
practice
significant
iteration
stages
web
service
independent
software
component
accessed
Internet
using
standard
protocols
completely
self
contained
without
external
dependencies
XML
based
standards
SOAP
Standard
Object
Access
Protocol
web
service
information
exchange
WSDL
Web
Service
Definition
Language
definition
web
service
interfaces
developed
However
REST
approach
used
web
service
implementation
white
box
testing
approach
program
testing
tests
based
knowledge
structure
program
components
Access
source
code
essential
white
box
testing
wicked
problem
problem
cannot
completely
specified
understood
complexity
interactions
elements
contribute
problem
@@@@@@@@@@
Glossary
wilderness
weather
system
system
collect
data
weather
conditions
remote
areas
Used
case
study
book
workflow
detailed
definition
business
process
intended
accomplish
certain
task
workflow
usually
expressed
graphically
shows
individual
process
activities
information
produced
consumed
activity
WSDL
XML
based
notation
defining
interface
web
services
XML
Extended
Markup
Language
XML
text
markup
language
supports
interchange
structured
data
data
field
delimited
tags
give
information
field
XML
now
widely
used
basis
protocols
web
services
XP
See
Extreme
Programming
Z
model
based
formal
specification
language
developed
University
Oxford
England
@@@@@@@@@@
page
intentionally
left
blank
@@@@@@@@@@@
